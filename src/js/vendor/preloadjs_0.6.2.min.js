/*!
* PreloadJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    /**
     * Static class holding library specific information such as the version and buildDate of the library.
     * @class PreloadJS
     **/
    var s = createjs.PreloadJS = createjs.PreloadJS || {};

    /**
     * The version string for this release.
     * @property version
     * @type {String}
     * @static
     **/
    s.version = /*=version*/"NEXT"; // injected by build process

    /**
     * The build date for this release in UTC format.
     * @property buildDate
     * @type {String}
     * @static
     **/
    s.buildDate = /*=date*/"Wed, 21 Jun 2017 16:42:40 GMT"; // injected by build process

})();

//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 *  function MySubClass() {}
 *  createjs.extend(MySubClass, MySuperClass);
 *  MySubClass.prototype.doSomething = function() { }
 *
 *  var foo = new MySubClass();
 *  console.log(foo instanceof MySuperClass); // true
 *  console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
    "use strict";

    function o() { this.constructor = subclass; }
    o.prototype = superclass.prototype;
    return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 *  function ClassA(name) {
 *      this.name = name;
 *  }
 *  ClassA.prototype.greet = function() {
 *      return "Hello "+this.name;
 *  }
 *
 *  function ClassB(name, punctuation) {
 *      this.ClassA_constructor(name);
 *      this.punctuation = punctuation;
 *  }
 *  createjs.extend(ClassB, ClassA);
 *  ClassB.prototype.greet = function() {
 *      return this.ClassA_greet()+this.punctuation;
 *  }
 *  createjs.promote(ClassB, "ClassA");
 *
 *  var foo = new ClassB("World", "!?!");
 *  console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
    "use strict";

    var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
    if (supP) {
        subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
        for (var n in supP) {
            if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
        }
    }
    return subclass;
};

//##############################################################################
// proxy.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the
 * createjs namespace directly.
 *
 * <h4>Example</h4>
 *
 *      myObject.addEventListener("change", createjs.proxy(myMethod, scope));
 *
 * @class Utility Methods
 * @main Utility Methods
 */

(function() {
    "use strict";

    /**
     * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a
     * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the
     * method gets called in the correct scope.
     *
     * Additional arguments can be passed that will be applied to the function when it is called.
     *
     * <h4>Example</h4>
     *
     *      myObject.addEventListener("event", createjs.proxy(myHandler, this, arg1, arg2));
     *
     *      function myHandler(arg1, arg2) {
     *           // This gets called when myObject.myCallback is executed.
     *      }
     *
     * @method proxy
     * @param {Function} method The function to call
     * @param {Object} scope The scope to call the method name on
     * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.
     * @public
     * @static
     */
    createjs.proxy = function (method, scope) {
        var aArgs = Array.prototype.slice.call(arguments, 2);
        return function () {
            return method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));
        };
    }

}());

//##############################################################################
// indexOf.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
 * that value.  Returns -1 if value is not found.
 *
 *      var i = createjs.indexOf(myArray, myElementToFind);
 *
 * @method indexOf
 * @param {Array} array Array to search for searchElement
 * @param searchElement Element to find in array.
 * @return {Number} The first index of searchElement in array.
 */
createjs.indexOf = function (array, searchElement){
    "use strict";

    for (var i = 0,l=array.length; i < l; i++) {
        if (searchElement === array[i]) {
            return i;
        }
    }
    return -1;
};

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
    "use strict";

// constructor:
    /**
     * Contains properties and methods shared by all events for use with
     * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
     * 
     * Note that Event objects are often reused, so you should never
     * rely on an event object's state outside of the call stack it was received in.
     * @class Event
     * @param {String} type The event type.
     * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
     * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
     * @constructor
     **/
    function Event(type, bubbles, cancelable) {
        
    
    // public properties:
        /**
         * The type of event.
         * @property type
         * @type String
         **/
        this.type = type;
    
        /**
         * The object that generated an event.
         * @property target
         * @type Object
         * @default null
         * @readonly
        */
        this.target = null;
    
        /**
         * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
         * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
         * is generated from childObj, then a listener on parentObj would receive the event with
         * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
         * @property currentTarget
         * @type Object
         * @default null
         * @readonly
        */
        this.currentTarget = null;
    
        /**
         * For bubbling events, this indicates the current event phase:<OL>
         *  <LI> capture phase: starting from the top parent to the target</LI>
         *  <LI> at target phase: currently being dispatched from the target</LI>
         *  <LI> bubbling phase: from the target to the top parent</LI>
         * </OL>
         * @property eventPhase
         * @type Number
         * @default 0
         * @readonly
        */
        this.eventPhase = 0;
    
        /**
         * Indicates whether the event will bubble through the display list.
         * @property bubbles
         * @type Boolean
         * @default false
         * @readonly
        */
        this.bubbles = !!bubbles;
    
        /**
         * Indicates whether the default behaviour of this event can be cancelled via
         * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
         * @property cancelable
         * @type Boolean
         * @default false
         * @readonly
        */
        this.cancelable = !!cancelable;
    
        /**
         * The epoch time at which this event was created.
         * @property timeStamp
         * @type Number
         * @default 0
         * @readonly
        */
        this.timeStamp = (new Date()).getTime();
    
        /**
         * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
         * on this event.
         * @property defaultPrevented
         * @type Boolean
         * @default false
         * @readonly
        */
        this.defaultPrevented = false;
    
        /**
         * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
         * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
         * @property propagationStopped
         * @type Boolean
         * @default false
         * @readonly
        */
        this.propagationStopped = false;
    
        /**
         * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
         * on this event.
         * @property immediatePropagationStopped
         * @type Boolean
         * @default false
         * @readonly
        */
        this.immediatePropagationStopped = false;
        
        /**
         * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
         * @property removed
         * @type Boolean
         * @default false
         * @readonly
        */
        this.removed = false;
    }
    var p = Event.prototype;

// public methods:
    /**
     * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true if the event is cancelable.
     * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will
     * cancel the default behaviour associated with the event.
     * @method preventDefault
     **/
    p.preventDefault = function() {
        this.defaultPrevented = this.cancelable&&true;
    };

    /**
     * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
     * Mirrors the DOM event standard.
     * @method stopPropagation
     **/
    p.stopPropagation = function() {
        this.propagationStopped = true;
    };

    /**
     * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
     * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
     * Mirrors the DOM event standard.
     * @method stopImmediatePropagation
     **/
    p.stopImmediatePropagation = function() {
        this.immediatePropagationStopped = this.propagationStopped = true;
    };
    
    /**
     * Causes the active listener to be removed via removeEventListener();
     * 
     *      myBtn.addEventListener("click", function(evt) {
     *          // do stuff...
     *          evt.remove(); // removes this listener.
     *      });
     * 
     * @method remove
     **/
    p.remove = function() {
        this.removed = true;
    };
    
    /**
     * Returns a clone of the Event instance.
     * @method clone
     * @return {Event} a clone of the Event instance.
     **/
    p.clone = function() {
        return new Event(this.type, this.bubbles, this.cancelable);
    };
    
    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     *
     * @method set
     * @param {Object} props A generic object containing properties to copy to the instance.
     * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
    */
    p.set = function(props) {
        for (var n in props) { this[n] = props[n]; }
        return this;
    };

    /**
     * Returns a string representation of this object.
     * @method toString
     * @return {String} a string representation of the instance.
     **/
    p.toString = function() {
        return "[Event (type="+this.type+")]";
    };

    createjs.Event = Event;
}());

//##############################################################################
// ErrorEvent.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
    "use strict";

    /**
     * A general error {{#crossLink "Event"}}{{/crossLink}}, that describes an error that occurred, as well as any details.
     * @class ErrorEvent
     * @param {String} [title] The error title
     * @param {String} [message] The error description
     * @param {Object} [data] Additional error data
     * @constructor
     */
    function ErrorEvent(title, message, data) {
        this.Event_constructor("error");

        /**
         * The short error title, which indicates the type of error that occurred.
         * @property title
         * @type String
         */
        this.title = title;

        /**
         * The verbose error message, containing details about the error.
         * @property message
         * @type String
         */
        this.message = message;

        /**
         * Additional data attached to an error.
         * @property data
         * @type {Object}
         */
        this.data = data;
    }

    var p = createjs.extend(ErrorEvent, createjs.Event);

    p.clone = function() {
        return new createjs.ErrorEvent(this.title, this.message, this.data);
    };

    createjs.ErrorEvent = createjs.promote(ErrorEvent, "Event");

}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
    "use strict";


// constructor:
    /**
     * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
     *
     * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
     * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
     * 
     * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
     * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
     * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
     * 
     * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
     * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
     * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
     * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
     * 
     * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
     * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
     * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
     *
     * <h4>Example</h4>
     * Add EventDispatcher capabilities to the "MyClass" class.
     *
     *      EventDispatcher.initialize(MyClass.prototype);
     *
     * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
     *
     *      instance.addEventListener("eventName", handlerMethod);
     *      function handlerMethod(event) {
     *          console.log(event.target + " Was Clicked");
     *      }
     *
     * <b>Maintaining proper scope</b><br />
     * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
     * method to subscribe to events simplifies this.
     *
     *      instance.addEventListener("click", function(event) {
     *          console.log(instance == this); // false, scope is ambiguous.
     *      });
     *      
     *      instance.on("click", function(event) {
     *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
     *      });
     * 
     * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage
     * scope.
     *
     * <b>Browser support</b>
     * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model
     * requires modern browsers (IE9+).
     *      
     *
     * @class EventDispatcher
     * @constructor
     **/
    function EventDispatcher() {
    
    
    // private properties:
        /**
         * @protected
         * @property _listeners
         * @type Object
         **/
        this._listeners = null;
        
        /**
         * @protected
         * @property _captureListeners
         * @type Object
         **/
        this._captureListeners = null;
    }
    var p = EventDispatcher.prototype;

// static public methods:
    /**
     * Static initializer to mix EventDispatcher methods into a target object or prototype.
     * 
     *      EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
     *      EventDispatcher.initialize(myObject); // add to a specific instance
     * 
     * @method initialize
     * @static
     * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
     * prototype.
     **/
    EventDispatcher.initialize = function(target) {
        target.addEventListener = p.addEventListener;
        target.on = p.on;
        target.removeEventListener = target.off =  p.removeEventListener;
        target.removeAllEventListeners = p.removeAllEventListeners;
        target.hasEventListener = p.hasEventListener;
        target.dispatchEvent = p.dispatchEvent;
        target._dispatchEvent = p._dispatchEvent;
        target.willTrigger = p.willTrigger;
    };
    

// public methods:
    /**
     * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
     * multiple callbacks getting fired.
     *
     * <h4>Example</h4>
     *
     *      displayObject.addEventListener("click", handleClick);
     *      function handleClick(event) {
     *         // Click happened.
     *      }
     *
     * @method addEventListener
     * @param {String} type The string type of the event.
     * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
     * the event is dispatched.
     * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
     * @return {Function | Object} Returns the listener for chaining or assignment.
     **/
    p.addEventListener = function(type, listener, useCapture) {
        var listeners;
        if (useCapture) {
            listeners = this._captureListeners = this._captureListeners||{};
        } else {
            listeners = this._listeners = this._listeners||{};
        }
        var arr = listeners[type];
        if (arr) { this.removeEventListener(type, listener, useCapture); }
        arr = listeners[type]; // remove may have deleted the array
        if (!arr) { listeners[type] = [listener];  }
        else { arr.push(listener); }
        return listener;
    };
    
    /**
     * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
     * only run once, associate arbitrary data with the listener, and remove the listener.
     * 
     * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
     * The wrapper function is returned for use with `removeEventListener` (or `off`).
     * 
     * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use
     * {{#crossLink "Event/remove"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls
     * to `on` with the same params will create multiple listeners.
     * 
     * <h4>Example</h4>
     * 
     *      var listener = myBtn.on("click", handleClick, null, false, {count:3});
     *      function handleClick(evt, data) {
     *          data.count -= 1;
     *          console.log(this == myBtn); // true - scope defaults to the dispatcher
     *          if (data.count == 0) {
     *              alert("clicked 3 times!");
     *              myBtn.off("click", listener);
     *              // alternately: evt.remove();
     *          }
     *      }
     * 
     * @method on
     * @param {String} type The string type of the event.
     * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
     * the event is dispatched.
     * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
     * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
     * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
     * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
     * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
     **/
    p.on = function(type, listener, scope, once, data, useCapture) {
        if (listener.handleEvent) {
            scope = scope||listener;
            listener = listener.handleEvent;
        }
        scope = scope||this;
        return this.addEventListener(type, function(evt) {
                listener.call(scope, evt, data);
                once&&evt.remove();
            }, useCapture);
    };

    /**
     * Removes the specified event listener.
     *
     * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
     * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
     * closure will not work.
     *
     * <h4>Example</h4>
     *
     *      displayObject.removeEventListener("click", handleClick);
     *
     * @method removeEventListener
     * @param {String} type The string type of the event.
     * @param {Function | Object} listener The listener function or object.
     * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
     **/
    p.removeEventListener = function(type, listener, useCapture) {
        var listeners = useCapture ? this._captureListeners : this._listeners;
        if (!listeners) { return; }
        var arr = listeners[type];
        if (!arr) { return; }
        for (var i=0,l=arr.length; i<l; i++) {
            if (arr[i] == listener) {
                if (l==1) { delete(listeners[type]); } // allows for faster checks.
                else { arr.splice(i,1); }
                break;
            }
        }
    };
    
    /**
     * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
     * .on method.
     * 
     * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See 
     * {{#crossLink "EventDispatcher/on"}}{{/crossLink}} for an example.
     *
     * @method off
     * @param {String} type The string type of the event.
     * @param {Function | Object} listener The listener function or object.
     * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
     **/
    p.off = p.removeEventListener;

    /**
     * Removes all listeners for the specified type, or all listeners of all types.
     *
     * <h4>Example</h4>
     *
     *      // Remove all listeners
     *      displayObject.removeAllEventListeners();
     *
     *      // Remove all click listeners
     *      displayObject.removeAllEventListeners("click");
     *
     * @method removeAllEventListeners
     * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
     **/
    p.removeAllEventListeners = function(type) {
        if (!type) { this._listeners = this._captureListeners = null; }
        else {
            if (this._listeners) { delete(this._listeners[type]); }
            if (this._captureListeners) { delete(this._captureListeners[type]); }
        }
    };

    /**
     * Dispatches the specified event to all listeners.
     *
     * <h4>Example</h4>
     *
     *      // Use a string event
     *      this.dispatchEvent("complete");
     *
     *      // Use an Event instance
     *      var event = new createjs.Event("progress");
     *      this.dispatchEvent(event);
     *
     * @method dispatchEvent
     * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
     * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
     * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can
     * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.
     * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.
     * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.
     * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.
     **/
    p.dispatchEvent = function(eventObj, bubbles, cancelable) {
        if (typeof eventObj == "string") {
            // skip everything if there's no listeners and it doesn't bubble:
            var listeners = this._listeners;
            if (!bubbles && (!listeners || !listeners[eventObj])) { return true; }
            eventObj = new createjs.Event(eventObj, bubbles, cancelable);
        } else if (eventObj.target && eventObj.clone) {
            // redispatching an active event object, so clone it:
            eventObj = eventObj.clone();
        }
        
        // TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent
        try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

        if (!eventObj.bubbles || !this.parent) {
            this._dispatchEvent(eventObj, 2);
        } else {
            var top=this, list=[top];
            while (top.parent) { list.push(top = top.parent); }
            var i, l=list.length;

            // capture & atTarget
            for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
                list[i]._dispatchEvent(eventObj, 1+(i==0));
            }
            // bubbling
            for (i=1; i<l && !eventObj.propagationStopped; i++) {
                list[i]._dispatchEvent(eventObj, 3);
            }
        }
        return !eventObj.defaultPrevented;
    };

    /**
     * Indicates whether there is at least one listener for the specified event type.
     * @method hasEventListener
     * @param {String} type The string type of the event.
     * @return {Boolean} Returns true if there is at least one listener for the specified event.
     **/
    p.hasEventListener = function(type) {
        var listeners = this._listeners, captureListeners = this._captureListeners;
        return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
    };
    
    /**
     * Indicates whether there is at least one listener for the specified event type on this object or any of its
     * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
     * specified type is dispatched from this object, it will trigger at least one listener.
     * 
     * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
     * event flow for a listener, not just this object.
     * @method willTrigger
     * @param {String} type The string type of the event.
     * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
     **/
    p.willTrigger = function(type) {
        var o = this;
        while (o) {
            if (o.hasEventListener(type)) { return true; }
            o = o.parent;
        }
        return false;
    };

    /**
     * @method toString
     * @return {String} a string representation of the instance.
     **/
    p.toString = function() {
        return "[EventDispatcher]";
    };


// private methods:
    /**
     * @method _dispatchEvent
     * @param {Object | Event} eventObj
     * @param {Object} eventPhase
     * @protected
     **/
    p._dispatchEvent = function(eventObj, eventPhase) {
        var l, arr, listeners = (eventPhase <= 2) ? this._captureListeners : this._listeners;
        if (eventObj && listeners && (arr = listeners[eventObj.type]) && (l=arr.length)) {
            try { eventObj.currentTarget = this; } catch (e) {}
            try { eventObj.eventPhase = eventPhase|0; } catch (e) {}
            eventObj.removed = false;
            
            arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
            for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
                var o = arr[i];
                if (o.handleEvent) { o.handleEvent(eventObj); }
                else { o(eventObj); }
                if (eventObj.removed) {
                    this.off(eventObj.type, o, eventPhase==1);
                    eventObj.removed = false;
                }
            }
        }
        if (eventPhase === 2) { this._dispatchEvent(eventObj, 2.1); }
    };


    createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// ProgressEvent.js
//##############################################################################

this.createjs = this.createjs || {};

(function (scope) {
    "use strict";

    // constructor
    /**
     * A CreateJS {{#crossLink "Event"}}{{/crossLink}} that is dispatched when progress changes.
     * @class ProgressEvent
     * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.
     * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is
     * a percentage (between 0 and 1), it can be omitted.
     * @todo Consider having this event be a "fileprogress" event as well
     * @constructor
     */
    function ProgressEvent(loaded, total) {
        this.Event_constructor("progress");

        /**
         * The amount that has been loaded (out of a total amount)
         * @property loaded
         * @type {Number}
         */
        this.loaded = loaded;

        /**
         * The total "size" of the load.
         * @property total
         * @type {Number}
         * @default 1
         */
        this.total = (total == null) ? 1 : total;

        /**
         * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.
         * @property progress
         * @type {Number}
         * @default 0
         */
        this.progress = (total == 0) ? 0 : this.loaded / this.total;
    };

    var p = createjs.extend(ProgressEvent, createjs.Event);

    /**
     * Returns a clone of the ProgressEvent instance.
     * @method clone
     * @return {ProgressEvent} a clone of the Event instance.
     **/
    p.clone = function() {
        return new createjs.ProgressEvent(this.loaded, this.total);
    };

    createjs.ProgressEvent = createjs.promote(ProgressEvent, "Event");

}(window));

//##############################################################################
// json3.js
//##############################################################################

/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

//##############################################################################
// Elements.js
//##############################################################################

(function () {

    /**
     * Convenience methods for creating various elements used by PrelaodJS.
     *
     * @class DomUtils
     */
    var s = {};

    s.a = function() {
        return s.el("a");
    }

    s.svg = function() {
        return s.el("svg");
    }

    s.object = function() {
        return s.el("object");
    }

    s.image = function() {
        return s.el("image");
    }

    s.img = function() {
        return s.el("img");
    }

    s.style = function() {
        return s.el("style");
    }

    s.link = function() {
        return s.el("link");
    }

    s.script = function() {
        return s.el("script");
    }

    s.audio = function() {
        return s.el("audio");
    }

    s.video = function() {
        return s.el("video");
    }

    s.text = function(value) {
        return document.createTextNode(value);
    }

    s.el = function(name) {
        return document.createElement(name);
    }

    createjs.Elements = s;

}());

//##############################################################################
// URLUtils.js
//##############################################################################

(function () {

    /**
     * Utilities that assist with parsing load items, and determining file types, etc.
     * @class URLUtils
     */
    var s = {};

    /**
     * The Regular Expression used to test file URLS for an absolute path.
     * @property ABSOLUTE_PATH
     * @type {RegExp}
     * @static
     */
    s.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i;

    /**
     * The Regular Expression used to test file URLS for a relative path.
     * @property RELATIVE_PATH
     * @type {RegExp}
     * @static
     */
    s.RELATIVE_PATT = (/^[./]*?\//i);

    /**
     * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string
     * removed.
     * @property EXTENSION_PATT
     * @type {RegExp}
     * @static
     */
    s.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i;

    /**
     * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:
     * <ul>
     *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or
     *     `//networkPath`)</li>
     *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>
     *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and
     *     the file path is expected to follow the format `name.ext`.</li>
     * </ul>
     *
     * @method parseURI
     * @param {String} path
     * @returns {Object} An Object with an `absolute` and `relative` Boolean values,
     *  the pieces of the path (protocol, hostname, port, pathname, search, hash, host)
     *  as well as an optional 'extension` property, which is the lowercase extension.
     *
     * @static
     */
    s.parseURI = function (path) {
        var info = {
            absolute: false,
            relative: false,
            protocol: null,
            hostname: null,
            port: null,
            pathname: null,
            search: null,
            hash: null,
            host: null
        };

        if (path == null) { return info; }

        // Inject the path parts.
        var parser = createjs.Elements.a();
        parser.href = path;

        for (var n in info) {
            if (n in parser) {
                info[n] = parser[n];
            }
        }

        // Drop the query string
        var queryIndex = path.indexOf("?");
        if (queryIndex > -1) {
            path = path.substr(0, queryIndex);
        }

        // Absolute
        var match;
        if (s.ABSOLUTE_PATT.test(path)) {
            info.absolute = true;

            // Relative
        } else if (s.RELATIVE_PATT.test(path)) {
            info.relative = true;
        }

        // Extension
        if (match = path.match(s.EXTENSION_PATT)) {
            info.extension = match[1].toLowerCase();
        }

        return info;
    };

    /**
     * Formats an object into a query string for either a POST or GET request.
     * @method formatQueryString
     * @param {Object} data The data to convert to a query string.
     * @param {Array} [query] Existing name/value pairs to append on to this query.
     * @static
     */
    s.formatQueryString = function (data, query) {
        if (data == null) {
            throw new Error("You must specify data.");
        }
        var params = [];
        for (var n in data) {
            params.push(n + "=" + escape(data[n]));
        }
        if (query) {
            params = params.concat(query);
        }
        return params.join("&");
    };

    /**
     * A utility method that builds a file path using a source and a data object, and formats it into a new path.
     * @method buildURI
     * @param {String} src The source path to add values to.
     * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the
     * path will be preserved.
     * @returns {string} A formatted string that contains the path and the supplied parameters.
     * @static
     */
    s.buildURI = function (src, data) {
        if (data == null) {
            return src;
        }

        var query = [];
        var idx = src.indexOf("?");

        if (idx != -1) {
            var q = src.slice(idx + 1);
            query = query.concat(q.split("&"));
        }

        if (idx != -1) {
            return src.slice(0, idx) + "?" + this.formatQueryString(data, query);
        } else {
            return src + "?" + this.formatQueryString(data, query);
        }
    };

    /**
     * @method isCrossDomain
     * @param {LoadItem|Object} item A load item with a `src` property.
     * @return {Boolean} If the load item is loading from a different domain than the current location.
     * @static
     */
    s.isCrossDomain = function (item) {
        var target = createjs.Elements.a();
        target.href = item.src;

        var host = createjs.Elements.a();
        host.href = location.href;

        var crossdomain = (target.hostname != "") &&
            (target.port != host.port ||
            target.protocol != host.protocol ||
            target.hostname != host.hostname);
        return crossdomain;
    };

    /**
     * @method isLocal
     * @param {LoadItem|Object} item A load item with a `src` property
     * @return {Boolean} If the load item is loading from the "file:" protocol. Assume that the host must be local as
     * well.
     * @static
     */
    s.isLocal = function (item) {
        var target = createjs.Elements.a();
        target.href = item.src;
        return target.hostname == "" && target.protocol == "file:";
    };

    createjs.URLUtils = s;

}());

//##############################################################################
// DomUtils.js
//##############################################################################

(function () {

    /**
     * A few utilities for interacting with the dom.
     * @class DomUtils
     */
    var s = {
        container: null
    };

    s.appendToHead = function (el) {
        s.getHead().appendChild(el);
    }

    s.appendToBody = function (el) {
        if (s.container == null) {
            s.container = document.createElement("div");
            s.container.id = "preloadjs-container";
            var style = s.container.style;
            style.visibility = "hidden";
            style.position = "absolute";
            style.width = s.container.style.height = "10px";
            style.overflow = "hidden";
            style.transform = style.msTransform = style.webkitTransform = style.oTransform = "translate(-10px, -10px)"; //LM: Not working
            s.getBody().appendChild(s.container);
        }
        s.container.appendChild(el);
    }

    s.getHead = function () {
        return document.head || document.getElementsByTagName("head")[0];
    }

    s.getBody = function () {
        return document.body || document.getElementsByTagName("body")[0];
    }

    s.removeChild = function(el) {
        if (el.parent) {
            el.parent.removeChild(el);
        }
    }

    /**
     * Check if item is a valid HTMLImageElement
     * @method isImageTag
     * @param {Object} item
     * @returns {Boolean}
     * @static
     */
    s.isImageTag = function(item) {
        return item instanceof HTMLImageElement;
    };

    /**
     * Check if item is a valid HTMLAudioElement
     * @method isAudioTag
     * @param {Object} item
     * @returns {Boolean}
     * @static
     */
    s.isAudioTag = function(item) {
        if (window.HTMLAudioElement) {
            return item instanceof HTMLAudioElement;
        } else {
            return false;
        }
    };

    /**
     * Check if item is a valid HTMLVideoElement
     * @method isVideoTag
     * @param {Object} item
     * @returns {Boolean}
     * @static
     */
    s.isVideoTag = function(item) {
        if (window.HTMLVideoElement) {
            return item instanceof HTMLVideoElement;
        } else {
            return false;
        }
    };

    createjs.DomUtils = s;

}());

//##############################################################################
// DataUtils.js
//##############################################################################

(function () {

    /**
     * A few data utilities for formatting different data types.
     * @class DataUtils
     */
    var s = {};

    // static methods
    /**
     * Parse XML using the DOM. This is required when preloading XML or SVG.
     * @method parseXML
     * @param {String} text The raw text or XML that is loaded by XHR.
     * @return {XML} An XML document
     * @static
     */
    s.parseXML = function (text) {
        var xml = null;
        // CocoonJS does not support XML parsing with either method.

        // Most browsers will use DOMParser
        // IE fails on certain SVG files, so we have a fallback below.
        try {
            if (window.DOMParser) {
                var parser = new DOMParser();
                xml = parser.parseFromString(text, "text/xml");
            }
        } catch (e) {
        }

        // Fallback for IE support.
        if (!xml) {
            try {
                xml = new ActiveXObject("Microsoft.XMLDOM");
                xml.async = false;
                xml.loadXML(text);
            } catch (e) {
                xml = null;
            }
        }

        return xml;
    };

    /**
     * Parse a string into an Object.
     * @method parseJSON
     * @param {String} value The loaded JSON string
     * @returns {Object} A JavaScript object.
     */
    s.parseJSON = function (value) {
        if (value == null) {
            return null;
        }

        try {
            return JSON.parse(value);
        } catch (e) {
            // TODO; Handle this with a custom error?
            throw e;
        }
    };

    createjs.DataUtils = s;

}());

//##############################################################################
// Types.js
//##############################################################################

this.createjs = this.createjs || {};

(function() {
    var s = {};

    /**
     * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.
     * @property BINARY
     * @type {String}
     * @default binary
     * @static
     * @since 0.6.0
     */
    s.BINARY = "binary";

    /**
     * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a
     * &lt;style&gt; tag when loaded with tags.
     * @property CSS
     * @type {String}
     * @default css
     * @static
     * @since 0.6.0
     */
    s.CSS = "css";

    /**
     * The preload type for font files.
     * @property FONT
     * @type {String}
     * @default font
     * @static
     * @since 0.9.0
     */
    s.FONT = "font";

    /**
     * The preload type for fonts specified with CSS (such as Google fonts)
     * @property FONTCSS
     * @type {String}
     * @default fontcss
     * @static
     * @since 0.9.0
     */
    s.FONTCSS = "fontcss";

    /**
     * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.
     * @property IMAGE
     * @type {String}
     * @default image
     * @static
     * @since 0.6.0
     */
    s.IMAGE = "image";

    /**
     * The preload type for javascript files, usually with the "js" file extension. JavaScript files are loaded into a
     * &lt;script&gt; tag.
     *
     * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into
     * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,
     * only tag-loaded scripts are injected.
     * @property JAVASCRIPT
     * @type {String}
     * @default javascript
     * @static
     * @since 0.6.0
     */
    s.JAVASCRIPT = "javascript";

    /**
     * The preload type for json files, usually with the "json" file extension. JSON data is loaded and parsed into a
     * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,
     * no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to, and the JSON
     * must contain a matching wrapper function.
     * @property JSON
     * @type {String}
     * @default json
     * @static
     * @since 0.6.0
     */
    s.JSON = "json";

    /**
     * The preload type for jsonp files, usually with the "json" file extension. JSON data is loaded and parsed into a
     * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.
     * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}}
     * property is set to.
     * @property JSONP
     * @type {String}
     * @default jsonp
     * @static
     * @since 0.6.0
     */
    s.JSONP = "jsonp";

    /**
     * The preload type for json-based manifest files, usually with the "json" file extension. The JSON data is loaded
     * and parsed into a JavaScript object. PreloadJS will then look for a "manifest" property in the JSON, which is an
     * Array of files to load, following the same format as the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
     * method. If a "callback" is specified on the manifest object, then it will be loaded using JSONP instead,
     * regardless of what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to.
     * @property MANIFEST
     * @type {String}
     * @default manifest
     * @static
     * @since 0.6.0
     */
    s.MANIFEST = "manifest";

    /**
     * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an
     * &lt;audio&gt; tag.
     * @property SOUND
     * @type {String}
     * @default sound
     * @static
     * @since 0.6.0
     */
    s.SOUND = "sound";

    /**
     * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an
     * &lt;video&gt; tag.
     * @property VIDEO
     * @type {String}
     * @default video
     * @static
     * @since 0.6.0
     */
    s.VIDEO = "video";

    /**
     * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.
     * @property SPRITESHEET
     * @type {String}
     * @default spritesheet
     * @static
     * @since 0.6.0
     */
    s.SPRITESHEET = "spritesheet";

    /**
     * The preload type for SVG files.
     * @property SVG
     * @type {String}
     * @default svg
     * @static
     * @since 0.6.0
     */
    s.SVG = "svg";

    /**
     * The preload type for text files, which is also the default file type if the type can not be determined. Text is
     * loaded as raw text.
     * @property TEXT
     * @type {String}
     * @default text
     * @static
     * @since 0.6.0
     */
    s.TEXT = "text";

    /**
     * The preload type for xml files. XML is loaded into an XML document.
     * @property XML
     * @type {String}
     * @default xml
     * @static
     * @since 0.6.0
     */
    s.XML = "xml";

    createjs.Types = s;
}());

//##############################################################################
// Methods.js
//##############################################################################

this.createjs = this.createjs || {};

(function() {
    var s = {};

    /**
     * Defines a POST request, use for a method value when loading data.
     * @property POST
     * @type {string}
     * @default post
     * @static
     */
    s.POST = "POST";

    /**
     * Defines a GET request, use for a method value when loading data.
     * @property GET
     * @type {string}
     * @default get
     * @static
     */
    s.GET = "GET";

    createjs.Methods = s;
}());

//##############################################################################
// LoadItem.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    /**
     * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,
     * it will not be affected, but it must contain at least a {{#crossLink "src:property"}}{{/crossLink}} property. A
     * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the
     * {{#crossLink "create"}}{{/crossLink}} method by {{#crossLink "AbstractLoader"}}{{/crossLink}}
     * @class LoadItem
     * @constructor
     * @since 0.6.0
     */
    function LoadItem() {
        /**
         * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a
         * string (recommended), or an HTML tag.
         * This can also be an object, but in that case it has to include a type and be handled by a plugin.
         * @property src
         * @type {String}
         * @default null
         */
        this.src = null;

        /**
         * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also
         * be set manually. This is helpful in cases where a file does not have an extension.
         * @property type
         * @type {String}
         * @default null
         */
        this.type = null;

        /**
         * A string identifier which can be used to reference the loaded object. If none is provided, this will be
         * automatically set to the {{#crossLink "src:property"}}{{/crossLink}}.
         * @property id
         * @type {String}
         * @default null
         */
        this.id = null;

        /**
         * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest
         * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has
         * been set above 1 (using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}). Everything with this
         * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in
         * order when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}} is set to `true`.
         * @property maintainOrder
         * @type {Boolean}
         * @default false
         */
        this.maintainOrder = false;

        /**
         * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.
         * @property callback
         * @type {String}
         * @default null
         */
        this.callback = null;

        /**
         * An arbitrary data object, which is included with the loaded object.
         * @property data
         * @type {Object}
         * @default null
         */
        this.data = null;

        /**
         * The request method used for HTTP calls. Both {{#crossLink "Methods/GET:property"}}{{/crossLink}} or
         * {{#crossLink "Methods/POST:property"}}{{/crossLink}} request types are supported, and are defined as
         * constants on {{#crossLink "AbstractLoader"}}{{/crossLink}}.
         * @property method
         * @type {String}
         * @default GET
         */
        this.method = createjs.Methods.GET;

        /**
         * An object hash of name/value pairs to send to the server.
         * @property values
         * @type {Object}
         * @default null
         */
        this.values = null;

        /**
         * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default
         * headers when required, including "Origin", "Content-Type", and "X-Requested-With". You may override the
         * default headers by including them in your headers object.
         * @property headers
         * @type {Object}
         * @default null
         */
        this.headers = null;

        /**
         * Enable credentials for XHR requests.
         * @property withCredentials
         * @type {Boolean}
         * @default false
         */
        this.withCredentials = false;

        /**
         * Set the mime type of XHR-based requests. This is automatically set to "text/plain; charset=utf-8" for text
         * based files (json, xml, text, css, js).
         * @property mimeType
         * @type {String}
         * @default null
         */
        this.mimeType = null;

        /**
         * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.
         * @property crossOrigin
         * @type {boolean}
         * @default Anonymous
         */
        this.crossOrigin = null;

        /**
         * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
         * (level one) loading, as XHR (level 2) provides its own timeout event.
         * @property loadTimeout
         * @type {Number}
         * @default 8000 (8 seconds)
         */
        this.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
    };

    var p = LoadItem.prototype = {};
    var s = LoadItem;

    /**
     * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
     * (level one) loading, as XHR (level 2) provides its own timeout event.
     * @property LOAD_TIMEOUT_DEFAULT
     * @type {number}
     * @static
     */
    s.LOAD_TIMEOUT_DEFAULT = 8000;

    /**
     * Create a LoadItem.
     * <ul>
     *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink "src:property"}}{{/crossLink}}.</li>
     *     <li>LoadItem instances are returned as-is</li>
     *     <li>Objects are returned with any needed properties added</li>
     * </ul>
     * @method create
     * @param {LoadItem|String|Object} value The load item value
     * @returns {LoadItem|Object}
     * @static
     */
    s.create = function (value) {
        if (typeof value == "string") {
            var item = new LoadItem();
            item.src = value;
            return item;
        } else if (value instanceof s) {
            return value;
        } else if (value instanceof Object && value.src) {
            if (value.loadTimeout == null) {
                value.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
            }
            return value;
        } else {
            throw new Error("Type not recognized.");
        }
    };

    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     *
     * <h4>Example</h4>
     *
     *      var loadItem = new createjs.LoadItem().set({src:"image.png", maintainOrder:true});
     *
     * @method set
     * @param {Object} props A generic object containing properties to copy to the LoadItem instance.
     * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)
    */
    p.set = function(props) {
        for (var n in props) { this[n] = props[n]; }
        return this;
    };

    createjs.LoadItem = s;

}());

//##############################################################################
// RequestUtils.js
//##############################################################################

(function () {

    /**
     * Utilities that assist with parsing load items, and determining file types, etc.
     * @class RequestUtils
     */
    var s = {};

    /**
     * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked
     * specifically as "binary" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play
     * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get
     * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on
     * {{#crossLink "AbstractLoader"}}{{/crossLink}}.
     * @method isBinary
     * @param {String} type The item type.
     * @return {Boolean} If the specified type is binary.
     * @static
     */
    s.isBinary = function (type) {
        switch (type) {
            case createjs.Types.IMAGE:
            case createjs.Types.BINARY:
                return true;
            default:
                return false;
        }
    };

    /**
     * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.
     * @method isText
     * @param {String} type The item type.
     * @return {Boolean} If the specified type is text.
     * @static
     */
    s.isText = function (type) {
        switch (type) {
            case createjs.Types.TEXT:
            case createjs.Types.JSON:
            case createjs.Types.MANIFEST:
            case createjs.Types.XML:
            case createjs.Types.CSS:
            case createjs.Types.SVG:
            case createjs.Types.JAVASCRIPT:
            case createjs.Types.SPRITESHEET:
                return true;
            default:
                return false;
        }
    };

    /**
     * Determine the type of the object using common extensions. Note that the type can be passed in with the load item
     * if it is an unusual extension.
     * @method getTypeByExtension
     * @param {String} extension The file extension to use to determine the load type.
     * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if
     * the type can not be determined by the extension.
     * @static
     */
    s.getTypeByExtension = function (extension) {
        if (extension == null) {
            return createjs.Types.TEXT;
        }

        switch (extension.toLowerCase()) {
            case "jpeg":
            case "jpg":
            case "gif":
            case "png":
            case "webp":
            case "bmp":
                return createjs.Types.IMAGE;
            case "ogg":
            case "mp3":
            case "webm":
                return createjs.Types.SOUND;
            case "mp4":
            case "webm":
            case "ts":
                return createjs.Types.VIDEO;
            case "json":
                return createjs.Types.JSON;
            case "xml":
                return createjs.Types.XML;
            case "css":
                return createjs.Types.CSS;
            case "js":
                return createjs.Types.JAVASCRIPT;
            case 'svg':
                return createjs.Types.SVG;
            default:
                return createjs.Types.TEXT;
        }
    };

    createjs.RequestUtils = s;

}());

//##############################################################################
// AbstractLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

// constructor
    /**
     * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,
     * including the {{#crossLink "LoadQueue"}}{{/crossLink}}.
     * @class AbstractLoader
     * @param {LoadItem|object|string} loadItem The item to be loaded.
     * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a
     * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the
     * other, so this is a suggested directive.
     * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,
     * such as {{#crossLink "IMAGE:property"}}{{/crossLink}}, {{#crossLink "CSS:property"}}{{/crossLink}}, etc.
     * @extends EventDispatcher
     */
    function AbstractLoader(loadItem, preferXHR, type) {
        this.EventDispatcher_constructor();

        // public properties
        /**
         * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches
         * used for loading do not pile up resulting in more than one `complete` {{#crossLink "Event"}}{{/crossLink}}.
         * @property loaded
         * @type {Boolean}
         * @default false
         */
        this.loaded = false;

        /**
         * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property
         * is readonly, so {{#crossLink "LoadQueue"}}{{/crossLink}} queues should be closed using {{#crossLink "LoadQueue/close"}}{{/crossLink}}
         * instead.
         * @property canceled
         * @type {Boolean}
         * @default false
         * @readonly
         */
        this.canceled = false;

        /**
         * The current load progress (percentage) for this item. This will be a number between 0 and 1.
         *
         * <h4>Example</h4>
         *
         *     var queue = new createjs.LoadQueue();
         *     queue.loadFile("largeImage.png");
         *     queue.on("progress", function() {
         *         console.log("Progress:", queue.progress, event.progress);
         *     });
         *
         * @property progress
         * @type {Number}
         * @default 0
         */
        this.progress = 0;

        /**
         * The type of item this loader will load. See {{#crossLink "AbstractLoader"}}{{/crossLink}} for a full list of
         * supported types.
         * @property type
         * @type {String}
         */
        this.type = type;

        /**
         * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader
         * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property
         * can be overridden to provide custom formatting.
         *
         * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be
         * asynchronous, such as creating a new image. The callback function is passed 2 parameters, which are callbacks
         * to handle success and error conditions in the resultFormatter. Note that the resultFormatter method is
         * called in the current scope, as well as the success and error callbacks.
         *
         * <h4>Example asynchronous resultFormatter</h4>
         *
         *  function _formatResult(loader) {
         *      return function(success, error) {
         *          if (errorCondition) { error(errorDetailEvent); }
         *          success(result);
         *      }
         *  }
         * @property resultFormatter
         * @type {Function}
         * @default null
         */
        this.resultFormatter = null;

        // protected properties
        /**
         * The {{#crossLink "LoadItem"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink "LoadQueue"}}{{/crossLink}},
         * but will be available on loaders such as {{#crossLink "XMLLoader"}}{{/crossLink}} and {{#crossLink "ImageLoader"}}{{/crossLink}}.
         * @property _item
         * @type {LoadItem|Object}
         * @private
         */
        if (loadItem) {
            this._item = createjs.LoadItem.create(loadItem);
        } else {
            this._item = null;
        }

        /**
         * Whether the loader will try and load content using XHR (true) or HTML tags (false).
         * @property _preferXHR
         * @type {Boolean}
         * @private
         */
        this._preferXHR = preferXHR;

        /**
         * The loaded result after it is formatted by an optional {{#crossLink "resultFormatter"}}{{/crossLink}}. For
         * items that are not formatted, this will be the same as the {{#crossLink "_rawResult:property"}}{{/crossLink}}.
         * The result is accessed using the {{#crossLink "getResult"}}{{/crossLink}} method.
         * @property _result
         * @type {Object|String}
         * @private
         */
        this._result = null;

        /**
         * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink "getResult"}}{{/crossLink}}
         * method, and passing `true`.
         * @property _rawResult
         * @type {Object|String}
         * @private
         */
        this._rawResult = null;

        /**
         * A list of items that loaders load behind the scenes. This does not include the main item the loader is
         * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink "SpriteSheetLoader"}}{{/crossLink}} and
         * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
         * @property _loadItems
         * @type {null}
         * @protected
         */
        this._loadedItems = null;

        /**
         * The attribute the items loaded using tags use for the source.
         * @type {string}
         * @default null
         * @private
         */
        this._tagSrcAttribute = null;

        /**
         * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.
         * @property _tag
         * @type {Object}
         * @private
         */
        this._tag = null;
    };

    var p = createjs.extend(AbstractLoader, createjs.EventDispatcher);
    var s = AbstractLoader;

// Events
    /**
     * The {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when the overall progress changes. Prior to
     * version 0.6.0, this was just a regular {{#crossLink "Event"}}{{/crossLink}}.
     * @event progress
     * @since 0.3.0
     */

    /**
     * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a load starts.
     * @event loadstart
     * @param {Object} target The object that dispatched the event.
     * @param {String} type The event type.
     * @since 0.3.1
     */

    /**
     * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the entire queue has been loaded.
     * @event complete
     * @param {Object} target The object that dispatched the event.
     * @param {String} type The event type.
     * @since 0.3.0
     */

    /**
     * The {{#crossLink "ErrorEvent"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was
     * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was
     * just a regular {{#crossLink "Event"}}{{/crossLink}}.
     * @event error
     * @since 0.3.0
     */

    /**
     * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.
     * This enables loaders to maintain internal queues, and surface file load errors.
     * @event fileerror
     * @param {Object} target The object that dispatched the event.
     * @param {String} type The event type ("fileerror")
     * @param {LoadItem|object} The item that encountered the error
     * @since 0.6.0
     */

    /**
     * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables
     * loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}} to maintain internal {{#crossLink "LoadQueue"}}{{/crossLink}}s
     * and notify when they have loaded a file. The {{#crossLink "LoadQueue"}}{{/crossLink}} class dispatches a
     * slightly different {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event.
     * @event fileload
     * @param {Object} target The object that dispatched the event.
     * @param {String} type The event type ("fileload")
     * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
     * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
     * object will contain that value as a `src` property.
     * @param {Object} result The HTML tag or parsed result of the loaded item.
     * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
     * to a usable object.
     * @since 0.6.0
     */

    /**
     * The {{#crossLink "Event"}}{{/crossLink}} that is fired after the internal request is created, but before a load.
     * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.
     * @event initialize
     * @param {Object} target The object that dispatched the event.
     * @param {String} type The event type ("initialize")
     * @param {AbstractLoader} loader The loader that has been initialized.
     */


    /**
     * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was
     * passed into {{#crossLink "LoadQueue"}}{{/crossLink}} using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
     * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. However if only a String path was passed in, then it will
     * be a {{#crossLink "LoadItem"}}{{/crossLink}}.
     * @method getItem
     * @return {Object} The manifest item that this loader is responsible for loading.
     * @since 0.6.0
     */
    p.getItem = function () {
        return this._item;
    };

    /**
     * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink "complete:event"}}{{/crossLink}}
     * event is dispatched.
     * @method getResult
     * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded
     * data (if it exists).
     * @return {Object}
     * @since 0.6.0
     */
    p.getResult = function (raw) {
        return raw ? this._rawResult : this._result;
    };

    /**
     * Return the `tag` this object creates or uses for loading.
     * @method getTag
     * @return {Object} The tag instance
     * @since 0.6.0
     */
    p.getTag = function () {
        return this._tag;
    };

    /**
     * Set the `tag` this item uses for loading.
     * @method setTag
     * @param {Object} tag The tag instance
     * @since 0.6.0
     */
    p.setTag = function(tag) {
      this._tag = tag;
    };

    /**
     * Begin loading the item. This method is required when using a loader by itself.
     *
     * <h4>Example</h4>
     *
     *      var queue = new createjs.LoadQueue();
     *      queue.on("complete", handleComplete);
     *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet
     *      queue.load();
     *
     * @method load
     */
    p.load = function () {
        this._createRequest();

        this._request.on("complete", this, this);
        this._request.on("progress", this, this);
        this._request.on("loadStart", this, this);
        this._request.on("abort", this, this);
        this._request.on("timeout", this, this);
        this._request.on("error", this, this);

        var evt = new createjs.Event("initialize");
        evt.loader = this._request;
        this.dispatchEvent(evt);

        this._request.load();
    };

    /**
     * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in
     * the background), but events will not longer be dispatched.
     * @method cancel
     */
    p.cancel = function () {
        this.canceled = true;
        this.destroy();
    };

    /**
     * Clean up the loader.
     * @method destroy
     */
    p.destroy = function() {
        if (this._request) {
            this._request.removeAllEventListeners();
            this._request.destroy();
        }

        this._request = null;

        this._item = null;
        this._rawResult = null;
        this._result = null;

        this._loadItems = null;

        this.removeAllEventListeners();
    };

    /**
     * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}}
     * to expose items it loads internally.
     * @method getLoadedItems
     * @return {Array} A list of the items loaded by the loader.
     * @since 0.6.0
     */
    p.getLoadedItems = function () {
        return this._loadedItems;
    };


    // Private methods
    /**
     * Create an internal request used for loading. By default, an {{#crossLink "XHRRequest"}}{{/crossLink}} or
     * {{#crossLink "TagRequest"}}{{/crossLink}} is created, depending on the value of {{#crossLink "preferXHR:property"}}{{/crossLink}}.
     * Other loaders may override this to use different request types, such as {{#crossLink "ManifestLoader"}}{{/crossLink}},
     * which uses {{#crossLink "JSONLoader"}}{{/crossLink}} or {{#crossLink "JSONPLoader"}}{{/crossLink}} under the hood.
     * @method _createRequest
     * @protected
     */
    p._createRequest = function() {
        if (!this._preferXHR) {
            this._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
        } else {
            this._request = new createjs.XHRRequest(this._item);
        }
    };

    /**
     * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented
     * by loaders that require tag loading.
     * @method _createTag
     * @param {String} src The tag source
     * @return {HTMLElement} The tag that was created
     * @protected
     */
    p._createTag = function(src) { return null; };

    /**
     * Dispatch a loadstart {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/loadstart:event"}}{{/crossLink}}
     * event for details on the event payload.
     * @method _sendLoadStart
     * @protected
     */
    p._sendLoadStart = function () {
        if (this._isCanceled()) { return; }
        this.dispatchEvent("loadstart");
    };

    /**
     * Dispatch a {{#crossLink "ProgressEvent"}}{{/crossLink}}.
     * @method _sendProgress
     * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>
     * and <code>total</code> properties.
     * @protected
     */
    p._sendProgress = function (value) {
        if (this._isCanceled()) { return; }
        var event = null;
        if (typeof(value) == "number") {
            this.progress = value;
            event = new createjs.ProgressEvent(this.progress);
        } else {
            event = value;
            this.progress = value.loaded / value.total;
            event.progress = this.progress;
            if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
        }
        this.hasEventListener("progress") && this.dispatchEvent(event);
    };

    /**
     * Dispatch a complete {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}} event
     * @method _sendComplete
     * @protected
     */
    p._sendComplete = function () {
        if (this._isCanceled()) { return; }

        this.loaded = true;

        var event = new createjs.Event("complete");
        event.rawResult = this._rawResult;

        if (this._result != null) {
            event.result = this._result;
        }

        this.dispatchEvent(event);
    };

    /**
     * Dispatch an error {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
     * event for details on the event payload.
     * @method _sendError
     * @param {ErrorEvent} event The event object containing specific error properties.
     * @protected
     */
    p._sendError = function (event) {
        if (this._isCanceled() || !this.hasEventListener("error")) { return; }
        if (event == null) {
            event = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY"); // TODO: Populate error
        }
        this.dispatchEvent(event);
    };

    /**
     * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events
     * do not cause issues after the queue has been cleaned up.
     * @method _isCanceled
     * @return {Boolean} If the loader has been canceled.
     * @protected
     */
    p._isCanceled = function () {
        if (window.createjs == null || this.canceled) {
            return true;
        }
        return false;
    };

    /**
     * A custom result formatter function, which is called just before a request dispatches its complete event. Most
     * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The
     * formatted result will be available on Loaders using {{#crossLink "getResult"}}{{/crossLink}}, and passing `true`.
     * @property resultFormatter
     * @type Function
     * @return {Object} The formatted result
     * @since 0.6.0
     */
    p.resultFormatter = null;

    /**
     * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but
     * this method can be overridden for custom behaviours.
     * @method handleEvent
     * @param {Event} event The event that the internal request dispatches.
     * @protected
     * @since 0.6.0
     */
    p.handleEvent = function (event) {
        switch (event.type) {
            case "complete":
                this._rawResult = event.target._response;
                var result = this.resultFormatter && this.resultFormatter(this);
                // The resultFormatter is asynchronous
                if (result instanceof Function) {
                    result.call(this,
                            createjs.proxy(this._resultFormatSuccess, this),
                            createjs.proxy(this._resultFormatFailed, this)
                    );
                // The result formatter is synchronous
                } else {
                    this._result =  result || this._rawResult;
                    this._sendComplete();
                }
                break;
            case "progress":
                this._sendProgress(event);
                break;
            case "error":
                this._sendError(event);
                break;
            case "loadstart":
                this._sendLoadStart();
                break;
            case "abort":
            case "timeout":
                if (!this._isCanceled()) {
                    this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_" + event.type.toUpperCase() + "_ERROR"));
                }
                break;
        }
    };

    /**
     * The "success" callback passed to {{#crossLink "AbstractLoader/resultFormatter"}}{{/crossLink}} asynchronous
     * functions.
     * @method _resultFormatSuccess
     * @param {Object} result The formatted result
     * @private
     */
    p._resultFormatSuccess = function (result) {
        this._result = result;
        this._sendComplete();
    };

    /**
     * The "error" callback passed to {{#crossLink "AbstractLoader/resultFormatter"}}{{/crossLink}} asynchronous
     * functions.
     * @method _resultFormatSuccess
     * @param {Object} error The error event
     * @private
     */
    p._resultFormatFailed = function (event) {
        this._sendError(event);
    };

    /**
     * @method toString
     * @return {String} a string representation of the instance.
     */
    p.toString = function () {
        return "[PreloadJS AbstractLoader]";
    };

    createjs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher");

}());

//##############################################################################
// AbstractMediaLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that
     * handle HTML media elements, such as Video and Audio.
     * @class AbstractMediaLoader
     * @param {LoadItem|Object} loadItem
     * @param {Boolean} preferXHR
     * @param {String} type The type of media to load. Usually "video" or "audio".
     * @extends AbstractLoader
     * @constructor
     */
    function AbstractMediaLoader(loadItem, preferXHR, type) {
        this.AbstractLoader_constructor(loadItem, preferXHR, type);

        // public properties
        this.resultFormatter = this._formatResult;

        // protected properties
        this._tagSrcAttribute = "src";

        this.on("initialize", this._updateXHR, this);
    };

    var p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);

    // static properties
    // public methods
    p.load = function () {
        // TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.
        if (!this._tag) {
            this._tag = this._createTag(this._item.src);
        }

        this._tag.preload = "auto";
        this._tag.load();

        this.AbstractLoader_load();
    };

    // protected methods
    /**
     * Creates a new tag for loading if it doesn't exist yet.
     * @method _createTag
     * @private
     */
    p._createTag = function () {};


    p._createRequest = function() {
        if (!this._preferXHR) {
            this._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
        } else {
            this._request = new createjs.XHRRequest(this._item);
        }
    };

    // protected methods
    /**
     * Before the item loads, set its mimeType and responseType.
     * @property _updateXHR
     * @param {Event} event
     * @private
     */
    p._updateXHR = function (event) {
        // Only exists for XHR
        if (event.loader.setResponseType) {
            event.loader.setResponseType("blob");
        }
    };

    /**
     * The result formatter for media files.
     * @method _formatResult
     * @param {AbstractLoader} loader
     * @returns {HTMLVideoElement|HTMLAudioElement}
     * @private
     */
    p._formatResult = function (loader) {
        this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
        this._tag.onstalled = null;
        if (this._preferXHR) {
            var URL = window.URL || window.webkitURL;
            var result = loader.getResult(true);

            loader.getTag().src = URL.createObjectURL(result);
        }
        return loader.getTag();
    };

    createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader");

}());

//##############################################################################
// AbstractRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    /**
     * A base class for actual data requests, such as {{#crossLink "XHRRequest"}}{{/crossLink}}, {{#crossLink "TagRequest"}}{{/crossLink}},
     * and {{#crossLink "MediaRequest"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the
     * hood to get data.
     * @class AbstractRequest
     * @param {LoadItem} item
     * @constructor
     */
    var AbstractRequest = function (item) {
        this._item = item;
    };

    var p = createjs.extend(AbstractRequest, createjs.EventDispatcher);

    // public methods
    /**
     * Begin a load.
     * @method load
     */
    p.load =  function() {};

    /**
     * Clean up a request.
     * @method destroy
     */
    p.destroy = function() {};

    /**
     * Cancel an in-progress request.
     * @method cancel
     */
    p.cancel = function() {};

    createjs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher");

}());

//##############################################################################
// TagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * An {{#crossLink "AbstractRequest"}}{{/crossLink}} that loads HTML tags, such as images and scripts.
     * @class TagRequest
     * @param {LoadItem} loadItem
     * @param {HTMLElement} tag
     * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
     */
    function TagRequest(loadItem, tag, srcAttribute) {
        this.AbstractRequest_constructor(loadItem);

        // protected properties
        /**
         * The HTML tag instance that is used to load.
         * @property _tag
         * @type {HTMLElement}
         * @protected
         */
        this._tag = tag;

        /**
         * The tag attribute that specifies the source, such as "src", "href", etc.
         * @property _tagSrcAttribute
         * @type {String}
         * @protected
         */
        this._tagSrcAttribute = srcAttribute;

        /**
         * A method closure used for handling the tag load event.
         * @property _loadedHandler
         * @type {Function}
         * @private
         */
        this._loadedHandler = createjs.proxy(this._handleTagComplete, this);

        /**
         * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.
         * @property _addedToDOM
         * @type {Boolean}
         * @private
         */
        this._addedToDOM = false;

    };

    var p = createjs.extend(TagRequest, createjs.AbstractRequest);

    // public methods
    p.load = function () {
        this._tag.onload = createjs.proxy(this._handleTagComplete, this);
        this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
        this._tag.onerror = createjs.proxy(this._handleError, this);

        var evt = new createjs.Event("initialize");
        evt.loader = this._tag;

        this.dispatchEvent(evt);

        this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

        this._tag[this._tagSrcAttribute] = this._item.src;

        // wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.
        if (this._tag.parentNode == null) {
            createjs.DomUtils.appendToBody(this._tag);
            this._addedToDOM = true;
        }
    };

    p.destroy = function() {
        this._clean();
        this._tag = null;

        this.AbstractRequest_destroy();
    };

    // private methods
    /**
     * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT
     * and LINK tags), but other cases may exist.
     * @method _handleReadyStateChange
     * @private
     */
    p._handleReadyStateChange = function () {
        clearTimeout(this._loadTimeout);
        // This is strictly for tags in browsers that do not support onload.
        var tag = this._tag;

        // Complete is for old IE support.
        if (tag.readyState == "loaded" || tag.readyState == "complete") {
            this._handleTagComplete();
        }
    };

    /**
     * Handle any error events from the tag.
     * @method _handleError
     * @protected
     */
    p._handleError = function() {
        this._clean();
        this.dispatchEvent("error");
    };

    /**
     * Handle the tag's onload callback.
     * @method _handleTagComplete
     * @private
     */
    p._handleTagComplete = function () {
        this._rawResult = this._tag;
        this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;

        this._clean();

        this.dispatchEvent("complete");
    };

    /**
     * The tag request has not loaded within the time specified in loadTimeout.
     * @method _handleError
     * @param {Object} event The XHR error event.
     * @private
     */
    p._handleTimeout = function () {
        this._clean();
        this.dispatchEvent(new createjs.Event("timeout"));
    };

    /**
     * Remove event listeners, but don't destroy the request object
     * @method _clean
     * @private
     */
    p._clean = function() {
        this._tag.onload = null;
        this._tag.onreadystatechange = null;
        this._tag.onerror = null;
        if (this._addedToDOM && this._tag.parentNode != null) {
            this._tag.parentNode.removeChild(this._tag);
        }
        clearTimeout(this._loadTimeout);
    };

    /**
     * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio
     * that is already in a load, but not complete.
     * @method _handleStalled
     * @private
     */
    p._handleStalled = function () {
        //Ignore, let the timeout take care of it. Sometimes its not really stopped.
    };

    createjs.TagRequest = createjs.promote(TagRequest, "AbstractRequest");

}());

//##############################################################################
// MediaTagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * An {{#crossLink "TagRequest"}}{{/crossLink}} that loads HTML tags for video and audio.
     * @class MediaTagRequest
     * @param {LoadItem} loadItem
     * @param {HTMLAudioElement|HTMLVideoElement} tag
     * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
     * @constructor
     */
    function MediaTagRequest(loadItem, tag, srcAttribute) {
        this.AbstractRequest_constructor(loadItem);

        // protected properties
        this._tag = tag;
        this._tagSrcAttribute = srcAttribute;
        this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
    };

    var p = createjs.extend(MediaTagRequest, createjs.TagRequest);
    var s = MediaTagRequest;

    // public methods
    p.load = function () {
        var sc = createjs.proxy(this._handleStalled, this);
        this._stalledCallback = sc;

        var pc = createjs.proxy(this._handleProgress, this);
        this._handleProgress = pc;

        this._tag.addEventListener("stalled", sc);
        this._tag.addEventListener("progress", pc);

        // This will tell us when audio is buffered enough to play through, but not when its loaded.
        // The tag doesn't keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.
        this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, false); // canplaythrough callback doesn't work in Chrome, so we use an event.

        this.TagRequest_load();
    };

    // private methods
    p._handleReadyStateChange = function () {
        clearTimeout(this._loadTimeout);
        // This is strictly for tags in browsers that do not support onload.
        var tag = this._tag;

        // Complete is for old IE support.
        if (tag.readyState == "loaded" || tag.readyState == "complete") {
            this._handleTagComplete();
        }
    };

    p._handleStalled = function () {
        //Ignore, let the timeout take care of it. Sometimes its not really stopped.
    };

    /**
     * An XHR request has reported progress.
     * @method _handleProgress
     * @param {Object} event The XHR progress event.
     * @private
     */
    p._handleProgress = function (event) {
        if (!event || event.loaded > 0 && event.total == 0) {
            return; // Sometimes we get no "total", so just ignore the progress event.
        }

        var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
        this.dispatchEvent(newEvent);
    };

    // protected methods
    p._clean = function () {
        this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
        this._tag.removeEventListener("stalled", this._stalledCallback);
        this._tag.removeEventListener("progress", this._progressCallback);

        this.TagRequest__clean();
    };

    createjs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest");

}());

//##############################################################################
// XHRRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

// constructor
    /**
     * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used
     * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.
     * XHR requests load the content as text or binary data, provide progress and consistent completion events, and
     * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for
     * cross-domain loading.
     * @class XHRRequest
     * @constructor
     * @param {Object} item The object that defines the file to load. Please see the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
     * for an overview of supported file properties.
     * @extends AbstractLoader
     */
    function XHRRequest (item) {
        this.AbstractRequest_constructor(item);

        // protected properties
        /**
         * A reference to the XHR request used to load the content.
         * @property _request
         * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}
         * @private
         */
        this._request = null;

        /**
         * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,
         * typically IE9).
         * @property _loadTimeout
         * @type {Number}
         * @private
         */
        this._loadTimeout = null;

        /**
         * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect
         * the version, so we use capabilities to make a best guess.
         * @property _xhrLevel
         * @type {Number}
         * @default 1
         * @private
         */
        this._xhrLevel = 1;

        /**
         * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be
         * null until the file is loaded.
         * @property _response
         * @type {mixed}
         * @private
         */
        this._response = null;

        /**
         * The response of the loaded file before it is modified. In most cases, content is converted from raw text to
         * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still
         * want to access the raw content as it was loaded.
         * @property _rawResponse
         * @type {String|Object}
         * @private
         */
        this._rawResponse = null;

        this._canceled = false;

        // Setup our event handlers now.
        this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);
        this._handleProgressProxy = createjs.proxy(this._handleProgress, this);
        this._handleAbortProxy = createjs.proxy(this._handleAbort, this);
        this._handleErrorProxy = createjs.proxy(this._handleError, this);
        this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);
        this._handleLoadProxy = createjs.proxy(this._handleLoad, this);
        this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);

        if (!this._createXHR(item)) {
            //TODO: Throw error?
        }
    };

    var p = createjs.extend(XHRRequest, createjs.AbstractRequest);

// static properties
    /**
     * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.
     * @property ACTIVEX_VERSIONS
     * @type {Array}
     * @since 0.4.2
     * @private
     */
    XHRRequest.ACTIVEX_VERSIONS = [
        "Msxml2.XMLHTTP.6.0",
        "Msxml2.XMLHTTP.5.0",
        "Msxml2.XMLHTTP.4.0",
        "MSXML2.XMLHTTP.3.0",
        "MSXML2.XMLHTTP",
        "Microsoft.XMLHTTP"
    ];

// Public methods
    /**
     * Look up the loaded result.
     * @method getResult
     * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content
     * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
     * returned instead.
     * @return {Object} A result object containing the content that was loaded, such as:
     * <ul>
     *      <li>An image tag (&lt;image /&gt;) for images</li>
     *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the
     *      HTML head.</li>
     *      <li>A style tag for CSS (&lt;style /&gt;)</li>
     *      <li>Raw text for TEXT</li>
     *      <li>A formatted JavaScript object defined by JSON</li>
     *      <li>An XML document</li>
     *      <li>An binary arraybuffer loaded by XHR</li>
     * </ul>
     * Note that if a raw result is requested, but not found, the result will be returned instead.
     */
    p.getResult = function (raw) {
        if (raw && this._rawResponse) {
            return this._rawResponse;
        }
        return this._response;
    };

    // Overrides abstract method in AbstractRequest
    p.cancel = function () {
        this.canceled = true;
        this._clean();
        this._request.abort();
    };

    // Overrides abstract method in AbstractLoader
    p.load = function () {
        if (this._request == null) {
            this._handleError();
            return;
        }

        //Events
        if (this._request.addEventListener != null) {
            this._request.addEventListener("loadstart", this._handleLoadStartProxy, false);
            this._request.addEventListener("progress", this._handleProgressProxy, false);
            this._request.addEventListener("abort", this._handleAbortProxy, false);
            this._request.addEventListener("error", this._handleErrorProxy, false);
            this._request.addEventListener("timeout", this._handleTimeoutProxy, false);

            // Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
            this._request.addEventListener("load", this._handleLoadProxy, false);
            this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, false);
        } else {
            // IE9 support
            this._request.onloadstart = this._handleLoadStartProxy;
            this._request.onprogress = this._handleProgressProxy;
            this._request.onabort = this._handleAbortProxy;
            this._request.onerror = this._handleErrorProxy;
            this._request.ontimeout = this._handleTimeoutProxy;

            // Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
            this._request.onload = this._handleLoadProxy;
            this._request.onreadystatechange = this._handleReadyStateChangeProxy;
        }

        // Set up a timeout if we don't have XHR2
        if (this._xhrLevel == 1) {
            this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);
        }

        // Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome
        try {
            if (!this._item.values) {
                this._request.send();
            } else {
                this._request.send(createjs.URLUtils.formatQueryString(this._item.values));
            }
        } catch (error) {
            this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, error));
        }
    };

    p.setResponseType = function (type) {
        // Some old browsers doesn't support blob, so we convert arraybuffer to blob after response is downloaded
        if (type === 'blob') {
            type = window.URL ? 'blob' : 'arraybuffer';
            this._responseType = type;
        }
        this._request.responseType = type;
    };

    /**
     * Get all the response headers from the XmlHttpRequest.
     *
     * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match
     * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,
     * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE
     * pair.
     * @method getAllResponseHeaders
     * @return {String}
     * @since 0.4.1
     */
    p.getAllResponseHeaders = function () {
        if (this._request.getAllResponseHeaders instanceof Function) {
            return this._request.getAllResponseHeaders();
        } else {
            return null;
        }
    };

    /**
     * Get a specific response header from the XmlHttpRequest.
     *
     * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches
     * header, unless the field name is Set-Cookie or Set-Cookie2.
     * @method getResponseHeader
     * @param {String} header The header name to retrieve.
     * @return {String}
     * @since 0.4.1
     */
    p.getResponseHeader = function (header) {
        if (this._request.getResponseHeader instanceof Function) {
            return this._request.getResponseHeader(header);
        } else {
            return null;
        }
    };

// protected methods
    /**
     * The XHR request has reported progress.
     * @method _handleProgress
     * @param {Object} event The XHR progress event.
     * @private
     */
    p._handleProgress = function (event) {
        if (!event || event.loaded > 0 && event.total == 0) {
            return; // Sometimes we get no "total", so just ignore the progress event.
        }

        var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
        this.dispatchEvent(newEvent);
    };

    /**
     * The XHR request has reported a load start.
     * @method _handleLoadStart
     * @param {Object} event The XHR loadStart event.
     * @private
     */
    p._handleLoadStart = function (event) {
        clearTimeout(this._loadTimeout);
        this.dispatchEvent("loadstart");
    };

    /**
     * The XHR request has reported an abort event.
     * @method handleAbort
     * @param {Object} event The XHR abort event.
     * @private
     */
    p._handleAbort = function (event) {
        this._clean();
        this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, event));
    };

    /**
     * The XHR request has reported an error event.
     * @method _handleError
     * @param {Object} event The XHR error event.
     * @private
     */
    p._handleError = function (event) {
        this._clean();
        this.dispatchEvent(new createjs.ErrorEvent(event.message));
    };

    /**
     * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload
     * event, so we must monitor the readyStateChange to determine if the file is loaded.
     * @method _handleReadyStateChange
     * @param {Object} event The XHR readyStateChange event.
     * @private
     */
    p._handleReadyStateChange = function (event) {
        if (this._request.readyState == 4) {
            this._handleLoad();
        }
    };

    /**
     * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has
     * <code>request.readyState == 4</code>. Only the first call to this method will be processed.
     *
     * Note that This method uses {{#crossLink "_checkError"}}{{/crossLink}} to determine if the server has returned an
     * error code.
     * @method _handleLoad
     * @param {Object} event The XHR load event.
     * @private
     */
    p._handleLoad = function (event) {
        if (this.loaded) {
            return;
        }
        this.loaded = true;

        var error = this._checkError();
        if (error) {
            this._handleError(error);
            return;
        }

        this._response = this._getResponse();
        // Convert arraybuffer back to blob
        if (this._responseType === 'arraybuffer') {
            try {
                this._response = new Blob([this._response]);
            } catch (e) {
                // Fallback to use BlobBuilder if Blob constructor is not supported
                // Tested on Android 2.3 ~ 4.2 and iOS5 safari
                window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                if (e.name === 'TypeError' && window.BlobBuilder) {
                    var builder = new BlobBuilder();
                    builder.append(this._response);
                    this._response = builder.getBlob();
                }
            }
        }
        this._clean();

        this.dispatchEvent(new createjs.Event("complete"));
    };

    /**
     * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>
     * callback.
     * @method _handleTimeout
     * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.
     * @private
     */
    p._handleTimeout = function (event) {
        this._clean();
        this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, event));
    };

// Protected
    /**
     * Determine if there is an error in the current load.
     * Currently this checks the status of the request for problem codes, and not actual response content:
     * <ul>
     *     <li>Status codes between 400 and 599 (HTTP error range)</li>
     *     <li>A status of 0, but *only when the application is running on a server*. If the application is running
     *     on `file:`, then it may incorrectly treat an error on local (or embedded applications) as a successful
     *     load.</li>
     * </ul>
     * @method _checkError
     * @return {Error} An error with the status code in the `message` argument.
     * @private
     */
    p._checkError = function () {
        var status = parseInt(this._request.status);
        if (status >= 400 && status <= 599) {
            return new Error(status);
        } else if (status == 0) {
            if ((/^https?:/).test(location.protocol)) { return new Error(0); }
            return null; // Likely an embedded app.
        } else {
            return null;
        }
    };


    /**
     * Validate the response. Different browsers have different approaches, some of which throw errors when accessed
     * in other browsers. If there is no response, the <code>_response</code> property will remain null.
     * @method _getResponse
     * @private
     */
    p._getResponse = function () {
        if (this._response != null) {
            return this._response;
        }

        if (this._request.response != null) {
            return this._request.response;
        }

        // Android 2.2 uses .responseText
        try {
            if (this._request.responseText != null) {
                return this._request.responseText;
            }
        } catch (e) {
        }

        // When loading XML, IE9 does not return .response, instead it returns responseXML.xml
        try {
            if (this._request.responseXML != null) {
                return this._request.responseXML;
            }
        } catch (e) {
        }

        return null;
    };

    /**
     * Create an XHR request. Depending on a number of factors, we get totally different results.
     * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>
     *      <li>XMLHttpRequest are created when available.</li>
     *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>
     *      <li>Text requests override the mime type if possible</li>
     *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>
     *      <li>Binary loads set the response type to "arraybuffer"</li></ol>
     * @method _createXHR
     * @param {Object} item The requested item that is being loaded.
     * @return {Boolean} If an XHR request or equivalent was successfully created.
     * @private
     */
    p._createXHR = function (item) {
        // Check for cross-domain loads. We can't fully support them, but we can try.
        var crossdomain = createjs.URLUtils.isCrossDomain(item);
        var headers = {};

        // Create the request. Fallback to whatever support we have.
        var req = null;
        if (window.XMLHttpRequest) {
            req = new XMLHttpRequest();
            // This is 8 or 9, so use XDomainRequest instead.
            if (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {
                req = new XDomainRequest();
            }
        } else { // Old IE versions use a different approach
            for (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {
                var axVersion = s.ACTIVEX_VERSIONS[i];
                try {
                    req = new ActiveXObject(axVersion);
                    break;
                } catch (e) {
                }
            }
            if (req == null) {
                return false;
            }
        }

        // Default to utf-8 for Text requests.
        if (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {
            item.mimeType = "text/plain; charset=utf-8";
        }

        // IE9 doesn't support overrideMimeType(), so we need to check for it.
        if (item.mimeType && req.overrideMimeType) {
            req.overrideMimeType(item.mimeType);
        }

        // Determine the XHR level
        this._xhrLevel = (typeof req.responseType === "string") ? 2 : 1;

        var src = null;
        if (item.method == createjs.Methods.GET) {
            src = createjs.URLUtils.buildURI(item.src, item.values);
        } else {
            src = item.src;
        }

        // Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)
        req.open(item.method || createjs.Methods.GET, src, true);

        if (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {
            headers["Origin"] = location.origin;
        }

        // To send data we need to set the Content-type header)
        if (item.values && item.method == createjs.Methods.POST) {
            headers["Content-Type"] = "application/x-www-form-urlencoded";
        }

        if (!crossdomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
        }

        if (item.headers) {
            for (var n in item.headers) {
                headers[n] = item.headers[n];
            }
        }

        for (n in headers) {
            req.setRequestHeader(n, headers[n])
        }

        if (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {
            req.withCredentials = item.withCredentials;
        }

        this._request = req;

        return true;
    };

    /**
     * A request has completed (or failed or canceled), and needs to be disposed.
     * @method _clean
     * @private
     */
    p._clean = function () {
        clearTimeout(this._loadTimeout);

        if (this._request.removeEventListener != null) {
            this._request.removeEventListener("loadstart", this._handleLoadStartProxy);
            this._request.removeEventListener("progress", this._handleProgressProxy);
            this._request.removeEventListener("abort", this._handleAbortProxy);
            this._request.removeEventListener("error", this._handleErrorProxy);
            this._request.removeEventListener("timeout", this._handleTimeoutProxy);
            this._request.removeEventListener("load", this._handleLoadProxy);
            this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);
        } else {
            this._request.onloadstart = null;
            this._request.onprogress = null;
            this._request.onabort = null;
            this._request.onerror = null;
            this._request.ontimeout = null;
            this._request.onload = null;
            this._request.onreadystatechange = null;
        }
    };

    p.toString = function () {
        return "[PreloadJS XHRRequest]";
    };

    createjs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest");

}());

//##############################################################################
// LoadQueue.js
//##############################################################################

this.createjs = this.createjs || {};

/*
 TODO: WINDOWS ISSUES
 * No error for HTML audio in IE 678
 * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR
 * No script complete handler in IE 67 TAGS (XHR is fine)
 * No XML/JSON in IE6 TAGS
 * Need to hide loading SVG in Opera TAGS
 * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)
 * SVG no load or failure in Opera XHR
 * Reported issues with IE7/8
 */

(function () {
    "use strict";

// constructor
    /**
     * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either
     * a single file, or queue of files.
     *
     * <b>Creating a Queue</b><br />
     * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR
     * argument to false.
     *
     *      var queue = new createjs.LoadQueue(true);
     *
     * <b>Listening for Events</b><br />
     * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink "EventDispatcher"}}{{/crossLink}}
     * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>
     *     <li>{{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}: fired when a queue completes loading all
     *     files</li>
     *     <li>{{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}: fired when the queue encounters an error with
     *     any file.</li>
     *     <li>{{#crossLink "AbstractLoader/progress:event"}}{{/crossLink}}: Progress for the entire queue has
     *     changed.</li>
     *     <li>{{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}: A single file has completed loading.</li>
     *     <li>{{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}: Progress for a single file has changes. Note
     *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>
     * </ul>
     *
     *      queue.on("fileload", handleFileLoad, this);
     *      queue.on("complete", handleComplete, this);
     *
     * <b>Adding files and manifests</b><br />
     * Add files you want to load using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or add multiple files at a
     * time using a list or a manifest definition using {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. Files are
     * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you
     * like.
     *
     *      queue.loadFile("filePath/file.jpg");
     *      queue.loadFile({id:"image", src:"filePath/file.jpg"});
     *      queue.loadManifest(["filePath/file.jpg", {id:"image", src:"filePath/file.jpg"}]);
     *
     *      // Use an external manifest
     *      queue.loadManifest("path/to/manifest.json");
     *      queue.loadManifest({src:"manifest.json", type:"manifest"});
     *
     * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not
     * stop if it has already been started. Call the {{#crossLink "AbstractLoader/load"}}{{/crossLink}} method to begin
     * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a
     * `loadNow` argument of `true`.
     *
     *      queue.load();
     *
     * <b>File Types</b><br />
     * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS
     * should handle the majority of standard file and url formats, and works with common file extensions. If you have
     * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a
     * <code>type</code> property with any manifest item.
     *
     *      queue.loadFile({src:"path/to/myFile.mp3x", type:createjs.Types.SOUND});
     *
     *      // Note that PreloadJS will not read a file extension from the query string
     *      queue.loadFile({src:"http://server.com/proxy?file=image.jpg", type:createjs.Types.IMAGE});
     *
     * Supported types are defined on the {{#crossLink "AbstractLoader"}}{{/crossLink}} class, and include:
     * <ul>
     *     <li>{{#crossLink "Types/BINARY:property"}}{{/crossLink}}: Raw binary data via XHR</li>
     *     <li>{{#crossLink "Types/CSS:property"}}{{/crossLink}}: CSS files</li>
     *     <li>{{#crossLink "Types/IMAGE:property"}}{{/crossLink}}: Common image formats</li>
     *     <li>{{#crossLink "Types/JAVASCRIPT:property"}}{{/crossLink}}: JavaScript files</li>
     *     <li>{{#crossLink "Types/JSON:property"}}{{/crossLink}}: JSON data</li>
     *     <li>{{#crossLink "Types/JSONP:property"}}{{/crossLink}}: JSON files cross-domain</li>
     *     <li>{{#crossLink "Types/MANIFEST:property"}}{{/crossLink}}: A list of files to load in JSON format, see
     *     {{#crossLink "AbstractLoader/loadManifest"}}{{/crossLink}}</li>
     *     <li>{{#crossLink "Types/SOUND:property"}}{{/crossLink}}: Audio file formats</li>
     *     <li>{{#crossLink "Types/SPRITESHEET:property"}}{{/crossLink}}: JSON SpriteSheet definitions. This
     *     will also load sub-images, and provide a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance.</li>
     *     <li>{{#crossLink "Types/SVG:property"}}{{/crossLink}}: SVG files</li>
     *     <li>{{#crossLink "Types/TEXT:property"}}{{/crossLink}}: Text files - XHR only</li>
     *     <li>{{#crossLink "Types/VIDEO:property"}}{{/crossLink}}: Video objects</li>
     *     <li>{{#crossLink "Types/XML:property"}}{{/crossLink}}: XML data</li>
     * </ul>
     *
     * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to the Types class</em>
     *
     * <b>Handling Results</b><br />
     * When a file is finished downloading, a {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event is
     * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a
     * formatted object that can be used immediately, including:
     * <ul>
     *     <li>Binary: The binary loaded result</li>
     *     <li>CSS: A &lt;link /&gt; tag</li>
     *     <li>Image: An &lt;img /&gt; tag</li>
     *     <li>JavaScript: A &lt;script /&gt; tag</li>
     *     <li>JSON/JSONP: A formatted JavaScript Object</li>
     *     <li>Manifest: A JavaScript object.
     *     <li>Sound: An &lt;audio /&gt; tag</a>
     *     <li>SpriteSheet: A {{#crossLink "SpriteSheet"}}{{/crossLink}} instance, containing loaded images.
     *     <li>SVG: An &lt;object /&gt; tag</li>
     *     <li>Text: Raw text</li>
     *     <li>Video: A Video DOM node</li>
     *     <li>XML: An XML DOM node</li>
     * </ul>
     *
     *      function handleFileLoad(event) {
     *          var item = event.item; // A reference to the item that was passed in to the LoadQueue
     *          var type = item.type;
     *
     *          // Add any images to the page body.
     *          if (type == createjs.Types.IMAGE) {
     *              document.body.appendChild(event.result);
     *          }
     *      }
     *
     * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up
     * via its "id" using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}. If no id was provided, then the
     * "src" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>
     * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.
     *
     *      var image = queue.getResult("image");
     *      document.body.appendChild(image);
     *
     * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
     * event, or can be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}, passing `true` as the 2nd
     * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,
     * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.
     *
     *      var image = queue.getResult("image", true); // load the binary image data loaded with XHR.
     *
     * <b>Plugins</b><br />
     * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,
     * make sure to install the <a href="http://soundjs.com">SoundJS</a> Sound class, which will help load HTML audio,
     * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.
     *
     *      queue.installPlugin(createjs.Sound);
     *
     * <h4>Known Browser Issues</h4>
     * <ul>
     *     <li>Browsers without audio support can not load audio files.</li>
     *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>
     *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other
     *     than Chrome will continue to download in the background.</li>
     *     <li>When loading scripts using tags, they are automatically added to the document.</li>
     *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>
     *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require
     *     XHR to work.</li>
     *     <li>Content loaded via tags will not show progress, and will continue to download in the background when
     *     canceled, although no events will be dispatched.</li>
     * </ul>
     *
     * @class LoadQueue
     * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP
     * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR
     * when necessary.
     * @param {String} [basePath=""] A path that will be prepended on to the source parameter of all items in the queue
     * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`
     * will not receive a base path.
     * @param {String|Boolean} [crossOrigin=""] An optional flag to support images loaded from a CORS-enabled server. To
     * use it, set this value to `true`, which will default the crossOrigin property on images to "Anonymous". Any
     * string value will be passed through, but only "" and "Anonymous" are recommended. <strong>Note: The crossOrigin
     * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>
     *
     * @constructor
     * @extends AbstractLoader
     */
    function LoadQueue (preferXHR, basePath, crossOrigin) {
        this.AbstractLoader_constructor();

        /**
         * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}.
         * @property _plugins
         * @type {Array}
         * @private
         * @since 0.6.1
         */
        this._plugins = [];

        /**
         * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the
         * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
         * method for more information.
         * @property _typeCallbacks
         * @type {Object}
         * @private
         */
        this._typeCallbacks = {};

        /**
         * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the
         * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
         * method for more information.
         * @property _extensionCallbacks
         * @type {null}
         * @private
         */
        this._extensionCallbacks = {};

        /**
         * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and
         * {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}} is `true`, the next queue will not be processed.
         * @property next
         * @type {LoadQueue}
         * @default null
         */
        this.next = null;

        /**
         * Ensure loaded scripts "complete" in the order they are specified. Loaded scripts are added to the document head
         * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas
         * scripts loaded using XHR can load in any order, but will "finish" and be added to the document in the order
         * specified.
         *
         * Any items can be set to load in order by setting the {{#crossLink "maintainOrder:property"}}{{/crossLink}}
         * property on the load item, or by ensuring that only one connection can be open at a time using
         * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Note that when the `maintainScriptOrder` property
         * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the
         * `maintainScriptOrder` to `false` during a load will not change items already in a queue.
         *
         * <h4>Example</h4>
         *
         *      var queue = new createjs.LoadQueue();
         *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once
         *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order
         *      queue.loadManifest([
         *          "script1.js",
         *          "script2.js",
         *          "image.png", // Load any time
         *          {src: "image2.png", maintainOrder: true} // Will wait for script2.js
         *          "image3.png",
         *          "script3.js" // Will wait for image2.png before loading (or completing when loading with XHR)
         *      ]);
         *
         * @property maintainScriptOrder
         * @type {Boolean}
         * @default true
         */
        this.maintainScriptOrder = true;

        /**
         * Determines if the LoadQueue will stop processing the current queue when an error is encountered.
         * @property stopOnError
         * @type {Boolean}
         * @default false
         */
        this.stopOnError = false;

        /**
         * The number of maximum open connections that a loadQueue tries to maintain. Please see
         * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} for more information.
         * @property _maxConnections
         * @type {Number}
         * @default 1
         * @private
         */
        this._maxConnections = 1;

        /**
         * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the
         * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can
         * handle the content, it will be selected. The default loader, ({{#crossLink "TextLoader"}}{{/crossLink}} is
         * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the
         * {{#crossLink "LoadItem/type"}}{{/crossLink}}, which is automatically determined using the file extension of
         * the {{#crossLink "LoadItem/src:property"}}{{/crossLink}}.
         *
         * Loaders can be removed from PreloadJS by simply not including them.
         *
         * Custom loaders installed using {{#crossLink "registerLoader"}}{{/crossLink}} will be prepended to this list
         * so that they are checked first.
         * @property _availableLoaders
         * @type {Array}
         * @private
         * @since 0.6.0
         */
        this._availableLoaders = [
            createjs.FontLoader,
            createjs.ImageLoader,
            createjs.JavaScriptLoader,
            createjs.CSSLoader,
            createjs.JSONLoader,
            createjs.JSONPLoader,
            createjs.SoundLoader,
            createjs.ManifestLoader,
            createjs.SpriteSheetLoader,
            createjs.XMLLoader,
            createjs.SVGLoader,
            createjs.BinaryLoader,
            createjs.VideoLoader,
            createjs.TextLoader
        ];

        /**
         * The number of built in loaders, so they can't be removed by {{#crossLink "unregisterLoader"}}{{/crossLink}.
                 * @property _defaultLoaderLength
         * @type {Number}
         * @private
         * @since 0.6.0
         */
        this._defaultLoaderLength = this._availableLoaders.length;

        this.init(preferXHR, basePath, crossOrigin);
    }

    var p = createjs.extend(LoadQueue, createjs.AbstractLoader);
    var s = LoadQueue;

    /**
     * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.
     * @method init
     * @param preferXHR
     * @param basePath
     * @param crossOrigin
     * @private
     */
    p.init = function (preferXHR, basePath, crossOrigin) {

        // public properties

        /**
         * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR
         * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,
         * and plain text can not be loaded with tags, so it will default the the correct type instead of using the
         * user-defined type.
         * @type {Boolean}
         * @default true
         * @since 0.6.0
         */
        this.preferXHR = true; //TODO: Get/Set
        this._preferXHR = true;
        this.setPreferXHR(preferXHR);

        // protected properties
        /**
         * Whether the queue is currently paused or not.
         * @property _paused
         * @type {boolean}
         * @private
         */
        this._paused = false;

        /**
         * A path that will be prepended on to the item's {{#crossLink "LoadItem/src:property"}}{{/crossLink}}. The
         * `_basePath` property will only be used if an item's source is relative, and does not include a protocol such
         * as `http://`, or a relative path such as `../`.
         * @property _basePath
         * @type {String}
         * @private
         * @since 0.3.1
         */
        this._basePath = basePath;

        /**
         * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded
         * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by
         * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,
         * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are ""
         * and "Anonymous".
         * @property _crossOrigin
         * @type {String}
         * @default ""
         * @private
         * @since 0.4.1
         */
        this._crossOrigin = crossOrigin;

        /**
         * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first
         * file is requested.
         * @property _loadStartWasDispatched
         * @type {Boolean}
         * @default false
         * @private
         */
        this._loadStartWasDispatched = false;

        /**
         * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when
         * using a script tag to do preloading.
         * @property _currentlyLoadingScript
         * @type {Boolean}
         * @private
         */
        this._currentlyLoadingScript = null;

        /**
         * An array containing the currently downloading files.
         * @property _currentLoads
         * @type {Array}
         * @private
         */
        this._currentLoads = [];

        /**
         * An array containing the queued items that have not yet started downloading.
         * @property _loadQueue
         * @type {Array}
         * @private
         */
        this._loadQueue = [];

        /**
         * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.
         * @property _loadQueueBackup
         * @type {Array}
         * @private
         */
        this._loadQueueBackup = [];

        /**
         * An object hash of items that have finished downloading, indexed by the {{#crossLink "LoadItem"}}{{/crossLink}}
         * id.
         * @property _loadItemsById
         * @type {Object}
         * @private
         */
        this._loadItemsById = {};

        /**
         * An object hash of items that have finished downloading, indexed by {{#crossLink "LoadItem"}}{{/crossLink}}
         * source.
         * @property _loadItemsBySrc
         * @type {Object}
         * @private
         */
        this._loadItemsBySrc = {};

        /**
         * An object hash of loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.
         * @property _loadedResults
         * @type {Object}
         * @private
         */
        this._loadedResults = {};

        /**
         * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.
         * @property _loadedRawResults
         * @type {Object}
         * @private
         */
        this._loadedRawResults = {};

        /**
         * The number of items that have been requested. This helps manage an overall progress without knowing how large
         * the files are before they are downloaded. This does not include items inside of loaders such as the
         * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
         * @property _numItems
         * @type {Number}
         * @default 0
         * @private
         */
        this._numItems = 0;

        /**
         * The number of items that have completed loaded. This helps manage an overall progress without knowing how large
         * the files are before they are downloaded.
         * @property _numItemsLoaded
         * @type {Number}
         * @default 0
         * @private
         */
        this._numItemsLoaded = 0;

        /**
         * A list of scripts in the order they were requested. This helps ensure that scripts are "completed" in the right
         * order.
         * @property _scriptOrder
         * @type {Array}
         * @private
         */
        this._scriptOrder = [];

        /**
         * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are
         * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>
         * once they are complete and have been dispatched.
         * @property _loadedScripts
         * @type {Array}
         * @private
         */
        this._loadedScripts = [];

        /**
         * The last progress amount. This is used to suppress duplicate progress events.
         * @property _lastProgress
         * @type {Number}
         * @private
         * @since 0.6.0
         */
        this._lastProgress = NaN;

    };

// static properties

// events
    /**
     * This event is fired when an individual file has loaded, and been processed.
     * @event fileload
     * @param {Object} target The object that dispatched the event.
     * @param {String} type The event type.
     * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
     * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
     * object will contain that value as a `src` property.
     * @param {Object} result The HTML tag or parsed result of the loaded item.
     * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
     * to a usable object.
     * @since 0.3.0
     */

    /**
     * This {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when an an individual file's progress changes.
     * @event fileprogress
     * @since 0.3.0
     */

    /**
     * This event is fired when an individual file starts to load.
     * @event filestart
     * @param {Object} target The object that dispatched the event.
     * @param {String} type The event type.
     * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
     * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
     * object will contain that value as a property.
     */

    /**
     * Although it extends {{#crossLink "AbstractLoader"}}{{/crossLink}}, the `initialize` event is never fired from
     * a LoadQueue instance.
     * @event initialize
     * @private
     */

// public methods
    /**
     * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.
     * It is recommended that loaders extend {{#crossLink "AbstractLoader"}}{{/crossLink}}. Loaders can only be added
     * once, and will be prepended to the list of available loaders.
     * @method registerLoader
     * @param {Function|AbstractLoader} loader The AbstractLoader class to add.
     * @since 0.6.0
     */
    p.registerLoader = function (loader) {
        if (!loader || !loader.canLoadItem) {
            throw new Error("loader is of an incorrect type.");
        } else if (this._availableLoaders.indexOf(loader) != -1) {
            throw new Error("loader already exists."); //LM: Maybe just silently fail here
        }

        this._availableLoaders.unshift(loader);
    };

    /**
     * Remove a custom loader added using {{#crossLink "registerLoader"}}{{/crossLink}}. Only custom loaders can be
     * unregistered, the default loaders will always be available.
     * @method unregisterLoader
     * @param {Function|AbstractLoader} loader The AbstractLoader class to remove
     */
    p.unregisterLoader = function (loader) {
        var idx = this._availableLoaders.indexOf(loader);
        if (idx != -1 && idx < this._defaultLoaderLength - 1) {
            this._availableLoaders.splice(idx, 1);
        }
    };

    /**
     * Change the {{#crossLink "preferXHR:property"}}{{/crossLink}} value. Note that if this is set to `true`, it may
     * fail, or be ignored depending on the browser's capabilities and the load type.
     * @method setPreferXHR
     * @param {Boolean} value
     * @returns {Boolean} The value of {{#crossLink "preferXHR"}}{{/crossLink}} that was successfully set.
     * @since 0.6.0
     */
    p.setPreferXHR = function (value) {
        // Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.
        //TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.
        this.preferXHR = (value != false && window.XMLHttpRequest != null);
        return this.preferXHR;
    };

    /**
     * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded
     * content, and allows the queue to be used again.
     * @method removeAll
     * @since 0.3.0
     */
    p.removeAll = function () {
        this.remove();
    };

    /**
     * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.
     * This also removes internal references to loaded item(s).
     *
     * <h4>Example</h4>
     *
     *      queue.loadManifest([
     *          {src:"test.png", id:"png"},
     *          {src:"test.jpg", id:"jpg"},
     *          {src:"test.mp3", id:"mp3"}
     *      ]);
     *      queue.remove("png"); // Single item by ID
     *      queue.remove("png", "test.jpg"); // Items as arguments. Mixed id and src.
     *      queue.remove(["test.png", "jpg"]); // Items in an Array. Mixed id and src.
     *
     * @method remove
     * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of
     * items, or multiple items as arguments.
     * @since 0.3.0
     */
    p.remove = function (idsOrUrls) {
        var args = null;

        if (idsOrUrls && !Array.isArray(idsOrUrls)) {
            args = [idsOrUrls];
        } else if (idsOrUrls) {
            args = idsOrUrls;
        } else if (arguments.length > 0) {
            return;
        }

        var itemsWereRemoved = false;

        // Destroy everything
        if (!args) {
            this.close();
            for (var n in this._loadItemsById) {
                this._disposeItem(this._loadItemsById[n]);
            }
            this.init(this.preferXHR, this._basePath);

            // Remove specific items
        } else {
            while (args.length) {
                var item = args.pop();
                var r = this.getResult(item);

                //Remove from the main load Queue
                for (i = this._loadQueue.length - 1; i >= 0; i--) {
                    loadItem = this._loadQueue[i].getItem();
                    if (loadItem.id == item || loadItem.src == item) {
                        this._loadQueue.splice(i, 1)[0].cancel();
                        break;
                    }
                }

                //Remove from the backup queue
                for (i = this._loadQueueBackup.length - 1; i >= 0; i--) {
                    loadItem = this._loadQueueBackup[i].getItem();
                    if (loadItem.id == item || loadItem.src == item) {
                        this._loadQueueBackup.splice(i, 1)[0].cancel();
                        break;
                    }
                }

                if (r) {
                    this._disposeItem(this.getItem(item));
                } else {
                    for (var i = this._currentLoads.length - 1; i >= 0; i--) {
                        var loadItem = this._currentLoads[i].getItem();
                        if (loadItem.id == item || loadItem.src == item) {
                            this._currentLoads.splice(i, 1)[0].cancel();
                            itemsWereRemoved = true;
                            break;
                        }
                    }
                }
            }

            // If this was called during a load, try to load the next item.
            if (itemsWereRemoved) {
                this._loadNext();
            }
        }
    };

    /**
     * Stops all open loads, destroys any loaded items, and resets the queue, so all items can
     * be reloaded again by calling {{#crossLink "AbstractLoader/load"}}{{/crossLink}}. Items are not removed from the
     * queue. To remove items use the {{#crossLink "LoadQueue/remove"}}{{/crossLink}} or
     * {{#crossLink "LoadQueue/removeAll"}}{{/crossLink}} method.
     * @method reset
     * @since 0.3.0
     */
    p.reset = function () {
        this.close();
        for (var n in this._loadItemsById) {
            this._disposeItem(this._loadItemsById[n]);
        }

        //Reset the queue to its start state
        var a = [];
        for (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {
            a.push(this._loadQueueBackup[i].getItem());
        }

        this.loadManifest(a, false);
    };

    /**
     * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).
     * Currently, only one plugin can exist per type/extension.
     *
     * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information
     * on this method, check out the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method in the
     * {{#crossLink "SamplePlugin"}}{{/crossLink}} class.
     *
     * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned
     * from the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method, it will be invoked first, and its
     * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when
     * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these
     * methods, check out the {{#crossLink "SamplePlugin/preloadHandler"}}{{/crossLink}} and {{#crossLink "SamplePlugin/fileLoadHandler"}}{{/crossLink}}
     * methods on the {{#crossLink "SamplePlugin"}}{{/crossLink}}.
     *
     * @method installPlugin
     * @param {Function} plugin The plugin class to install.
     */
    p.installPlugin = function (plugin) {
        if (plugin == null) {
            return;
        }

        if (plugin.getPreloadHandlers != null) {
            this._plugins.push(plugin);
            var map = plugin.getPreloadHandlers();
            map.scope = plugin;

            if (map.types != null) {
                for (var i = 0, l = map.types.length; i < l; i++) {
                    this._typeCallbacks[map.types[i]] = map;
                }
            }

            if (map.extensions != null) {
                for (i = 0, l = map.extensions.length; i < l; i++) {
                    this._extensionCallbacks[map.extensions[i]] = map;
                }
            }
        }
    };

    /**
     * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum
     * number of open connections, so any additional connections may remain in a pending state until the browser
     * opens the connection. When loading scripts using tags, and when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}}
     * is `true`, only one script is loaded at a time due to browser limitations.
     *
     * <h4>Example</h4>
     *
     *      var queue = new createjs.LoadQueue();
     *      queue.setMaxConnections(10); // Allow 10 concurrent loads
     *
     * @method setMaxConnections
     * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue
     * is open at any time.
     */
    p.setMaxConnections = function (value) {
        this._maxConnections = value;
        if (!this._paused && this._loadQueue.length > 0) {
            this._loadNext();
        }
    };

    /**
     * Load a single file. To add multiple files at once, use the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
     * method.
     *
     * Files are always appended to the current queue, so this method can be used multiple times to add files.
     * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
     * @method loadFile
     * @param {LoadItem|Object|String} file The file object or path to load. A file can be either
     * <ul>
     *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
     *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
     *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
     *     in the background.</li>
     * </ul>
     * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
     * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}}, and the value is
     * `true`, the queue will resume automatically.
     * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
     * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "Types/MANIFEST:property"}}{{/crossLink}},
     * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
     * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
     * constructor, or a `path` property in a manifest definition.
     */
    p.loadFile = function (file, loadNow, basePath) {
        if (file == null) {
            var event = new createjs.ErrorEvent("PRELOAD_NO_FILE");
            this._sendError(event);
            return;
        }
        this._addItem(file, null, basePath);

        if (loadNow !== false) {
            this.setPaused(false);
        } else {
            this.setPaused(true);
        }
    };

    /**
     * Load an array of files. To load a single file, use the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} method.
     * The files in the manifest are requested in the same order, but may complete in a different order if the max
     * connections are set above 1 using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Scripts will load
     * in the right order as long as {{#crossLink "LoadQueue/maintainScriptOrder"}}{{/crossLink}} is true (which is
     * default).
     *
     * Files are always appended to the current queue, so this method can be used multiple times to add files.
     * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
     * @method loadManifest
     * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of
     * manifests:
     * <ol>
     *     <li>A string path, which points to a manifest file, which is a JSON file that contains a "manifest" property,
     *     which defines the list of files to load, and can optionally contain a "path" property, which will be
     *     prepended to each file in the list.</li>
     *     <li>An object which defines a "src", which is a JSON or JSONP file. A "callback" can be defined for JSONP
     *     file. The JSON/JSONP file should contain a "manifest" property, which defines the list of files to load,
     *     and can optionally contain a "path" property, which will be prepended to each file in the list.</li>
     *     <li>An object which contains a "manifest" property, which defines the list of files to load, and can
     *     optionally contain a "path" property, which will be prepended to each file in the list.</li>
     *     <li>An Array of files to load.</li>
     * </ol>
     *
     * Each "file" in a manifest can be either:
     * <ul>
     *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
     *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
     *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
     *     in the background.</li>
     * </ul>
     *
     * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
     * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} and this value is
     * `true`, the queue will resume automatically.
     * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
     * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "LoadQueue/MANIFEST:property"}}{{/crossLink}},
     * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
     * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
     * constructor, or a `path` property in a manifest definition.
     */
    p.loadManifest = function (manifest, loadNow, basePath) {
        var fileList = null;
        var path = null;

        // Array-based list of items
        if (Array.isArray(manifest)) {
            if (manifest.length == 0) {
                var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_EMPTY");
                this._sendError(event);
                return;
            }
            fileList = manifest;

            // String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.
        } else if (typeof(manifest) === "string") {
            fileList = [
                {
                    src: manifest,
                    type: s.MANIFEST
                }
            ];

        } else if (typeof(manifest) == "object") {

            // An object that defines a manifest path
            if (manifest.src !== undefined) {
                if (manifest.type == null) {
                    manifest.type = s.MANIFEST;
                } else if (manifest.type != s.MANIFEST) {
                    var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_TYPE");
                    this._sendError(event);
                }
                fileList = [manifest];

                // An object that defines a manifest
            } else if (manifest.manifest !== undefined) {
                fileList = manifest.manifest;
                path = manifest.path;
            }

            // Unsupported. This will throw an error.
        } else {
            var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_NULL");
            this._sendError(event);
            return;
        }

        for (var i = 0, l = fileList.length; i < l; i++) {
            this._addItem(fileList[i], path, basePath);
        }

        if (loadNow !== false) {
            this.setPaused(false);
        } else {
            this.setPaused(true);
        }

    };

    /**
     * Start a LoadQueue that was created, but not automatically started.
     * @method load
     */
    p.load = function () {
        this.setPaused(false);
    };

    /**
     * Look up a {{#crossLink "LoadItem"}}{{/crossLink}} using either the "id" or "src" that was specified when loading it. Note that if no "id" was
     * supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
     * `basePath` will not be part of the ID.
     * @method getItem
     * @param {String} value The <code>id</code> or <code>src</code> of the load item.
     * @return {Object} The load item that was initially requested using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
     * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
     * event as the `item` parameter.
     */
    p.getItem = function (value) {
        return this._loadItemsById[value] || this._loadItemsBySrc[value];
    };

    /**
     * Look up a loaded result using either the "id" or "src" that was specified when loading it. Note that if no "id"
     * was supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
     * `basePath` will not be part of the ID.
     * @method getResult
     * @param {String} value The <code>id</code> or <code>src</code> of the load item.
     * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content
     * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
     * returned instead.
     * @return {Object} A result object containing the content that was loaded, such as:
     * <ul>
     *      <li>An image tag (&lt;image /&gt;) for images</li>
     *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML
     *      DOM.</li>
     *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>
     *      <li>Raw text for TEXT</li>
     *      <li>A formatted JavaScript object defined by JSON</li>
     *      <li>An XML document</li>
     *      <li>A binary arraybuffer loaded by XHR</li>
     *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play
     *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method
     *      which can not be used to play audio back.</li>
     * </ul>
     * This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event as the 'item`
     * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.
     */
    p.getResult = function (value, rawResult) {
        var item = this._loadItemsById[value] || this._loadItemsBySrc[value];
        if (item == null) {
            return null;
        }
        var id = item.id;
        if (rawResult && this._loadedRawResults[id]) {
            return this._loadedRawResults[id];
        }
        return this._loadedResults[id];
    };

    /**
     * Generate an list of items loaded by this queue.
     * @method getItems
     * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress
     * and failed load items will also be included.
     * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink "LoadItem"}}{{/crossLink}},
     * result, and rawResult.
     * @since 0.6.0
     */
    p.getItems = function (loaded) {
        var arr = [];
        for (var n in this._loadItemsById) {
            var item = this._loadItemsById[n];
            var result = this.getResult(n);
            if (loaded === true && result == null) {
                continue;
            }
            arr.push({
                item: item,
                result: result,
                rawResult: this.getResult(n, true)
            });
        }
        return arr;
    };

    /**
     * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not
     * be processed when active loads complete. LoadQueues are not paused by default.
     *
     * Note that if new items are added to the queue using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
     * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`
     * argument is `false`.
     * @method setPaused
     * @param {Boolean} value Whether the queue should be paused or not.
     */
    p.setPaused = function (value) {
        this._paused = value;
        if (!this._paused) {
            this._loadNext();
        }
    };

    /**
     * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from
     * starting to download. Note that currently any active loads will remain open, and events may be processed.
     *
     * To stop and restart a queue, use the {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} method instead.
     * @method close
     */
    p.close = function () {
        while (this._currentLoads.length) {
            this._currentLoads.pop().cancel();
        }
        this._scriptOrder.length = 0;
        this._loadedScripts.length = 0;
        this.loadStartWasDispatched = false;
        this._itemCount = 0;
        this._lastProgress = NaN;
    };

// protected methods
    /**
     * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to
     * load the content. The load queue is populated with the loader instance that handles preloading, and not the load
     * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink "LoadQueue.getItem"}}{{/crossLink}}
     * method.
     * @method _addItem
     * @param {String|Object} value The item to add to the queue.
     * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is
     * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was
     * provided a {{#crossLink "_basePath"}}{{/crossLink}}, then it will optionally be prepended after.
     * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
     * or {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} call. This parameter will be removed in a future tagged
     * version.
     * @private
     */
    p._addItem = function (value, path, basePath) {
        var item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.
        if (item == null) {
            return;
        } // Sometimes plugins or types should be skipped.
        var loader = this._createLoader(item);
        if (loader != null) {
            if ("plugins" in loader) {
                loader.plugins = this._plugins;
            }
            item._loader = loader;
            this._loadQueue.push(loader);
            this._loadQueueBackup.push(loader);

            this._numItems++;
            this._updateProgress();

            // Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.
            if ((this.maintainScriptOrder
                    && item.type == createjs.Types.JAVASCRIPT
                        //&& loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way
                    )
                    || item.maintainOrder === true) {
                this._scriptOrder.push(item);
                this._loadedScripts.push(null);
            }
        }
    };

    /**
     * Create a refined {{#crossLink "LoadItem"}}{{/crossLink}}, which contains all the required properties. The type of
     * item is determined by browser support, requirements based on the file type, and developer settings. For example,
     * XHR is only used for file types that support it in new browsers.
     *
     * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may
     * alter the load item.
     * @method _createLoadItem
     * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.
     * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will
     * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink "LoadQueue/_basePath:property"}}{{/crossLink}}
     * when it is added.
     * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to
     * the path argument.
     * @return {Object} The loader instance that will be used.
     * @private
     */
    p._createLoadItem = function (value, path, basePath) {
        var item = createjs.LoadItem.create(value);
        if (item == null) {
            return null;
        }

        var bp = ""; // Store the generated basePath
        var useBasePath = basePath || this._basePath;

        if (item.src instanceof Object) {
            if (!item.type) {
                return null;
            } // the the src is an object, type is required to pass off to plugin
            if (path) {
                bp = path;
                var pathMatch = createjs.URLUtils.parseURI(path);
                // Also append basePath
                if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
                    bp = useBasePath + bp;
                }
            } else if (useBasePath != null) {
                bp = useBasePath;
            }
        } else {
            // Determine Extension, etc.
            var match = createjs.URLUtils.parseURI(item.src);
            if (match.extension) {
                item.ext = match.extension;
            }
            if (item.type == null) {
                item.type = createjs.RequestUtils.getTypeByExtension(item.ext);
            }

            // Inject path & basePath
            var autoId = item.src;
            if (!match.absolute && !match.relative) {
                if (path) {
                    bp = path;
                    var pathMatch = createjs.URLUtils.parseURI(path);
                    autoId = path + autoId;
                    // Also append basePath
                    if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
                        bp = useBasePath + bp;
                    }
                } else if (useBasePath != null) {
                    bp = useBasePath;
                }
            }
            item.src = bp + item.src;
        }
        item.path = bp;

        // If there's no id, set one now.
        if (item.id === undefined || item.id === null || item.id === "") {
            item.id = autoId;
        }

        // Give plugins a chance to modify the loadItem:
        var customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];
        if (customHandler) {
            // Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)
            var result = customHandler.callback.call(customHandler.scope, item, this);

            // The plugin will handle the load, or has canceled it. Ignore it.
            if (result === false) {
                return null;

                // Load as normal:
            } else if (result === true) {
                // Do Nothing

                // Result is a loader class:
            } else if (result != null) {
                item._loader = result;
            }

            // Update the extension in case the type changed:
            match = createjs.URLUtils.parseURI(item.src);
            if (match.extension != null) {
                item.ext = match.extension;
            }
        }

        // Store the item for lookup. This also helps clean-up later.
        this._loadItemsById[item.id] = item;
        this._loadItemsBySrc[item.src] = item;

        if (item.crossOrigin == null) {
            item.crossOrigin = this._crossOrigin;
        }

        return item;
    };

    /**
     * Create a loader for a load item.
     * @method _createLoader
     * @param {Object} item A formatted load item that can be used to generate a loader.
     * @return {AbstractLoader} A loader that can be used to load content.
     * @private
     */
    p._createLoader = function (item) {
        if (item._loader != null) { // A plugin already specified a loader
            return item._loader;
        }

        // Initially, try and use the provided/supported XHR mode:
        var preferXHR = this.preferXHR;

        for (var i = 0; i < this._availableLoaders.length; i++) {
            var loader = this._availableLoaders[i];
            if (loader && loader.canLoadItem(item)) {
                return new loader(item, preferXHR);
            }
        }

        // TODO: Log error (requires createjs.log)
        return null;
    };

    /**
     * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event
     * is processed. The queue will "fill up" any empty slots, up to the max connection specified using
     * {{#crossLink "LoadQueue.setMaxConnections"}}{{/crossLink}} method. The only exception is scripts that are loaded
     * using tags, which have to be loaded one at a time to maintain load order.
     * @method _loadNext
     * @private
     */
    p._loadNext = function () {
        if (this._paused) {
            return;
        }

        // Only dispatch loadstart event when the first file is loaded.
        if (!this._loadStartWasDispatched) {
            this._sendLoadStart();
            this._loadStartWasDispatched = true;
        }

        // The queue has completed.
        if (this._numItems == this._numItemsLoaded) {
            this.loaded = true;
            this._sendComplete();

            // Load the next queue, if it has been defined.
            if (this.next && this.next.load) {
                this.next.load();
            }
        } else {
            this.loaded = false;
        }

        // Must iterate forwards to load in the right order.
        for (var i = 0; i < this._loadQueue.length; i++) {
            if (this._currentLoads.length >= this._maxConnections) {
                break;
            }
            var loader = this._loadQueue[i];

            // Determine if we should be only loading one tag-script at a time:
            // Note: maintainOrder items don't do anything here because we can hold onto their loaded value
            if (!this._canStartLoad(loader)) {
                continue;
            }
            this._loadQueue.splice(i, 1);
            i--;
            this._loadItem(loader);
        }
    };

    /**
     * Begin loading an item. Event listeners are not added to the loaders until the load starts.
     * @method _loadItem
     * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.
     * @private
     */
    p._loadItem = function (loader) {
        loader.on("fileload", this._handleFileLoad, this);
        loader.on("progress", this._handleProgress, this);
        loader.on("complete", this._handleFileComplete, this);
        loader.on("error", this._handleError, this);
        loader.on("fileerror", this._handleFileError, this);
        this._currentLoads.push(loader);
        this._sendFileStart(loader.getItem());
        loader.load();
    };

    /**
     * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink "ManifestLoader"}}{{/crossLink}}
     * to maintain internal queues, but for this queue to dispatch the {{#crossLink "fileload:event"}}{{/crossLink}}
     * events.
     * @param {Event} event The {{#crossLink "AbstractLoader/fileload:event"}}{{/crossLink}} event from the loader.
     * @private
     * @since 0.6.0
     */
    p._handleFileLoad = function (event) {
        event.target = null;
        this.dispatchEvent(event);
    };

    /**
     * The callback that is fired when a loader encounters an error from an internal file load operation. This enables
     * loaders like M
     * @param event
     * @private
     */
    p._handleFileError = function (event) {
        var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, event.item);
        this._sendError(newEvent);
    };

    /**
     * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}}
     * is set to `true`.
     * @method _handleError
     * @param {ErrorEvent} event The error event, containing relevant error information.
     * @private
     */
    p._handleError = function (event) {
        var loader = event.target;
        this._numItemsLoaded++;

        this._finishOrderedItem(loader, true);
        this._updateProgress();

        var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, loader.getItem());
        // TODO: Propagate actual error message.

        this._sendError(newEvent);

        if (!this.stopOnError) {
            this._removeLoadItem(loader);
            this._cleanLoadItem(loader);
            this._loadNext();
        } else {
            this.setPaused(true);
        }
    };

    /**
     * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and
     * is available as the "result" property on the load item. The raw text result for a parsed item (such as JSON, XML,
     * CSS, JavaScript, etc) is available as the "rawResult" property, and can also be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}.
     * @method _handleFileComplete
     * @param {Event} event The event object from the loader.
     * @private
     */
    p._handleFileComplete = function (event) {
        var loader = event.target;
        var item = loader.getItem();

        var result = loader.getResult();
        this._loadedResults[item.id] = result;
        var rawResult = loader.getResult(true);
        if (rawResult != null && rawResult !== result) {
            this._loadedRawResults[item.id] = rawResult;
        }

        this._saveLoadedItems(loader);

        // Remove the load item
        this._removeLoadItem(loader);

        if (!this._finishOrderedItem(loader)) {
            // The item was NOT managed, so process it now
            this._processFinishedLoad(item, loader);
        }

        // Clean up the load item
        this._cleanLoadItem(loader);
    };

    /**
     * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink "ManifestLoader"}}{{/crossLink}}).
     * Any items exposed by the loader using {{#crossLink "AbstractLoader/getLoadItems"}}{{/crossLink}} are added to the
     * LoadQueue's look-ups, including {{#crossLink "getItem"}}{{/crossLink}} and {{#crossLink "getResult"}}{{/crossLink}}
     * methods.
     * @method _saveLoadedItems
     * @param {AbstractLoader} loader
     * @protected
     * @since 0.6.0
     */
    p._saveLoadedItems = function (loader) {
        // TODO: Not sure how to handle this. Would be nice to expose the items.
        // Loaders may load sub-items. This adds them to this queue
        var list = loader.getLoadedItems();
        if (list === null) {
            return;
        }

        for (var i = 0; i < list.length; i++) {
            var item = list[i].item;

            // Store item lookups
            this._loadItemsBySrc[item.src] = item;
            this._loadItemsById[item.id] = item;

            // Store loaded content
            this._loadedResults[item.id] = list[i].result;
            this._loadedRawResults[item.id] = list[i].rawResult;
        }
    };

    /**
     * Flag an item as finished. If the item's order is being managed, then ensure that it is allowed to finish, and if
     * so, trigger prior items to trigger as well.
     * @method _finishOrderedItem
     * @param {AbstractLoader} loader
     * @param {Boolean} loadFailed
     * @return {Boolean} If the item's order is being managed. This allows the caller to take an alternate
     * behaviour if it is.
     * @private
     */
    p._finishOrderedItem = function (loader, loadFailed) {
        var item = loader.getItem();

        if ((this.maintainScriptOrder && item.type == createjs.Types.JAVASCRIPT)
                || item.maintainOrder) {

            //TODO: Evaluate removal of the _currentlyLoadingScript
            if (loader instanceof createjs.JavaScriptLoader) {
                this._currentlyLoadingScript = false;
            }

            var index = createjs.indexOf(this._scriptOrder, item);
            if (index == -1) {
                return false;
            } // This loader no longer exists
            this._loadedScripts[index] = (loadFailed === true) ? true : item;

            this._checkScriptLoadOrder();
            return true;
        }

        return false;
    };

    /**
     * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the
     * order they were added, but with a "null" value. When they are completed, the value is set to the load item,
     * and then when they are processed and dispatched, the value is set to `true`. This method simply
     * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are
     * dispatched.
     * @method _checkScriptLoadOrder
     * @private
     */
    p._checkScriptLoadOrder = function () {
        var l = this._loadedScripts.length;

        for (var i = 0; i < l; i++) {
            var item = this._loadedScripts[i];
            if (item === null) {
                break;
            } // This is still loading. Do not process further.
            if (item === true) {
                continue;
            } // This has completed, and been processed. Move on.

            var loadItem = this._loadedResults[item.id];
            if (item.type == createjs.Types.JAVASCRIPT) {
                // Append script tags to the head automatically.
                createjs.DomUtils.appendToHead(loadItem);
            }

            var loader = item._loader;
            this._processFinishedLoad(item, loader);
            this._loadedScripts[i] = true;
        }
    };

    /**
     * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts
     * the next item.
     * @method _processFinishedLoad
     * @param {LoadItem|Object} item
     * @param {AbstractLoader} loader
     * @protected
     */
    p._processFinishedLoad = function (item, loader) {
        this._numItemsLoaded++;

        // Since LoadQueue needs maintain order, we can't append scripts in the loader.
        // So we do it here instead. Or in _checkScriptLoadOrder();
        if (!this.maintainScriptOrder && item.type == createjs.Types.JAVASCRIPT) {
            var tag = loader.getTag();
            createjs.DomUtils.appendToHead(tag);
        }

        this._updateProgress();
        this._sendFileComplete(item, loader);
        this._loadNext();
    };

    /**
     * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to
     * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>
     * the script can even be started, since it exist in the DOM while loading.
     * @method _canStartLoad
     * @param {AbstractLoader} loader The loader for the item
     * @return {Boolean} Whether the item can start a load or not.
     * @private
     */
    p._canStartLoad = function (loader) {
        if (!this.maintainScriptOrder || loader.preferXHR) {
            return true;
        }
        var item = loader.getItem();
        if (item.type != createjs.Types.JAVASCRIPT) {
            return true;
        }
        if (this._currentlyLoadingScript) {
            return false;
        }

        var index = this._scriptOrder.indexOf(item);
        var i = 0;
        while (i < index) {
            var checkItem = this._loadedScripts[i];
            if (checkItem == null) {
                return false;
            }
            i++;
        }
        this._currentlyLoadingScript = true;
        return true;
    };

    /**
     * A load item is completed or was canceled, and needs to be removed from the LoadQueue.
     * @method _removeLoadItem
     * @param {AbstractLoader} loader A loader instance to remove.
     * @private
     */
    p._removeLoadItem = function (loader) {
        var l = this._currentLoads.length;
        for (var i = 0; i < l; i++) {
            if (this._currentLoads[i] == loader) {
                this._currentLoads.splice(i, 1);
                break;
            }
        }
    };

    /**
     * Remove unneeded references from a loader.
     *
     * @param loader
     * @private
     */
    p._cleanLoadItem = function(loader) {
        var item = loader.getItem();
        if (item) {
            delete item._loader;
        }
    }

    /**
     * An item has dispatched progress. Propagate that progress, and update the LoadQueue's overall progress.
     * @method _handleProgress
     * @param {ProgressEvent} event The progress event from the item.
     * @private
     */
    p._handleProgress = function (event) {
        var loader = event.target;
        this._sendFileProgress(loader.getItem(), loader.progress);
        this._updateProgress();
    };

    /**
     * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an
     * item dispatches progress or completes. Note that since we don't always know the actual filesize of items before
     * they are loaded. In this case, we define a "slot" for each item (1 item in 10 would get 10%), and then append
     * loaded progress on top of the already-loaded items.
     *
     * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:
     * <ul>
     *      <li>5/10 of the items in the queue (50%)</li>
     *      <li>plus 20% of item 6's slot (2%)</li>
     *      <li>equals 52%</li>
     * </ul>
     * @method _updateProgress
     * @private
     */
    p._updateProgress = function () {
        var loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress
        var remaining = this._numItems - this._numItemsLoaded;
        if (remaining > 0) {
            var chunk = 0;
            for (var i = 0, l = this._currentLoads.length; i < l; i++) {
                chunk += this._currentLoads[i].progress;
            }
            loaded += (chunk / remaining) * (remaining / this._numItems);
        }

        if (this._lastProgress != loaded) {
            this._sendProgress(loaded);
            this._lastProgress = loaded;
        }
    };

    /**
     * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal
     * hashes.
     * @method _disposeItem
     * @param {LoadItem|Object} item The item that was passed in for preloading.
     * @private
     */
    p._disposeItem = function (item) {
        delete this._loadedResults[item.id];
        delete this._loadedRawResults[item.id];
        delete this._loadItemsById[item.id];
        delete this._loadItemsBySrc[item.src];
    };

    /**
     * Dispatch a "fileprogress" {{#crossLink "Event"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}
     * event for details on the event payload.
     * @method _sendFileProgress
     * @param {LoadItem|Object} item The item that is being loaded.
     * @param {Number} progress The amount the item has been loaded (between 0 and 1).
     * @protected
     */
    p._sendFileProgress = function (item, progress) {
        if (this._isCanceled() || this._paused) {
            return;
        }
        if (!this.hasEventListener("fileprogress")) {
            return;
        }

        //LM: Rework ProgressEvent to support this?
        var event = new createjs.Event("fileprogress");
        event.progress = progress;
        event.loaded = progress;
        event.total = 1;
        event.item = item;

        this.dispatchEvent(event);
    };

    /**
     * Dispatch a fileload {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event for
     * details on the event payload.
     * @method _sendFileComplete
     * @param {LoadItemObject} item The item that is being loaded.
     * @param {AbstractLoader} loader
     * @protected
     */
    p._sendFileComplete = function (item, loader) {
        if (this._isCanceled() || this._paused) {
            return;
        }

        var event = new createjs.Event("fileload");
        event.loader = loader;
        event.item = item;
        event.result = this._loadedResults[item.id];
        event.rawResult = this._loadedRawResults[item.id];

        // This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.
        if (item.completeHandler) {
            item.completeHandler(event);
        }

        this.hasEventListener("fileload") && this.dispatchEvent(event);
    };

    /**
     * Dispatch a filestart {{#crossLink "Event"}}{{/crossLink}} immediately before a file starts to load. Please see
     * the {{#crossLink "LoadQueue/filestart:event"}}{{/crossLink}} event for details on the event payload.
     * @method _sendFileStart
     * @param {LoadItem|Object} item The item that is being loaded.
     * @protected
     */
    p._sendFileStart = function (item) {
        var event = new createjs.Event("filestart");
        event.item = item;
        this.hasEventListener("filestart") && this.dispatchEvent(event);
    };

    p.toString = function () {
        return "[PreloadJS LoadQueue]";
    };

    createjs.LoadQueue = createjs.promote(LoadQueue, "AbstractLoader");
}());

//##############################################################################
// TextLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for Text files.
     * @class TextLoader
     * @param {LoadItem|Object} loadItem
     * @extends AbstractLoader
     * @constructor
     */
    function TextLoader(loadItem) {
        this.AbstractLoader_constructor(loadItem, true, createjs.Types.TEXT);
    };

    var p = createjs.extend(TextLoader, createjs.AbstractLoader);
    var s = TextLoader;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink "Types/TEXT:property"}}{{/crossLink}},
     * but is also the default loader if a file type can not be determined.
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.TEXT;
    };

    createjs.TextLoader = createjs.promote(TextLoader, "AbstractLoader");

}());

//##############################################################################
// BinaryLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.
     * @class BinaryLoader
     * @param {LoadItem|Object} loadItem
     * @extends AbstractLoader
     * @constructor
     */
    function BinaryLoader(loadItem) {
        this.AbstractLoader_constructor(loadItem, true, createjs.Types.BINARY);
        this.on("initialize", this._updateXHR, this);
    };

    var p = createjs.extend(BinaryLoader, createjs.AbstractLoader);
    var s = BinaryLoader;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/BINARY:property"}}{{/crossLink}}
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.BINARY;
    };

    // private methods
    /**
     * Before the item loads, set the response type to "arraybuffer"
     * @property _updateXHR
     * @param {Event} event
     * @private
     */
    p._updateXHR = function (event) {
        event.loader.setResponseType("arraybuffer");
    };

    createjs.BinaryLoader = createjs.promote(BinaryLoader, "AbstractLoader");

}());

//##############################################################################
// CSSLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for CSS files.
     * @class CSSLoader
     * @param {LoadItem|Object} loadItem
     * @param {Boolean} preferXHR
     * @extends AbstractLoader
     * @constructor
     */
    function CSSLoader(loadItem, preferXHR) {
        this.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.CSS);

        // public properties
        this.resultFormatter = this._formatResult;

        // protected properties
        this._tagSrcAttribute = "href";

        if (preferXHR) {
            this._tag = createjs.Elements.style();
        } else {
            this._tag = createjs.Elements.link();
        }

        this._tag.rel = "stylesheet";
        this._tag.type = "text/css";
    };

    var p = createjs.extend(CSSLoader, createjs.AbstractLoader);
    var s = CSSLoader;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/CSS:property"}}{{/crossLink}}.
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.CSS;
    };

    // protected methods
    /**
     * The result formatter for CSS files.
     * @method _formatResult
     * @param {AbstractLoader} loader
     * @returns {HTMLLinkElement|HTMLStyleElement}
     * @private
     */
    p._formatResult = function (loader) {
        if (this._preferXHR) {
            var tag = loader.getTag();

            if (tag.styleSheet) { // IE
                tag.styleSheet.cssText = loader.getResult(true);
            } else {
                var textNode = createjs.Elements.text(loader.getResult(true));
                tag.appendChild(textNode);
            }
        } else {
            tag = this._tag;
        }

        createjs.DomUtils.appendToHead(tag);

        return tag;
    };

    createjs.CSSLoader = createjs.promote(CSSLoader, "AbstractLoader");

}());

//##############################################################################
// FontLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

// constructor:
    /**
     * A loader that handles font files, CSS definitions, and CSS paths. FontLoader doesn't actually preload fonts
     * themselves, but rather generates CSS definitions, and then tests the size changes on an HTML5 Canvas element.
     *
     * Note that FontLoader does not support tag-based loading due to the requirement that CSS be read to determine the
     * font definitions to test for.
     * @class FontLoader
     * @param {LoadItem|object|string} loadItem The item to be loaded.
     * @extends AbstractLoader
     * @constructor
     **/
    function FontLoader(loadItem, preferXHR) {
        this.AbstractLoader_constructor(loadItem, preferXHR, loadItem.type);

        // private properties:
        /**
         * A lookup of font faces to load.
         * @property _faces
         * @protected
         * @type Object
         **/
        this._faces = {};

        /**
         * A list of font faces currently being "watched". Watched fonts will be tested on a regular interval, and be
         * removed from this list when they are complete.
         * @oroperty _watched
         * @type {Array}
         * @protected
         */
        this._watched = [];

        /**
         * A count of the total font faces to load.
         * @property _count
         * @type {number}
         * @protected
         * @default 0
         */
        this._count = 0;

        /**
         * The interval for checking if fonts have been loaded.
         * @property _watchInterval
         * @type {Number}
         * @protected
         */
        this._watchInterval = null;

        /**
         * The timeout for determining if a font can't be loaded. Uses the LoadItem {{#crossLink "LoadImte/timeout:property"}}{{/crossLink}}
         * value.
         * @property _loadTimeout
         * @type {Number}
         * @protected
         */
        this._loadTimeout = null;
        /**
         * Determines if generated CSS should be injected into the document.
         * @property _injectCSS
         * @type {boolean}
         * @protected
         */
        this._injectCSS = (loadItem.injectCSS === undefined) ? true : loadItem.injectCSS;

        this.dispatchEvent("initialize");
    }
    var p = createjs.extend(FontLoader, createjs.AbstractLoader);
    
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/FONT:property"}}{{/crossLink}}.
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    FontLoader.canLoadItem = function (item) {
        return item.type == createjs.Types.FONT || item.type == createjs.Types.FONTCSS;
    };

// static properties:
    /**
     * Sample text used by the FontLoader to determine if the font has been loaded. The sample text size is compared
     * to the loaded font size, and a change indicates that the font has completed.
     * @property sampleText
     * @type {String}
     * @default abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
     * @static
     * @private
     */
    FontLoader.sampleText = "abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    /**
     * The canvas context used to test the font size. Note that this currently requires an HTML DOM.
     * @property _ctx
     * @type {CanvasRenderingContext2D}
     * @static
     * @private
     */
    FontLoader._ctx = document.createElement("canvas").getContext("2d"); // TODO: Consider a method to do this like EaselJS Stage has.

    /**
     * A list of reference fonts to test. Multiple faces are tested to address the rare case of a loaded font being the
     * exact same dimensions as the test font.
     * @property _referenceFonts
     * @type {Array}
     * @default ["serif", "monospace"]
     * @private
     */
    FontLoader._referenceFonts = ["serif","monospace"];

    /**
     * A regular expression that pulls out possible style values from the font name.
     * <ul>
     *     <li>This includes font names that include thin, normal, book, regular, medium, black, and heavy (such as
     *     "Arial Black")</li>
     *     <li>Weight modifiers including extra, ultra, semi, demi, light, and bold (such as "WorkSans SemiBold")</li>
     * </ul>
     *
     * Weight descriptions map to font weight values by default using the following (from
     * http://www.w3.org/TR/css3-fonts/#font-weight-numeric-values):
     * <ul>
     *     <li>100 - Thin</li>
     *     <li>200 - Extra Light, Ultra Light</li>
     *     <li>300 - Light, Semi Light, Demi Light</li>
     *     <li>400 - Normal, Book, Regular</li>
     *     <li>500 - Medium</li>
     *     <li>600 - Semi Bold, Demi Bold</li>
     *     <li>700 - Bold</li>
     *     <li>800 - Extra Bold, Ultra Bold</li>
     *     <li>900 - Black, Heavy</li>
     * </ul>
     * @property WEIGHT_REGEX
     * @type {RegExp}
     * @static
     */
    FontLoader.WEIGHT_REGEX = /[- ._]*(thin|normal|book|regular|medium|black|heavy|[1-9]00|(?:extra|ultra|semi|demi)?[- ._]*(?:light|bold))[- ._]*/ig;

    /**
     * A regular expression that pulls out possible style values from the font name. These include "italic"
     * and "oblique".
     * @property STYLE_REGEX
     * @type {RegExp}
     * @static
     */
    FontLoader.STYLE_REGEX = /[- ._]*(italic|oblique)[- ._]*/ig;

    /**
     * A lookup of font types for generating a CSS definition. For example, TTF fonts requires a "truetype" type.
     * @property FONT_FORMAT
     * @type {Object}
     * @static
     */
    FontLoader.FONT_FORMAT = {woff2:"woff2", woff:"woff", ttf:"truetype", otf:"truetype"};

    /**
     * A lookup of font weights based on a name. These values are from http://www.w3.org/TR/css3-fonts/#font-weight-numeric-values.
     * @property FONT_WEIGHT
     * @type {Object}
     * @static
     */
    FontLoader.FONT_WEIGHT = {thin:100, extralight:200, ultralight:200, light:300, semilight:300, demilight:300, book:"normal", regular:"normal", semibold:600, demibold:600, extrabold:800, ultrabold:800, black:900, heavy:900};

    /**
     * The frequency in milliseconds to check for loaded fonts.
     * @property WATCH_DURATION
     * @type {number}
     * @default 10
     * @static
     */
    FontLoader.WATCH_DURATION = 10;
// public methods:
    p.load = function() {
        if (this.type == createjs.Types.FONTCSS) {
            var loaded = this._watchCSS();

            // If the CSS is not ready, it will create a request, which AbstractLoader can handle.
            if (!loaded) {
                this.AbstractLoader_load();
                return;
            }

        } else if (this._item.src instanceof Array) {
            this._watchFontArray();
        } else {
            var def = this._defFromSrc(this._item.src);
            this._watchFont(def);
            this._injectStyleTag(this._cssFromDef(def));
        }

        this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

        this.dispatchEvent("loadstart");
    };

    /**
     * The font load has timed out. This is called via a <code>setTimeout</code>.
     * callback.
     * @method _handleTimeout
     * @protected
     */
    p._handleTimeout = function () {
        this._stopWatching();
        this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT"));
    };

    // WatchCSS does the work for us, and provides a modified src.
    p._createRequest = function() {
        return this._request;
    };

    // Events come from the internal XHR loader.
    p.handleEvent = function (event) {
        switch (event.type) {
            case "complete":
                this._rawResult = event.target._response;
                this._result = true;
                this._parseCSS(this._rawResult);
                break;

            case "error":
                this._stopWatching();
                this.AbstractLoader_handleEvent(event);
                break;
        }
    };

// private methods:
    /**
     * Determine if the provided CSS is a string definition, CSS HTML element, or a CSS file URI. Depending on the
     * format, the CSS will be parsed, or loaded.
     * @method _watchCSS
     * @returns {boolean} Whether or not the CSS is ready
     * @protected
     */
    p._watchCSS = function() {
        var src = this._item.src;

        // An HTMLElement was passed in. Just use it.
        if (src instanceof HTMLStyleElement) {
            if (this._injectCSS && !src.parentNode) { (document.head || document.getElementsByTagName('head')[0]).appendChild(src); }
            this._injectCSS = false;
            src = "\n"+src.textContent;
        }

        // A CSS string was passed in. Parse and use it
        if (src.search(/\n|\r|@font-face/i) !== -1) { // css string.
            this._parseCSS(src);
            return true;
        }

        // Load a CSS Path. Note that we CAN NOT load it without XHR because we need to read the CSS definition
        this._request = new createjs.XHRRequest(this._item);
        return false;
    };

    /**
     * Parse a CSS string to determine the fonts to load.
     * @method _parseCSS
     * @param {String} css The CSS string to parse
     * @protected
     */
    p._parseCSS = function(css) {
        var regex = /@font-face\s*\{([^}]+)}/g
        while (true) {
            var result = regex.exec(css);
            if (!result) { break; }
            this._watchFont(this._parseFontFace(result[1]));
        }
        this._injectStyleTag(css);
    };

    /**
     * The provided fonts were an array of object or string definitions. Parse them, and inject any that are ready.
     * @method _watchFontArray
     * @protected
     */
    p._watchFontArray = function() {
        var arr = this._item.src, css = "", def;
        for (var i=arr.length-1; i>=0; i--) {
            var o = arr[i];
            if (typeof o === "string") { def = this._defFromSrc(o) }
            else { def = this._defFromObj(o); }
            this._watchFont(def);
            css += this._cssFromDef(def)+"\n";
        }
        this._injectStyleTag(css);
    };

    /**
     * Inject any style definitions into the document head. This is necessary when the definition is just a string or
     * object definition in order for the styles to be applied to the document. If the loaded fonts are already HTML CSS
     * elements, they don't need to be appended again.
     * @method _injectStyleTag
     * @param {String} css The CSS string content to be appended to the
     * @protected
     */
    p._injectStyleTag = function(css) {
        if (!this._injectCSS) { return; }
        var head = document.head || document.getElementsByTagName('head')[0];
        var styleTag = document.createElement("style");
        styleTag.type = "text/css";
        if (styleTag.styleSheet){
            styleTag.styleSheet.cssText = css;
        } else {
            styleTag.appendChild(document.createTextNode(css));
        }
        head.appendChild(styleTag);
    };

    /**
     * Determine the font face from a CSS definition.
     * @method _parseFontFace
     * @param {String} str The CSS string definition
     * @protected
     * @return {String} A modified CSS object containing family name, src, style, and weight
     */
    p._parseFontFace = function(str) {
        var family = this._getCSSValue(str, "font-family"), src = this._getCSSValue(str, "src");
        if (!family || !src) { return null; }
        return this._defFromObj({
            family: family,
            src: src,
            style: this._getCSSValue(str, "font-style"),
            weight: this._getCSSValue(str, "font-weight")
        });
    };

    /**
     * Add a font to the list of fonts currently being watched. If the font is already watched or loaded, it won't be
     * added again.
     * @method _watchFont
     * @param {Object} def The font definition
     * @protected
     */
    p._watchFont = function(def) {
        if (!def || this._faces[def.id]) { return; }
        this._faces[def.id] = def;
        this._watched.push(def);
        this._count++;

        this._calculateReferenceSizes(def);
        this._startWatching();
    };

    /**
     * Create a interval to check for loaded fonts. Only one interval is used for all fonts. The fonts are checked based
     * on the {{#crossLink "FontLoader/WATCH_DURATION:property"}}{{/crossLink}}.
     * @method _startWatching
     * @protected
     */
    p._startWatching = function() {
        if (this._watchInterval != null) { return; }
        this._watchInterval = setInterval(createjs.proxy(this._watch, this), FontLoader.WATCH_DURATION);
    };

    /**
     * Clear the interval used to check fonts. This happens when all fonts are loaded, or an error occurs, such as a
     * CSS file error, or a load timeout.
     * @method _stopWatching
     * @protected
     */
    p._stopWatching = function() {
        clearInterval(this._watchInterval);
        clearTimeout(this._loadTimeout);
        this._watchInterval = null;
    };

    /**
     * Check all the fonts that have not been loaded. The fonts are drawn to a canvas in memory, and if their font size
     * varies from the default text size, then the font is considered loaded.
     *
     * A {{#crossLink "AbstractLoader/fileload"}}{{/crossLink}} event will be dispatched when each file is loaded, along
     * with the font family name as the `item` value. A {{#crossLink "ProgressEvent"}}{{/crossLink}} is dispatched a
     * maximum of one time per check when any fonts are loaded, with the {{#crossLink "ProgressEvent/progress:property"}}{{/crossLink}}
     * value showing the percentage of fonts that have loaded.
     * @method _watch
     * @protected
     */
    p._watch = function() {
        var defs = this._watched, refFonts = FontLoader._referenceFonts, l = defs.length;
        for (var i = l - 1; i >= 0; i--) {
            var def = defs[i], refs = def.refs;
            for (var j = refs.length - 1; j >= 0; j--) {
                var w = this._getTextWidth(def.family + "," + refFonts[j], def.weight, def.style);
                if (w != refs[j]) {
                    var event = new createjs.Event("fileload");
                    def.type = "font-family";
                    event.item = def;
                    this.dispatchEvent(event);
                    defs.splice(i, 1);
                    break;
                }
            }
        }
        if (l !== defs.length) {
            var event = new createjs.ProgressEvent(this._count-defs.length, this._count);
            this.dispatchEvent(event);
        }
        if (l === 0) {
            this._stopWatching();
            this._sendComplete();
        }
    };

    /**
     * Determine the default size of the reference fonts used to compare against loaded fonts.
     * @method _calculateReferenceSizes
     * @param {Object} def The font definition to get the size of.
     * @protected
     */
    p._calculateReferenceSizes = function(def) {
        var refFonts = FontLoader._referenceFonts;
        var refs = def.refs = [];
        for (var i=0; i<refFonts.length; i++) {
            refs[i] = this._getTextWidth(refFonts[i], def.weight, def.style);
        }
    };

    /**
     * Get a CSS definition from a font source and name.
     * @method _defFromSrc
     * @param {String} src The font source
     * @protected
     */
    p._defFromSrc = function(src) {
        var re = /[- ._]+/g, name = src, ext = null, index;
        
        index = name.search(/[?#]/);
        if (index !== -1) {
            name = name.substr(0,index);
        }
        index = name.lastIndexOf(".");
        if (index !== -1) {
            ext = name.substr(index+1);
            name = name.substr(0,index);
        }
        index = name.lastIndexOf("/");
        if (index !== -1) {
            name = name.substr(index+1);
        }
        
        var family = name,
                weight = family.match(FontLoader.WEIGHT_REGEX);
        if (weight) {
            weight = weight[0];
            family = family.replace(weight, "");
            weight = weight.replace(re, "").toLowerCase();
        }
        var style = name.match(FontLoader.STYLE_REGEX);
        if (style) {
            family = family.replace(style[0], "");
            style = "italic";
        }
        family = family.replace(re, "");
        
        var cssSrc = "local('"+name.replace(re," ")+"'), url('"+src+"')";
        var format = FontLoader.FONT_FORMAT[ext];
        if (format) { cssSrc += " format('"+format+"')"; }
        
        return this._defFromObj({
            family: family,
            weight: FontLoader.FONT_WEIGHT[weight]||weight,
            style: style,
            src: cssSrc
        });
    };

    /**
     * Get a font definition from a raw font object.
     * @method _defFromObj
     * @param {Object} o A raw object provided to the FontLoader
     * @returns {Object} A standard font object that the FontLoader understands
     * @protected
     */
    p._defFromObj = function(o) {
        var def = {
            family: o.family,
            src: o.src,
            style: o.style || "normal",
            weight: o.weight || "normal"
        };
        def.id = def.family + ";" + def.style + ";" + def.weight;
        return def;
    };

    /**
     * Get CSS from a font definition.
     * @method _cssFromDef
     * @param {Object} def A font definition
     * @returns {string} A CSS string representing the object
     * @protected
     */
    p._cssFromDef = function(def) {
        return "@font-face {\n" +
            "\tfont-family: '"+def.family+"';\n" +
            "\tfont-style: "+def.style+";\n" +
            "\tfont-weight: "+def.weight+";\n" +
            "\tsrc: "+def.src+";\n" +
            "}";
    };

    /**
     * Get the text width of text using the family, weight, and style
     * @method _getTextWidth
     * @param {String} family The font family
     * @param {String} weight The font weight
     * @param {String} style The font style
     * @returns {Number} The pixel measurement of the font.
     * @protected
     */
    p._getTextWidth = function(family, weight, style) {
        var ctx = FontLoader._ctx;
        ctx.font = style+" "+weight+" 72px "+family;
        return ctx.measureText(FontLoader.sampleText).width;
    };

    /**
     * Get the value of a property from a CSS string. For example, searches a CSS string for the value of the
     * "font-family" property.
     * @method _getCSSValue
     * @param {String} str The CSS string to search
     * @param {String} propName The property name to get the value for
     * @returns {String} The value in the CSS for the provided property name
     * @protected
     */
    p._getCSSValue = function(str, propName) {
        var regex = new RegExp(propName+":\s*([^;}]+?)\s*[;}]");
        var result = regex.exec(str);
        if (!result || !result[1]) { return null; }
        return result[1];
    };

    createjs.FontLoader = createjs.promote(FontLoader, "AbstractLoader");

})();

//##############################################################################
// ImageLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for image files.
     * @class ImageLoader
     * @param {LoadItem|Object} loadItem
     * @param {Boolean} preferXHR
     * @extends AbstractLoader
     * @constructor
     */
    function ImageLoader (loadItem, preferXHR) {
        this.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.IMAGE);

        // public properties
        this.resultFormatter = this._formatResult;

        // protected properties
        this._tagSrcAttribute = "src";

        // Check if the preload item is already a tag.
        if (createjs.DomUtils.isImageTag(loadItem)) {
            this._tag = loadItem;
        } else if (createjs.DomUtils.isImageTag(loadItem.src)) {
            this._tag = loadItem.src;
        } else if (createjs.DomUtils.isImageTag(loadItem.tag)) {
            this._tag = loadItem.tag;
        }

        if (this._tag != null) {
            this._preferXHR = false;
        } else {
            this._tag = createjs.Elements.img();
        }

        this.on("initialize", this._updateXHR, this);
    };

    var p = createjs.extend(ImageLoader, createjs.AbstractLoader);
    var s = ImageLoader;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/IMAGE:property"}}{{/crossLink}}.
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.IMAGE;
    };

    // public methods
    p.load = function () {
        if (this._tag.src != "" && this._tag.complete) {
            this._sendComplete();
            return;
        }

        var crossOrigin = this._item.crossOrigin;
        if (crossOrigin == true) { crossOrigin = "Anonymous"; }
        if (crossOrigin != null && !createjs.URLUtils.isLocal(this._item)) {
            this._tag.crossOrigin = crossOrigin;
        }

        this.AbstractLoader_load();
    };

    // protected methods
    /**
     * Before the item loads, set its mimeType and responseType.
     * @property _updateXHR
     * @param {Event} event
     * @private
     */
    p._updateXHR = function (event) {
        event.loader.mimeType = 'text/plain; charset=x-user-defined-binary';

        // Only exists for XHR
        if (event.loader.setResponseType) {
            event.loader.setResponseType("blob");
        }
    };

    /**
     * The result formatter for Image files.
     * @method _formatResult
     * @param {AbstractLoader} loader
     * @returns {HTMLImageElement}
     * @private
     */
    p._formatResult = function (loader) {
        return this._formatImage;
    };

    /**
     * The asynchronous image formatter function. This is required because images have
     * a short delay before they are ready.
     * @method _formatImage
     * @param {Function} successCallback The method to call when the result has finished formatting
     * @param {Function} errorCallback The method to call if an error occurs during formatting
     * @private
     */
    p._formatImage = function (successCallback, errorCallback) {
        var tag = this._tag;
        var URL = window.URL || window.webkitURL;

        if (!this._preferXHR) {

            //document.body.removeChild(tag);
        } else if (URL) {
            var objURL = URL.createObjectURL(this.getResult(true));
            tag.src = objURL;

            tag.addEventListener("load", this._cleanUpURL, false);
            tag.addEventListener("error", this._cleanUpURL, false);
        } else {
            tag.src = this._item.src;
        }

        if (tag.complete) {
            successCallback(tag);
        } else {
            tag.onload = createjs.proxy(function() {
                successCallback(this._tag);
                tag.onload = tag.onerror = null;
            }, this);

            tag.onerror = createjs.proxy(function(event) {
                errorCallback(new createjs.ErrorEvent('IMAGE_FORMAT', null, event));
                tag.onload = tag.onerror = null;
            }, this);
        }
    };

    /**
     * Clean up the ObjectURL, the tag is done with it. Note that this function is run
     * as an event listener without a proxy/closure, as it doesn't require it - so do not
     * include any functionality that requires scope without changing it.
     * @method _cleanUpURL
     * @param event
     * @private
     */
    p._cleanUpURL = function (event) {
        var URL = window.URL || window.webkitURL;
        URL.revokeObjectURL(event.target.src);
    };

    createjs.ImageLoader = createjs.promote(ImageLoader, "AbstractLoader");

}());

//##############################################################################
// JavaScriptLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for JavaScript files.
     * @class JavaScriptLoader
     * @param {LoadItem|Object} loadItem
     * @param {Boolean} preferXHR
     * @extends AbstractLoader
     * @constructor
     */
    function JavaScriptLoader(loadItem, preferXHR) {
        this.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.JAVASCRIPT);

        // public properties
        this.resultFormatter = this._formatResult;

        // protected properties
        this._tagSrcAttribute = "src";
        this.setTag(createjs.Elements.script());
    };

    var p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);
    var s = JavaScriptLoader;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/JAVASCRIPT:property"}}{{/crossLink}}
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.JAVASCRIPT;
    };

    // protected methods
    /**
     * The result formatter for JavaScript files.
     * @method _formatResult
     * @param {AbstractLoader} loader
     * @returns {HTMLLinkElement|HTMLStyleElement}
     * @private
     */
    p._formatResult = function (loader) {
        var tag = loader.getTag();
        if (this._preferXHR) {
            tag.text = loader.getResult(true);
        }
        return tag;
    };

    createjs.JavaScriptLoader = createjs.promote(JavaScriptLoader, "AbstractLoader");

}());

//##############################################################################
// JSONLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink "JSONPLoader"}}{{/crossLink}}
     * instead. To load JSON-formatted manifests, use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to
     * load EaselJS SpriteSheets, use {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.
     * @class JSONLoader
     * @param {LoadItem|Object} loadItem
     * @extends AbstractLoader
     * @constructor
     */
    function JSONLoader(loadItem) {
        this.AbstractLoader_constructor(loadItem, true, createjs.Types.JSON);

        // public properties
        this.resultFormatter = this._formatResult;
    };

    var p = createjs.extend(JSONLoader, createjs.AbstractLoader);
    var s = JSONLoader;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/JSON:property"}}{{/crossLink}}.
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.JSON;
    };

    // protected methods
    /**
     * The result formatter for JSON files.
     * @method _formatResult
     * @param {AbstractLoader} loader
     * @returns {HTMLLinkElement|HTMLStyleElement}
     * @private
     */
    p._formatResult = function (loader) {
        var json = null;
        try {
            json = createjs.DataUtils.parseJSON(loader.getResult(true));
        } catch (e) {
            var event = new createjs.ErrorEvent("JSON_FORMAT", null, e);
            this._sendError(event);
            return e;
        }

        return json;
    };

    createjs.JSONLoader = createjs.promote(JSONLoader, "AbstractLoader");

}());

//##############################################################################
// JSONPLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON
     * without a callback use the {{#crossLink "JSONLoader"}}{{/crossLink}} instead. To load JSON-formatted manifests,
     * use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to load EaselJS SpriteSheets, use
     * {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.
     *
     * JSONP is a format that provides a solution for loading JSON files cross-domain <em>without</em> requiring CORS.
     * JSONP files are loaded as JavaScript, and the "callback" is executed once they are loaded. The callback in the
     * JSONP must match the callback passed to the loadItem.
     *
     * <h4>Example JSONP</h4>
     *
     *      callbackName({
     *          "name": "value",
     *          "num": 3,
     *          "obj": { "bool":true }
     *      });
     *
     * <h4>Example</h4>
     *
     *      var loadItem = {id:"json", type:"jsonp", src:"http://server.com/text.json", callback:"callbackName"}
     *      var queue = new createjs.LoadQueue();
     *      queue.on("complete", handleComplete);
     *      queue.loadItem(loadItem);
     *
     *      function handleComplete(event) }
     *          var json = queue.getResult("json");
     *          console.log(json.obj.bool); // true
     *      }
     *
     * JSONP files loaded concurrently require a <em>unique</em> callback. To ensure JSONP files are loaded in order,
     * either use the {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} method (set to 1), or set
     * {{#crossLink "LoadItem/maintainOrder:property"}}{{/crossLink}} on items with the same callback.
     *
     * Important note: Some browsers will prevent JSONP from firing the callback if the file was loaded as JSON, and not
     * JavaScript. You may have to have your server give you a JavaScript mime-type for this to work.
     *
     * @class JSONPLoader
     * @param {LoadItem|Object} loadItem
     * @extends AbstractLoader
     * @constructor
     */
    function JSONPLoader(loadItem) {
        this.AbstractLoader_constructor(loadItem, false, createjs.Types.JSONP);
        this.setTag(createjs.Elements.script());
        this.getTag().type = "text/javascript";
    };

    var p = createjs.extend(JSONPLoader, createjs.AbstractLoader);
    var s = JSONPLoader;


    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/JSONP:property"}}{{/crossLink}}.
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.JSONP;
    };

    // public methods
    p.cancel = function () {
        this.AbstractLoader_cancel();
        this._dispose();
    };

    /**
     * Loads the JSONp file.  Because of the unique loading needs of JSONp
     * we don't use the AbstractLoader.load() method.
     *
     * @method load
     *
     */
    p.load = function () {
        if (this._item.callback == null) {
            throw new Error('callback is required for loading JSONP requests.');
        }

        // TODO: Look into creating our own iFrame to handle the load
        // In the first attempt, FF did not get the result
        //   result instanceof Object did not work either
        //   so we would need to clone the result.
        if (window[this._item.callback] != null) {
            throw new Error(
                "JSONP callback '" +
                this._item.callback +
                "' already exists on window. You need to specify a different callback or re-name the current one.");
        }

        window[this._item.callback] = createjs.proxy(this._handleLoad, this);
        createjs.DomUtils.appendToBody(this._tag);

        this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

        // Load the tag
        this._tag.src = this._item.src;
    };

    // private methods
    /**
     * Handle the JSONP callback, which is a public method defined on `window`.
     * @method _handleLoad
     * @param {Object} data The formatted JSON data.
     * @private
     */
    p._handleLoad = function (data) {
        this._result = this._rawResult = data;
        this._sendComplete();

        this._dispose();
    };

    /**
     * The tag request has not loaded within the time specfied in loadTimeout.
     * @method _handleError
     * @param {Object} event The XHR error event.
     * @private
     */
    p._handleTimeout = function () {
        this._dispose();
        this.dispatchEvent(new createjs.ErrorEvent("timeout"));
    };

    /**
     * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.
     * @method _dispose
     * @private
     */
    p._dispose = function () {
        createjs.DomUtils.removeChild(this._tag);
        delete window[this._item.callback];

        clearTimeout(this._loadTimeout);
    };

    createjs.JSONPLoader = createjs.promote(JSONPLoader, "AbstractLoader");

}());

//##############################################################################
// ManifestLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests
     * using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}} as part of the
     * {{#crossLink "LoadItem"}}{{/crossLink}}.
     *
     * The list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This
     * example shows a sample manifest definition, as well as how to to include a sub-manifest.
     *
     *      {
     *          "path": "assets/",
     *          "manifest": [
     *              "image.png",
     *              {"src": "image2.png", "id":"image2"},
     *              {"src": "sub-manifest.json", "type":"manifest", "callback":"jsonCallback"}
     *          ]
     *      }
     *
     * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink "LoadQueue"}}{{/crossLink}},
     * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.
     *
     * Note that the {{#crossLink "JSONLoader"}}{{/crossLink}} and {{#crossLink "JSONPLoader"}}{{/crossLink}} are
     * higher priority loaders, so manifests <strong>must</strong> set the {{#crossLink "LoadItem"}}{{/crossLink}}
     * {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property to {{#crossLink "Types/MANIFEST:property"}}{{/crossLink}}.
     *
     * Additionally, some browsers require the server to serve a JavaScript mime-type for JSONP, so it may not work in
     * some conditions.
     * @class ManifestLoader
     * @param {LoadItem|Object} loadItem
     * @extends AbstractLoader
     * @constructor
     */
    function ManifestLoader(loadItem, preferXHR) {
        this.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.MANIFEST);

    // Public Properties
        /**
         * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}},
         * used to pass plugins to new LoadQueues that may be created.
         * @property _plugins
         * @type {Array}
         * @private
         * @since 0.6.1
         */
        this.plugins = null;


    // Protected Properties
        /**
         * An internal {{#crossLink "LoadQueue"}}{{/crossLink}} that loads the contents of the manifest.
         * @property _manifestQueue
         * @type {LoadQueue}
         * @private
         */
        this._manifestQueue = null;
    };

    var p = createjs.extend(ManifestLoader, createjs.AbstractLoader);
    var s = ManifestLoader;

    // static properties
    /**
     * The amount of progress that the manifest itself takes up.
     * @property MANIFEST_PROGRESS
     * @type {number}
     * @default 0.25 (25%)
     * @private
     * @static
     */
    s.MANIFEST_PROGRESS = 0.25;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/MANIFEST:property"}}{{/crossLink}}
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.MANIFEST;
    };

    // public methods
    p.load = function () {
        this.AbstractLoader_load();
    };

    // protected methods
    p._createRequest = function() {
        var callback = this._item.callback;
        if (callback != null) {
            this._request = new createjs.JSONPLoader(this._item);
        } else {
            this._request = new createjs.JSONLoader(this._item);
        }
    };

    p.handleEvent = function (event) {
        switch (event.type) {
            case "complete":
                this._rawResult = event.target.getResult(true);
                this._result = event.target.getResult();
                this._sendProgress(s.MANIFEST_PROGRESS);
                this._loadManifest(this._result);
                return;
            case "progress":
                event.loaded *= s.MANIFEST_PROGRESS;
                this.progress = event.loaded / event.total;
                if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
                this._sendProgress(event);
                return;
        }
        this.AbstractLoader_handleEvent(event);
    };

    p.destroy = function() {
        this.AbstractLoader_destroy();
        this._manifestQueue.close();
    };

    /**
     * Create and load the manifest items once the actual manifest has been loaded.
     * @method _loadManifest
     * @param {Object} json
     * @private
     */
    p._loadManifest = function (json) {
        if (json && json.manifest) {
            var queue = this._manifestQueue = new createjs.LoadQueue(this._preferXHR);
            queue.on("fileload", this._handleManifestFileLoad, this);
            queue.on("progress", this._handleManifestProgress, this);
            queue.on("complete", this._handleManifestComplete, this, true);
            queue.on("error", this._handleManifestError, this, true);
            for(var i = 0, l = this.plugins.length; i < l; i++) {   // conserve order of plugins
                queue.installPlugin(this.plugins[i]);
            }
            queue.loadManifest(json);
        } else {
            this._sendComplete();
        }
    };

    /**
     * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.
     * @method _handleManifestFileLoad
     * @param {Event} event
     * @private
     */
    p._handleManifestFileLoad = function (event) {
        event.target = null;
        this.dispatchEvent(event);
    };

    /**
     * The manifest has completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}
     * {{#crossLink "Event"}}{{/crossLink}} from the ManifestLoader.
     * @method _handleManifestComplete
     * @param {Event} event
     * @private
     */
    p._handleManifestComplete = function (event) {
        this._loadedItems = this._manifestQueue.getItems(true);
        this._sendComplete();
    };

    /**
     * The manifest has reported progress.
     * @method _handleManifestProgress
     * @param {ProgressEvent} event
     * @private
     */
    p._handleManifestProgress = function (event) {
        this.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;
        this._sendProgress(this.progress);
    };

    /**
     * The manifest has reported an error with one of the files.
     * @method _handleManifestError
     * @param {ErrorEvent} event
     * @private
     */
    p._handleManifestError = function (event) {
        var newEvent = new createjs.Event("fileerror");
        newEvent.item = event.data;
        this.dispatchEvent(newEvent);
    };

    createjs.ManifestLoader = createjs.promote(ManifestLoader, "AbstractLoader");

}());

//##############################################################################
// SoundLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which
     * should be created by either a library playing the sound (such as <a href="http://soundjs.com">SoundJS</a>, or an
     * external framework that handles audio playback. To load content that can be played by WebAudio, use the
     * {{#crossLink "BinaryLoader"}}{{/crossLink}}, and handle the audio context decoding manually.
     * @class SoundLoader
     * @param {LoadItem|Object} loadItem
     * @param {Boolean} preferXHR
     * @extends AbstractMediaLoader
     * @constructor
     */
    function SoundLoader(loadItem, preferXHR) {
        this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.Types.SOUND);

        // protected properties
        if (createjs.DomUtils.isAudioTag(loadItem)) {
            this._tag = loadItem;
        } else if (createjs.DomUtils.isAudioTag(loadItem.src)) {
            this._tag = loadItem;
        } else if (createjs.DomUtils.isAudioTag(loadItem.tag)) {
            this._tag = createjs.DomUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;
        }

        if (this._tag != null) {
            this._preferXHR = false;
        }
    };

    var p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);
    var s = SoundLoader;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/SOUND:property"}}{{/crossLink}}.
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.SOUND;
    };

    // protected methods
    p._createTag = function (src) {
        var tag = createjs.Elements.audio();
        tag.autoplay = false;
        tag.preload = "none";

        //LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.
        tag.src = src;
        return tag;
    };

    createjs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader");

}());

//##############################################################################
// VideoLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for video files.
     * @class VideoLoader
     * @param {LoadItem|Object} loadItem
     * @param {Boolean} preferXHR
     * @extends AbstractMediaLoader
     * @constructor
     */
    function VideoLoader(loadItem, preferXHR) {
        this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.Types.VIDEO);

        if (createjs.DomUtils.isVideoTag(loadItem) || createjs.DomUtils.isVideoTag(loadItem.src)) {
            this.setTag(createjs.DomUtils.isVideoTag(loadItem)?loadItem:loadItem.src);

            // We can't use XHR for a tag that's passed in.
            this._preferXHR = false;
        } else {
            this.setTag(this._createTag());
        }
    };

    var p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);
    var s = VideoLoader;

    /**
     * Create a new video tag
     *
     * @returns {HTMLElement}
     * @private
     */
    p._createTag = function () {
        return createjs.Elements.video();
    };

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/VIDEO:property"}}{{/crossLink}}.
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.VIDEO;
    };

    createjs.VideoLoader = createjs.promote(VideoLoader, "AbstractMediaLoader");

}());

//##############################################################################
// SpriteSheetLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader
     * completes. To load SpriteSheets using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}}
     * as part of the {{#crossLink "LoadItem"}}{{/crossLink}}. Note that the {{#crossLink "JSONLoader"}}{{/crossLink}}
     * and {{#crossLink "JSONPLoader"}}{{/crossLink}} are higher priority loaders, so SpriteSheets <strong>must</strong>
     * set the {{#crossLink "LoadItem"}}{{/crossLink}} {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property
     * to {{#crossLink "Types/SPRITESHEET:property"}}{{/crossLink}}.
     *
     * The {{#crossLink "LoadItem"}}{{/crossLink}} {{#crossLink "LoadItem/crossOrigin:property"}}{{/crossLink}} as well
     * as the {{#crossLink "LoadQueue's"}}{{/crossLink}} `basePath` argument and {{#crossLink "LoadQueue/_preferXHR"}}{{/crossLink}}
     * property supplied to the {{#crossLink "LoadQueue"}}{{/crossLink}} are passed on to the sub-manifest that loads
     * the SpriteSheet images.
     *
     * Note that the SpriteSheet JSON does not respect the {{#crossLink "LoadQueue/_preferXHR:property"}}{{/crossLink}}
     * property, which should instead be determined by the presence of a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}}
     * property on the SpriteSheet load item. This is because the JSON loaded will have a different format depending on
     * if it is loaded as JSON, so just changing `preferXHR` is not enough to change how it is loaded.
     * @class SpriteSheetLoader
     * @param {LoadItem|Object} loadItem
     * @extends AbstractLoader
     * @constructor
     */
    function SpriteSheetLoader(loadItem, preferXHR) {
        this.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.SPRITESHEET);

        // protected properties
        /**
         * An internal queue which loads the SpriteSheet's images.
         * @method _manifestQueue
         * @type {LoadQueue}
         * @private
         */
        this._manifestQueue = null;
    }

    var p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);
    var s = SpriteSheetLoader;

    // static properties
    /**
     * The amount of progress that the manifest itself takes up.
     * @property SPRITESHEET_PROGRESS
     * @type {number}
     * @default 0.25 (25%)
     * @private
     * @static
     */
    s.SPRITESHEET_PROGRESS = 0.25;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/SPRITESHEET:property"}}{{/crossLink}}
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.SPRITESHEET;
    };

    // public methods
    p.destroy = function() {
        this.AbstractLoader_destroy();
        this._manifestQueue.close();
    };

    // protected methods
    p._createRequest = function() {
        var callback = this._item.callback;
        if (callback != null) {
            this._request = new createjs.JSONPLoader(this._item);
        } else {
            this._request = new createjs.JSONLoader(this._item);
        }
    };

    p.handleEvent = function (event) {
        switch (event.type) {
            case "complete":
                this._rawResult = event.target.getResult(true);
                this._result = event.target.getResult();
                this._sendProgress(s.SPRITESHEET_PROGRESS);
                this._loadManifest(this._result);
                return;
            case "progress":
                event.loaded *= s.SPRITESHEET_PROGRESS;
                this.progress = event.loaded / event.total;
                if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
                this._sendProgress(event);
                return;
        }
        this.AbstractLoader_handleEvent(event);
    };

    /**
     * Create and load the images once the SpriteSheet JSON has been loaded.
     * @method _loadManifest
     * @param {Object} json
     * @private
     */
    p._loadManifest = function (json) {
        if (json && json.images) {
            var queue = this._manifestQueue = new createjs.LoadQueue(this._preferXHR, this._item.path, this._item.crossOrigin);
            queue.on("complete", this._handleManifestComplete, this, true);
            queue.on("fileload", this._handleManifestFileLoad, this);
            queue.on("progress", this._handleManifestProgress, this);
            queue.on("error", this._handleManifestError, this, true);
            queue.loadManifest(json.images);
        }
    };

    /**
     * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.
     * @method _handleManifestFileLoad
     * @param {Event} event
     * @private
     */
    p._handleManifestFileLoad = function (event) {
        var image = event.result;
        if (image != null) {
            var images = this.getResult().images;
            var pos = images.indexOf(event.item.src);
            images[pos] = image;
        }
    };

    /**
     * The images have completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}
     * {{#crossLink "Event"}}{{/crossLink}} from the SpriteSheetLoader.
     * @method _handleManifestComplete
     * @param {Event} event
     * @private
     */
    p._handleManifestComplete = function (event) {
        this._result = new createjs.SpriteSheet(this._result);
        this._loadedItems = this._manifestQueue.getItems(true);
        this._sendComplete();
    };

    /**
     * The images {{#crossLink "LoadQueue"}}{{/crossLink}} has reported progress.
     * @method _handleManifestProgress
     * @param {ProgressEvent} event
     * @private
     */
    p._handleManifestProgress = function (event) {
        this.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;
        this._sendProgress(this.progress);
    };

    /**
     * An image has reported an error.
     * @method _handleManifestError
     * @param {ErrorEvent} event
     * @private
     */
    p._handleManifestError = function (event) {
        var newEvent = new createjs.Event("fileerror");
        newEvent.item = event.data;
        this.dispatchEvent(newEvent);
    };

    createjs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, "AbstractLoader");

}());

//##############################################################################
// SVGLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for SVG files.
     * @class SVGLoader
     * @param {LoadItem|Object} loadItem
     * @param {Boolean} preferXHR
     * @extends AbstractLoader
     * @constructor
     */
    function SVGLoader(loadItem, preferXHR) {
        this.AbstractLoader_constructor(loadItem, preferXHR, createjs.Types.SVG);

        // public properties
        this.resultFormatter = this._formatResult;

        // protected properties
        this._tagSrcAttribute = "data";

        if (preferXHR) {
            this.setTag(createjs.Elements.svg());
        } else {
            this.setTag(createjs.Elements.object());
            this.getTag().type = "image/svg+xml";
        }
    };

    var p = createjs.extend(SVGLoader, createjs.AbstractLoader);
    var s = SVGLoader;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/SVG:property"}}{{/crossLink}}
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.SVG;
    };

    // protected methods
    /**
     * The result formatter for SVG files.
     * @method _formatResult
     * @param {AbstractLoader} loader
     * @returns {Object}
     * @private
     */
    p._formatResult = function (loader) {
        // mime should be image/svg+xml, but Opera requires text/xml
        var xml = createjs.DataUtils.parseXML(loader.getResult(true));
        var tag = loader.getTag();

        if (!this._preferXHR && document.body.contains(tag)) {
            document.body.removeChild(tag);
        }

        if (xml.documentElement != null) {
            var element = xml.documentElement;
            // Support loading an SVG from a different domain in ID
            if (document.importNode) {
                element = document.importNode(element, true);
            }
            tag.appendChild(element);
            return tag;
        } else { // For browsers that don't support SVG, just give them the XML. (IE 9-8)
            return xml;
        }
    };

    createjs.SVGLoader = createjs.promote(SVGLoader, "AbstractLoader");

}());

//##############################################################################
// XMLLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
    "use strict";

    // constructor
    /**
     * A loader for CSS files.
     * @class XMLLoader
     * @param {LoadItem|Object} loadItem
     * @extends AbstractLoader
     * @constructor
     */
    function XMLLoader(loadItem) {
        this.AbstractLoader_constructor(loadItem, true, createjs.Types.XML);

        // public properties
        this.resultFormatter = this._formatResult;
    };

    var p = createjs.extend(XMLLoader, createjs.AbstractLoader);
    var s = XMLLoader;

    // static methods
    /**
     * Determines if the loader can load a specific item. This loader can only load items that are of type
     * {{#crossLink "Types/XML:property"}}{{/crossLink}}.
     * @method canLoadItem
     * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
     * @returns {Boolean} Whether the loader can load the item.
     * @static
     */
    s.canLoadItem = function (item) {
        return item.type == createjs.Types.XML;
    };

    // protected methods
    /**
     * The result formatter for XML files.
     * @method _formatResult
     * @param {AbstractLoader} loader
     * @returns {XMLDocument}
     * @private
     */
    p._formatResult = function (loader) {
        return createjs.DataUtils.parseXML(loader.getResult(true));
    };

    createjs.XMLLoader = createjs.promote(XMLLoader, "AbstractLoader");

}());
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJ2ZW5kb3IvcHJlbG9hZGpzXzAuNi4yLm1pbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiogUHJlbG9hZEpTXG4qIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEwIGdza2lubmVyLmNvbSwgaW5jLlxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuKiBjb25kaXRpb25zOlxuKlxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4qIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mIHRoZSBsaWJyYXJ5LlxuICAgICAqIEBjbGFzcyBQcmVsb2FkSlNcbiAgICAgKiovXG4gICAgdmFyIHMgPSBjcmVhdGVqcy5QcmVsb2FkSlMgPSBjcmVhdGVqcy5QcmVsb2FkSlMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cbiAgICAgKiBAcHJvcGVydHkgdmVyc2lvblxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqKi9cbiAgICBzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIk5FWFRcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuICAgICAqIEBwcm9wZXJ0eSBidWlsZERhdGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiovXG4gICAgcy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIldlZCwgMjEgSnVuIDIwMTcgMTY6NDI6NDAgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGV4dGVuZC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgY29uc3RydWN0b3IgcHJvcGVydHkgZm9yIGEgbmV3IGNsYXNzLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCByaWdodCBhZnRlciBjcmVhdGluZyB0aGUgY2xhc3MgY29uc3RydWN0b3IuXG4gKlxuICogIGZ1bmN0aW9uIE15U3ViQ2xhc3MoKSB7fVxuICogIGNyZWF0ZWpzLmV4dGVuZChNeVN1YkNsYXNzLCBNeVN1cGVyQ2xhc3MpO1xuICogIE15U3ViQ2xhc3MucHJvdG90eXBlLmRvU29tZXRoaW5nID0gZnVuY3Rpb24oKSB7IH1cbiAqXG4gKiAgdmFyIGZvbyA9IG5ldyBNeVN1YkNsYXNzKCk7XG4gKiAgY29uc29sZS5sb2coZm9vIGluc3RhbmNlb2YgTXlTdXBlckNsYXNzKTsgLy8gdHJ1ZVxuICogIGNvbnNvbGUubG9nKGZvby5wcm90b3R5cGUuY29uc3RydWN0b3IgPT09IE15U3ViQ2xhc3MpOyAvLyB0cnVlXG4gKlxuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBzdWJjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyY2xhc3MgVGhlIHN1cGVyY2xhc3MgdG8gZXh0ZW5kLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHN1YmNsYXNzJ3MgbmV3IHByb3RvdHlwZS5cbiAqL1xuY3JlYXRlanMuZXh0ZW5kID0gZnVuY3Rpb24oc3ViY2xhc3MsIHN1cGVyY2xhc3MpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIG8oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBzdWJjbGFzczsgfVxuICAgIG8ucHJvdG90eXBlID0gc3VwZXJjbGFzcy5wcm90b3R5cGU7XG4gICAgcmV0dXJuIChzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgbygpKTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm9tb3RlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogUHJvbW90ZXMgYW55IG1ldGhvZHMgb24gdGhlIHN1cGVyIGNsYXNzIHRoYXQgd2VyZSBvdmVycmlkZGVuLCBieSBjcmVhdGluZyBhbiBhbGlhcyBpbiB0aGUgZm9ybWF0IGBwcmVmaXhfbWV0aG9kTmFtZWAuXG4gKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIHN1cGVyIGNsYXNzJ3MgbmFtZSBhcyB0aGUgcHJlZml4LlxuICogQW4gYWxpYXMgdG8gdGhlIHN1cGVyIGNsYXNzJ3MgY29uc3RydWN0b3IgaXMgYWx3YXlzIGFkZGVkIGluIHRoZSBmb3JtYXQgYHByZWZpeF9jb25zdHJ1Y3RvcmAuXG4gKiBUaGlzIGFsbG93cyB0aGUgc3ViY2xhc3MgdG8gY2FsbCBzdXBlciBjbGFzcyBtZXRob2RzIHdpdGhvdXQgdXNpbmcgYGZ1bmN0aW9uLmNhbGxgLCBwcm92aWRpbmcgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBgTXlTdWJDbGFzc2AgZXh0ZW5kcyBgTXlTdXBlckNsYXNzYCwgYW5kIGJvdGggZGVmaW5lIGEgYGRyYXdgIG1ldGhvZCwgdGhlbiBjYWxsaW5nIGBwcm9tb3RlKE15U3ViQ2xhc3MsIFwiTXlTdXBlckNsYXNzXCIpYFxuICogd291bGQgYWRkIGEgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAgbWV0aG9kIHRvIE15U3ViQ2xhc3MgYW5kIHByb21vdGUgdGhlIGBkcmF3YCBtZXRob2Qgb24gYE15U3VwZXJDbGFzc2AgdG8gdGhlXG4gKiBwcm90b3R5cGUgb2YgYE15U3ViQ2xhc3NgIGFzIGBNeVN1cGVyQ2xhc3NfZHJhd2AuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoZSBjbGFzcydzIHByb3RvdHlwZSBpcyBmdWxseSBkZWZpbmVkLlxuICpcbiAqICBmdW5jdGlvbiBDbGFzc0EobmFtZSkge1xuICogICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICogIH1cbiAqICBDbGFzc0EucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgIHJldHVybiBcIkhlbGxvIFwiK3RoaXMubmFtZTtcbiAqICB9XG4gKlxuICogIGZ1bmN0aW9uIENsYXNzQihuYW1lLCBwdW5jdHVhdGlvbikge1xuICogICAgICB0aGlzLkNsYXNzQV9jb25zdHJ1Y3RvcihuYW1lKTtcbiAqICAgICAgdGhpcy5wdW5jdHVhdGlvbiA9IHB1bmN0dWF0aW9uO1xuICogIH1cbiAqICBjcmVhdGVqcy5leHRlbmQoQ2xhc3NCLCBDbGFzc0EpO1xuICogIENsYXNzQi5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqICAgICAgcmV0dXJuIHRoaXMuQ2xhc3NBX2dyZWV0KCkrdGhpcy5wdW5jdHVhdGlvbjtcbiAqICB9XG4gKiAgY3JlYXRlanMucHJvbW90ZShDbGFzc0IsIFwiQ2xhc3NBXCIpO1xuICpcbiAqICB2YXIgZm9vID0gbmV3IENsYXNzQihcIldvcmxkXCIsIFwiIT8hXCIpO1xuICogIGNvbnNvbGUubG9nKGZvby5ncmVldCgpKTsgLy8gSGVsbG8gV29ybGQhPyFcbiAqXG4gKiBAbWV0aG9kIHByb21vdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBjbGFzcyB0byBwcm9tb3RlIHN1cGVyIGNsYXNzIG1ldGhvZHMgb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBwcm9tb3RlZCBtZXRob2QgbmFtZXMuIFVzdWFsbHkgdGhlIG5hbWUgb2YgdGhlIHN1cGVyY2xhc3MuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MuXG4gKi9cbmNyZWF0ZWpzLnByb21vdGUgPSBmdW5jdGlvbihzdWJjbGFzcywgcHJlZml4KSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgc3ViUCA9IHN1YmNsYXNzLnByb3RvdHlwZSwgc3VwUCA9IChPYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihzdWJQKSl8fHN1YlAuX19wcm90b19fO1xuICAgIGlmIChzdXBQKSB7XG4gICAgICAgIHN1YlBbKHByZWZpeCs9XCJfXCIpICsgXCJjb25zdHJ1Y3RvclwiXSA9IHN1cFAuY29uc3RydWN0b3I7IC8vIGNvbnN0cnVjdG9yIGlzIG5vdCBhbHdheXMgaW5udW1lcmFibGVcbiAgICAgICAgZm9yICh2YXIgbiBpbiBzdXBQKSB7XG4gICAgICAgICAgICBpZiAoc3ViUC5oYXNPd25Qcm9wZXJ0eShuKSAmJiAodHlwZW9mIHN1cFBbbl0gPT0gXCJmdW5jdGlvblwiKSkgeyBzdWJQW3ByZWZpeCArIG5dID0gc3VwUFtuXTsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJjbGFzcztcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm94eS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0aWVzIHRoYXQgdGhlIENyZWF0ZUpTIFN1aXRlIHVzZXMuIFV0aWxpdGllcyBhcmUgY3JlYXRlZCBhcyBzZXBhcmF0ZSBmaWxlcywgYW5kIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZVxuICogY3JlYXRlanMgbmFtZXNwYWNlIGRpcmVjdGx5LlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgY3JlYXRlanMucHJveHkobXlNZXRob2QsIHNjb3BlKSk7XG4gKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICogQG1haW4gVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiBwcm94eSBmb3IgbWV0aG9kcy4gQnkgZGVmYXVsdCwgSmF2YVNjcmlwdCBtZXRob2RzIGRvIG5vdCBtYWludGFpbiBzY29wZSwgc28gcGFzc2luZyBhIG1ldGhvZCBhcyBhXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXN1bHQgaW4gdGhlIG1ldGhvZCBnZXR0aW5nIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIGNhbGxlci4gVXNpbmcgYSBwcm94eSBlbnN1cmVzIHRoYXQgdGhlXG4gICAgICogbWV0aG9kIGdldHMgY2FsbGVkIGluIHRoZSBjb3JyZWN0IHNjb3BlLlxuICAgICAqXG4gICAgICogQWRkaXRpb25hbCBhcmd1bWVudHMgY2FuIGJlIHBhc3NlZCB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZnVuY3Rpb24gd2hlbiBpdCBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gICAgICpcbiAgICAgKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJldmVudFwiLCBjcmVhdGVqcy5wcm94eShteUhhbmRsZXIsIHRoaXMsIGFyZzEsIGFyZzIpKTtcbiAgICAgKlxuICAgICAqICAgICAgZnVuY3Rpb24gbXlIYW5kbGVyKGFyZzEsIGFyZzIpIHtcbiAgICAgKiAgICAgICAgICAgLy8gVGhpcyBnZXRzIGNhbGxlZCB3aGVuIG15T2JqZWN0Lm15Q2FsbGJhY2sgaXMgZXhlY3V0ZWQuXG4gICAgICogICAgICB9XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHByb3h5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFRoZSBzY29wZSB0byBjYWxsIHRoZSBtZXRob2QgbmFtZSBvblxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IFthcmddICogQXJndW1lbnRzIHRoYXQgYXJlIGFwcGVuZGVkIHRvIHRoZSBjYWxsYmFjayBmb3IgYWRkaXRpb25hbCBwYXJhbXMuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBjcmVhdGVqcy5wcm94eSA9IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlKSB7XG4gICAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHNjb3BlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLmNvbmNhdChhQXJncykpO1xuICAgICAgICB9O1xuICAgIH1cblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGluZGV4T2YuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHNwZWNpZmllZCB2YWx1ZSBzZWFyY2hFbGVtZW50IGluIHRoZSBwYXNzZWQgaW4gYXJyYXksIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZlxuICogdGhhdCB2YWx1ZS4gIFJldHVybnMgLTEgaWYgdmFsdWUgaXMgbm90IGZvdW5kLlxuICpcbiAqICAgICAgdmFyIGkgPSBjcmVhdGVqcy5pbmRleE9mKG15QXJyYXksIG15RWxlbWVudFRvRmluZCk7XG4gKlxuICogQG1ldGhvZCBpbmRleE9mXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBzZWFyY2ggZm9yIHNlYXJjaEVsZW1lbnRcbiAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gZmluZCBpbiBhcnJheS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGZpcnN0IGluZGV4IG9mIHNlYXJjaEVsZW1lbnQgaW4gYXJyYXkuXG4gKi9cbmNyZWF0ZWpzLmluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIHNlYXJjaEVsZW1lbnQpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsbD1hcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHNlYXJjaEVsZW1lbnQgPT09IGFycmF5W2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvcjpcbiAgICAvKipcbiAgICAgKiBDb250YWlucyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHNoYXJlZCBieSBhbGwgZXZlbnRzIGZvciB1c2Ugd2l0aFxuICAgICAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBcbiAgICAgKiBOb3RlIHRoYXQgRXZlbnQgb2JqZWN0cyBhcmUgb2Z0ZW4gcmV1c2VkLCBzbyB5b3Ugc2hvdWxkIG5ldmVyXG4gICAgICogcmVseSBvbiBhbiBldmVudCBvYmplY3QncyBzdGF0ZSBvdXRzaWRlIG9mIHRoZSBjYWxsIHN0YWNrIGl0IHdhcyByZWNlaXZlZCBpbi5cbiAgICAgKiBAY2xhc3MgRXZlbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZC5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiovXG4gICAgZnVuY3Rpb24gRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuICAgICAgICBcbiAgICBcbiAgICAvLyBwdWJsaWMgcHJvcGVydGllczpcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9iamVjdCB0aGF0IGdlbmVyYXRlZCBhbiBldmVudC5cbiAgICAgICAgICogQHByb3BlcnR5IHRhcmdldFxuICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgdGFyZ2V0IHRoYXQgYSBidWJibGluZyBldmVudCBpcyBiZWluZyBkaXNwYXRjaGVkIGZyb20uIEZvciBub24tYnViYmxpbmcgZXZlbnRzLCB0aGlzIHdpbGxcbiAgICAgICAgICogYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRhcmdldC4gRm9yIGV4YW1wbGUsIGlmIGNoaWxkT2JqLnBhcmVudCA9IHBhcmVudE9iaiwgYW5kIGEgYnViYmxpbmcgZXZlbnRcbiAgICAgICAgICogaXMgZ2VuZXJhdGVkIGZyb20gY2hpbGRPYmosIHRoZW4gYSBsaXN0ZW5lciBvbiBwYXJlbnRPYmogd291bGQgcmVjZWl2ZSB0aGUgZXZlbnQgd2l0aFxuICAgICAgICAgKiB0YXJnZXQ9Y2hpbGRPYmogKHRoZSBvcmlnaW5hbCB0YXJnZXQpIGFuZCBjdXJyZW50VGFyZ2V0PXBhcmVudE9iaiAod2hlcmUgdGhlIGxpc3RlbmVyIHdhcyBhZGRlZCkuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50VGFyZ2V0XG4gICAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGJ1YmJsaW5nIGV2ZW50cywgdGhpcyBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgZXZlbnQgcGhhc2U6PE9MPlxuICAgICAgICAgKiAgPExJPiBjYXB0dXJlIHBoYXNlOiBzdGFydGluZyBmcm9tIHRoZSB0b3AgcGFyZW50IHRvIHRoZSB0YXJnZXQ8L0xJPlxuICAgICAgICAgKiAgPExJPiBhdCB0YXJnZXQgcGhhc2U6IGN1cnJlbnRseSBiZWluZyBkaXNwYXRjaGVkIGZyb20gdGhlIHRhcmdldDwvTEk+XG4gICAgICAgICAqICA8TEk+IGJ1YmJsaW5nIHBoYXNlOiBmcm9tIHRoZSB0YXJnZXQgdG8gdGhlIHRvcCBwYXJlbnQ8L0xJPlxuICAgICAgICAgKiA8L09MPlxuICAgICAgICAgKiBAcHJvcGVydHkgZXZlbnRQaGFzZVxuICAgICAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudFBoYXNlID0gMDtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBidWJibGVzXG4gICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnViYmxlcyA9ICEhYnViYmxlcztcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQgdmlhXG4gICAgICAgICAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIGlzIHNldCB2aWEgdGhlIEV2ZW50IGNvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbGFibGUgPSAhIWNhbmNlbGFibGU7XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXBvY2ggdGltZSBhdCB3aGljaCB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgdGltZVN0YW1wXG4gICAgICAgICAqIEB0eXBlIE51bWJlclxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVTdGFtcCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgICAqIG9uIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0UHJldmVudGVkXG4gICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBvclxuICAgICAgICAgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBwcm9wYWdhdGlvblN0b3BwZWRcbiAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgICAqIG9uIHRoaXMgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcbiAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgcmVtb3ZlZFxuICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHAgPSBFdmVudC5wcm90b3R5cGU7XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuICAgIC8qKlxuICAgICAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvZGVmYXVsdFByZXZlbnRlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlIGlmIHRoZSBldmVudCBpcyBjYW5jZWxhYmxlLlxuICAgICAqIE1pcnJvcnMgdGhlIERPTSBsZXZlbCAyIGV2ZW50IHN0YW5kYXJkLiBJbiBnZW5lcmFsLCBjYW5jZWxhYmxlIGV2ZW50cyB0aGF0IGhhdmUgYHByZXZlbnREZWZhdWx0KClgIGNhbGxlZCB3aWxsXG4gICAgICogY2FuY2VsIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuICAgICAqIEBtZXRob2QgcHJldmVudERlZmF1bHRcbiAgICAgKiovXG4gICAgcC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0aGlzLmNhbmNlbGFibGUmJnRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG4gICAgICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuICAgICAqIEBtZXRob2Qgc3RvcFByb3BhZ2F0aW9uXG4gICAgICoqL1xuICAgIHAuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG4gICAgICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuICAgICAqIEBtZXRob2Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG4gICAgICoqL1xuICAgIHAuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBhY3RpdmUgbGlzdGVuZXIgdG8gYmUgcmVtb3ZlZCB2aWEgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAqIFxuICAgICAqICAgICAgbXlCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgICAgICAgIC8vIGRvIHN0dWZmLi4uXG4gICAgICogICAgICAgICAgZXZ0LnJlbW92ZSgpOyAvLyByZW1vdmVzIHRoaXMgbGlzdGVuZXIuXG4gICAgICogICAgICB9KTtcbiAgICAgKiBcbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAqKi9cbiAgICBwLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cbiAgICAgKiBAbWV0aG9kIGNsb25lXG4gICAgICogQHJldHVybiB7RXZlbnR9IGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuICAgICAqKi9cbiAgICBwLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtFdmVudH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAqL1xuICAgIHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuICAgICAqKi9cbiAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIltFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIpXVwiO1xuICAgIH07XG5cbiAgICBjcmVhdGVqcy5FdmVudCA9IEV2ZW50O1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEVycm9yRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLyoqXG4gICAgICogQSBnZW5lcmFsIGVycm9yIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LCB0aGF0IGRlc2NyaWJlcyBhbiBlcnJvciB0aGF0IG9jY3VycmVkLCBhcyB3ZWxsIGFzIGFueSBkZXRhaWxzLlxuICAgICAqIEBjbGFzcyBFcnJvckV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFt0aXRsZV0gVGhlIGVycm9yIHRpdGxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBUaGUgZXJyb3IgZGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIEFkZGl0aW9uYWwgZXJyb3IgZGF0YVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVycm9yRXZlbnQodGl0bGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5FdmVudF9jb25zdHJ1Y3RvcihcImVycm9yXCIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2hvcnQgZXJyb3IgdGl0bGUsIHdoaWNoIGluZGljYXRlcyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IG9jY3VycmVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgdGl0bGVcbiAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2ZXJib3NlIGVycm9yIG1lc3NhZ2UsIGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBtZXNzYWdlXG4gICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCBkYXRhIGF0dGFjaGVkIHRvIGFuIGVycm9yLlxuICAgICAgICAgKiBAcHJvcGVydHkgZGF0YVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChFcnJvckV2ZW50LCBjcmVhdGVqcy5FdmVudCk7XG5cbiAgICBwLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgY3JlYXRlanMuRXJyb3JFdmVudCh0aGlzLnRpdGxlLCB0aGlzLm1lc3NhZ2UsIHRoaXMuZGF0YSk7XG4gICAgfTtcblxuICAgIGNyZWF0ZWpzLkVycm9yRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKEVycm9yRXZlbnQsIFwiRXZlbnRcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFdmVudERpc3BhdGNoZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuICAgIC8qKlxuICAgICAqIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBtZXRob2RzIGZvciBtYW5hZ2luZyBxdWV1ZXMgb2YgZXZlbnQgbGlzdGVuZXJzIGFuZCBkaXNwYXRjaGluZyBldmVudHMuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGVpdGhlciBleHRlbmQgRXZlbnREaXNwYXRjaGVyIG9yIG1peCBpdHMgbWV0aG9kcyBpbnRvIGFuIGV4aXN0aW5nIHByb3RvdHlwZSBvciBpbnN0YW5jZSBieSB1c2luZyB0aGVcbiAgICAgKiBFdmVudERpc3BhdGNoZXIge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2luaXRpYWxpemVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuICAgICAqIFxuICAgICAqIFRvZ2V0aGVyIHdpdGggdGhlIENyZWF0ZUpTIEV2ZW50IGNsYXNzLCBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgYW4gZXh0ZW5kZWQgZXZlbnQgbW9kZWwgdGhhdCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBET00gTGV2ZWwgMiBldmVudCBtb2RlbCwgaW5jbHVkaW5nIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGFuZCBkaXNwYXRjaEV2ZW50LiBJdCBzdXBwb3J0c1xuICAgICAqIGJ1YmJsaW5nIC8gY2FwdHVyZSwgcHJldmVudERlZmF1bHQsIHN0b3BQcm9wYWdhdGlvbiwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLCBhbmQgaGFuZGxlRXZlbnQuXG4gICAgICogXG4gICAgICogRXZlbnREaXNwYXRjaGVyIGFsc28gZXhwb3NlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIHdoaWNoIG1ha2VzIGl0IGVhc2llclxuICAgICAqIHRvIGNyZWF0ZSBzY29wZWQgbGlzdGVuZXJzLCBsaXN0ZW5lcnMgdGhhdCBvbmx5IHJ1biBvbmNlLCBhbmQgbGlzdGVuZXJzIHdpdGggYXNzb2NpYXRlZCBhcmJpdHJhcnkgZGF0YS4gVGhlIFxuICAgICAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vZmZcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGlzIG1lcmVseSBhbiBhbGlhcyB0b1xuICAgICAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIFxuICAgICAqIEFub3RoZXIgYWRkaXRpb24gdG8gdGhlIERPTSBMZXZlbCAyIG1vZGVsIGlzIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBtZXRob2QsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbmVycyBmb3IgYWxsIGV2ZW50cywgb3IgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50LiBUaGUgRXZlbnQgb2JqZWN0IGFsc28gXG4gICAgICogaW5jbHVkZXMgYSB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHdoaWNoIHJlbW92ZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lci5cbiAgICAgKlxuICAgICAqIDxoND5FeGFtcGxlPC9oND5cbiAgICAgKiBBZGQgRXZlbnREaXNwYXRjaGVyIGNhcGFiaWxpdGllcyB0byB0aGUgXCJNeUNsYXNzXCIgY2xhc3MuXG4gICAgICpcbiAgICAgKiAgICAgIEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKE15Q2xhc3MucHJvdG90eXBlKTtcbiAgICAgKlxuICAgICAqIEFkZCBhbiBldmVudCAoc2VlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9hZGRFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319KS5cbiAgICAgKlxuICAgICAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50TmFtZVwiLCBoYW5kbGVyTWV0aG9kKTtcbiAgICAgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZXJNZXRob2QoZXZlbnQpIHtcbiAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC50YXJnZXQgKyBcIiBXYXMgQ2xpY2tlZFwiKTtcbiAgICAgKiAgICAgIH1cbiAgICAgKlxuICAgICAqIDxiPk1haW50YWluaW5nIHByb3BlciBzY29wZTwvYj48YnIgLz5cbiAgICAgKiBTY29wZSAoaWUuIFwidGhpc1wiKSBjYW4gYmUgYmUgYSBjaGFsbGVuZ2Ugd2l0aCBldmVudHMuIFVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBtZXRob2QgdG8gc3Vic2NyaWJlIHRvIGV2ZW50cyBzaW1wbGlmaWVzIHRoaXMuXG4gICAgICpcbiAgICAgKiAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyBmYWxzZSwgc2NvcGUgaXMgYW1iaWd1b3VzLlxuICAgICAqICAgICAgfSk7XG4gICAgICogICAgICBcbiAgICAgKiAgICAgIGluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSA9PSB0aGlzKTsgLy8gdHJ1ZSwgXCJvblwiIHVzZXMgZGlzcGF0Y2hlciBzY29wZSBieSBkZWZhdWx0LlxuICAgICAqICAgICAgfSk7XG4gICAgICogXG4gICAgICogSWYgeW91IHdhbnQgdG8gdXNlIGFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZCwgeW91IG1heSB3YW50IHRvIHVzZSBmdW5jdGlvbi5iaW5kKCkgb3IgYSBzaW1pbGFyIHByb3h5IHRvIG1hbmFnZVxuICAgICAqIHNjb3BlLlxuICAgICAqXG4gICAgICogPGI+QnJvd3NlciBzdXBwb3J0PC9iPlxuICAgICAqIFRoZSBldmVudCBtb2RlbCBpbiBDcmVhdGVKUyBjYW4gYmUgdXNlZCBzZXBhcmF0ZWx5IGZyb20gdGhlIHN1aXRlIGluIGFueSBwcm9qZWN0LCBob3dldmVyIHRoZSBpbmhlcml0YW5jZSBtb2RlbFxuICAgICAqIHJlcXVpcmVzIG1vZGVybiBicm93c2VycyAoSUU5KykuXG4gICAgICogICAgICBcbiAgICAgKlxuICAgICAqIEBjbGFzcyBFdmVudERpc3BhdGNoZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiovXG4gICAgZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge1xuICAgIFxuICAgIFxuICAgIC8vIHByaXZhdGUgcHJvcGVydGllczpcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHByb3BlcnR5IF9saXN0ZW5lcnNcbiAgICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgICAqKi9cbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfY2FwdHVyZUxpc3RlbmVyc1xuICAgICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHAgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xuXG4vLyBzdGF0aWMgcHVibGljIG1ldGhvZHM6XG4gICAgLyoqXG4gICAgICogU3RhdGljIGluaXRpYWxpemVyIHRvIG1peCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvIGEgdGFyZ2V0IG9iamVjdCBvciBwcm90b3R5cGUuXG4gICAgICogXG4gICAgICogICAgICBFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7IC8vIGFkZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjbGFzc1xuICAgICAqICAgICAgRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUobXlPYmplY3QpOyAvLyBhZGQgdG8gYSBzcGVjaWZpYyBpbnN0YW5jZVxuICAgICAqIFxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRvIGluamVjdCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvLiBUaGlzIGNhbiBiZSBhbiBpbnN0YW5jZSBvciBhXG4gICAgICogcHJvdG90eXBlLlxuICAgICAqKi9cbiAgICBFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lciA9IHAuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgdGFyZ2V0Lm9uID0gcC5vbjtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSB0YXJnZXQub2ZmID0gIHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gcC5yZW1vdmVBbGxFdmVudExpc3RlbmVycztcbiAgICAgICAgdGFyZ2V0Lmhhc0V2ZW50TGlzdGVuZXIgPSBwLmhhc0V2ZW50TGlzdGVuZXI7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50ID0gcC5kaXNwYXRjaEV2ZW50O1xuICAgICAgICB0YXJnZXQuX2Rpc3BhdGNoRXZlbnQgPSBwLl9kaXNwYXRjaEV2ZW50O1xuICAgICAgICB0YXJnZXQud2lsbFRyaWdnZXIgPSBwLndpbGxUcmlnZ2VyO1xuICAgIH07XG4gICAgXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci4gTm90ZSB0aGF0IGFkZGluZyBtdWx0aXBsZSBsaXN0ZW5lcnMgdG8gdGhlIHNhbWUgZnVuY3Rpb24gd2lsbCByZXN1bHQgaW5cbiAgICAgKiBtdWx0aXBsZSBjYWxsYmFja3MgZ2V0dGluZyBmaXJlZC5cbiAgICAgKlxuICAgICAqIDxoND5FeGFtcGxlPC9oND5cbiAgICAgKlxuICAgICAqICAgICAgZGlzcGxheU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuICAgICAqICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAgKiAgICAgICAgIC8vIENsaWNrIGhhcHBlbmVkLlxuICAgICAqICAgICAgfVxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICAgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb24gfCBPYmplY3R9IFJldHVybnMgdGhlIGxpc3RlbmVyIGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuICAgICAqKi9cbiAgICBwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzO1xuICAgICAgICBpZiAodXNlQ2FwdHVyZSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnN8fHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzfHx7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyID0gbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgICBpZiAoYXJyKSB7IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cbiAgICAgICAgYXJyID0gbGlzdGVuZXJzW3R5cGVdOyAvLyByZW1vdmUgbWF5IGhhdmUgZGVsZXRlZCB0aGUgYXJyYXlcbiAgICAgICAgaWYgKCFhcnIpIHsgbGlzdGVuZXJzW3R5cGVdID0gW2xpc3RlbmVyXTsgIH1cbiAgICAgICAgZWxzZSB7IGFyci5wdXNoKGxpc3RlbmVyKTsgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBBIHNob3J0Y3V0IG1ldGhvZCBmb3IgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lciB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBzcGVjaWZ5IGFuIGV4ZWN1dGlvbiBzY29wZSwgaGF2ZSBhIGxpc3RlbmVyXG4gICAgICogb25seSBydW4gb25jZSwgYXNzb2NpYXRlIGFyYml0cmFyeSBkYXRhIHdpdGggdGhlIGxpc3RlbmVyLCBhbmQgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICAgKiBcbiAgICAgKiBUaGlzIG1ldGhvZCB3b3JrcyBieSBjcmVhdGluZyBhbiBhbm9ueW1vdXMgd3JhcHBlciBmdW5jdGlvbiBhbmQgc3Vic2NyaWJpbmcgaXQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuICAgICAqIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIGlzIHJldHVybmVkIGZvciB1c2Ugd2l0aCBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgKG9yIGBvZmZgKS5cbiAgICAgKiBcbiAgICAgKiA8Yj5JTVBPUlRBTlQ6PC9iPiBUbyByZW1vdmUgYSBsaXN0ZW5lciBhZGRlZCB3aXRoIGBvbmAsIHlvdSBtdXN0IHBhc3MgaW4gdGhlIHJldHVybmVkIHdyYXBwZXIgZnVuY3Rpb24gYXMgdGhlIGxpc3RlbmVyLCBvciB1c2VcbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0uIExpa2V3aXNlLCBlYWNoIHRpbWUgeW91IGNhbGwgYG9uYCBhIE5FVyB3cmFwcGVyIGZ1bmN0aW9uIGlzIHN1YnNjcmliZWQsIHNvIG11bHRpcGxlIGNhbGxzXG4gICAgICogdG8gYG9uYCB3aXRoIHRoZSBzYW1lIHBhcmFtcyB3aWxsIGNyZWF0ZSBtdWx0aXBsZSBsaXN0ZW5lcnMuXG4gICAgICogXG4gICAgICogPGg0PkV4YW1wbGU8L2g0PlxuICAgICAqIFxuICAgICAqICAgICAgdmFyIGxpc3RlbmVyID0gbXlCdG4ub24oXCJjbGlja1wiLCBoYW5kbGVDbGljaywgbnVsbCwgZmFsc2UsIHtjb3VudDozfSk7XG4gICAgICogICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldnQsIGRhdGEpIHtcbiAgICAgKiAgICAgICAgICBkYXRhLmNvdW50IC09IDE7XG4gICAgICogICAgICAgICAgY29uc29sZS5sb2codGhpcyA9PSBteUJ0bik7IC8vIHRydWUgLSBzY29wZSBkZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlclxuICAgICAqICAgICAgICAgIGlmIChkYXRhLmNvdW50ID09IDApIHtcbiAgICAgKiAgICAgICAgICAgICAgYWxlcnQoXCJjbGlja2VkIDMgdGltZXMhXCIpO1xuICAgICAqICAgICAgICAgICAgICBteUJ0bi5vZmYoXCJjbGlja1wiLCBsaXN0ZW5lcik7XG4gICAgICogICAgICAgICAgICAgIC8vIGFsdGVybmF0ZWx5OiBldnQucmVtb3ZlKCk7XG4gICAgICogICAgICAgICAgfVxuICAgICAqICAgICAgfVxuICAgICAqIFxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAgICAqIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIFRoZSBzY29wZSB0byBleGVjdXRlIHRoZSBsaXN0ZW5lciBpbi4gRGVmYXVsdHMgdG8gdGhlIGRpc3BhdGNoZXIvY3VycmVudFRhcmdldCBmb3IgZnVuY3Rpb24gbGlzdGVuZXJzLCBhbmQgdG8gdGhlIGxpc3RlbmVyIGl0c2VsZiBmb3Igb2JqZWN0IGxpc3RlbmVycyAoaWUuIHVzaW5nIGhhbmRsZUV2ZW50KS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBJZiB0cnVlLCB0aGUgbGlzdGVuZXIgd2lsbCByZW1vdmUgaXRzZWxmIGFmdGVyIHRoZSBmaXJzdCB0aW1lIGl0IGlzIHRyaWdnZXJlZC5cbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXSBBcmJpdHJhcnkgZGF0YSB0aGF0IHdpbGwgYmUgaW5jbHVkZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgd2hlbiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmU9ZmFsc2VdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYW5vbnltb3VzIGZ1bmN0aW9uIHRoYXQgd2FzIGNyZWF0ZWQgYW5kIGFzc2lnbmVkIGFzIHRoZSBsaXN0ZW5lci4gVGhpcyBpcyBuZWVkZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBsYXRlciB1c2luZyAucmVtb3ZlRXZlbnRMaXN0ZW5lci5cbiAgICAgKiovXG4gICAgcC5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBzY29wZSwgb25jZSwgZGF0YSwgdXNlQ2FwdHVyZSkge1xuICAgICAgICBpZiAobGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcbiAgICAgICAgICAgIHNjb3BlID0gc2NvcGV8fGxpc3RlbmVyO1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5oYW5kbGVFdmVudDtcbiAgICAgICAgfVxuICAgICAgICBzY29wZSA9IHNjb3BlfHx0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoc2NvcGUsIGV2dCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgb25jZSYmZXZ0LnJlbW92ZSgpO1xuICAgICAgICAgICAgfSwgdXNlQ2FwdHVyZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci5cbiAgICAgKlxuICAgICAqIDxiPkltcG9ydGFudCBOb3RlOjwvYj4gdGhhdCB5b3UgbXVzdCBwYXNzIHRoZSBleGFjdCBmdW5jdGlvbiByZWZlcmVuY2UgdXNlZCB3aGVuIHRoZSBldmVudCB3YXMgYWRkZWQuIElmIGEgcHJveHlcbiAgICAgKiBmdW5jdGlvbiwgb3IgZnVuY3Rpb24gY2xvc3VyZSBpcyB1c2VkIGFzIHRoZSBjYWxsYmFjaywgdGhlIHByb3h5L2Nsb3N1cmUgcmVmZXJlbmNlIG11c3QgYmUgdXNlZCAtIGEgbmV3IHByb3h5IG9yXG4gICAgICogY2xvc3VyZSB3aWxsIG5vdCB3b3JrLlxuICAgICAqXG4gICAgICogPGg0PkV4YW1wbGU8L2g0PlxuICAgICAqXG4gICAgICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxuICAgICAqKi9cbiAgICBwLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdXNlQ2FwdHVyZSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICghbGlzdGVuZXJzKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgYXJyID0gbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgICBpZiAoIWFycikgeyByZXR1cm47IH1cbiAgICAgICAgZm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobD09MSkgeyBkZWxldGUobGlzdGVuZXJzW3R5cGVdKTsgfSAvLyBhbGxvd3MgZm9yIGZhc3RlciBjaGVja3MuXG4gICAgICAgICAgICAgICAgZWxzZSB7IGFyci5zcGxpY2UoaSwxKTsgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBBIHNob3J0Y3V0IHRvIHRoZSByZW1vdmVFdmVudExpc3RlbmVyIG1ldGhvZCwgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdmFsdWUuIFRoaXMgaXMgYSBjb21wYW5pb24gdG8gdGhlXG4gICAgICogLm9uIG1ldGhvZC5cbiAgICAgKiBcbiAgICAgKiA8Yj5JTVBPUlRBTlQ6PC9iPiBUbyByZW1vdmUgYSBsaXN0ZW5lciBhZGRlZCB3aXRoIGBvbmAsIHlvdSBtdXN0IHBhc3MgaW4gdGhlIHJldHVybmVkIHdyYXBwZXIgZnVuY3Rpb24gYXMgdGhlIGxpc3RlbmVyLiBTZWUgXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxuICAgICAqKi9cbiAgICBwLm9mZiA9IHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLCBvciBhbGwgbGlzdGVuZXJzIG9mIGFsbCB0eXBlcy5cbiAgICAgKlxuICAgICAqIDxoND5FeGFtcGxlPC9oND5cbiAgICAgKlxuICAgICAqICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgKlxuICAgICAqICAgICAgLy8gUmVtb3ZlIGFsbCBjbGljayBsaXN0ZW5lcnNcbiAgICAgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJjbGlja1wiKTtcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuIElmIG9taXR0ZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIGFsbCB0eXBlcyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICoqL1xuICAgIHAucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIGlmICghdHlwZSkgeyB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSk7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jYXB0dXJlTGlzdGVuZXJzKSB7IGRlbGV0ZSh0aGlzLl9jYXB0dXJlTGlzdGVuZXJzW3R5cGVdKTsgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgdGhlIHNwZWNpZmllZCBldmVudCB0byBhbGwgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogPGg0PkV4YW1wbGU8L2g0PlxuICAgICAqXG4gICAgICogICAgICAvLyBVc2UgYSBzdHJpbmcgZXZlbnRcbiAgICAgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuICAgICAqXG4gICAgICogICAgICAvLyBVc2UgYW4gRXZlbnQgaW5zdGFuY2VcbiAgICAgKiAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInByb2dyZXNzXCIpO1xuICAgICAqICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nIHwgRXZlbnR9IGV2ZW50T2JqIEFuIG9iamVjdCB3aXRoIGEgXCJ0eXBlXCIgcHJvcGVydHksIG9yIGEgc3RyaW5nIHR5cGUuXG4gICAgICogV2hpbGUgYSBnZW5lcmljIG9iamVjdCB3aWxsIHdvcmssIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhIENyZWF0ZUpTIEV2ZW50IGluc3RhbmNlLiBJZiBhIHN0cmluZyBpcyB1c2VkLFxuICAgICAqIGRpc3BhdGNoRXZlbnQgd2lsbCBjb25zdHJ1Y3QgYW4gRXZlbnQgaW5zdGFuY2UgaWYgbmVjZXNzYXJ5IHdpdGggdGhlIHNwZWNpZmllZCB0eXBlLiBUaGlzIGxhdHRlciBhcHByb2FjaCBjYW5cbiAgICAgKiBiZSB1c2VkIHRvIGF2b2lkIGV2ZW50IG9iamVjdCBpbnN0YW50aWF0aW9uIGZvciBub24tYnViYmxpbmcgZXZlbnRzIHRoYXQgbWF5IG5vdCBoYXZlIGFueSBsaXN0ZW5lcnMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlc10gU3BlY2lmaWVzIHRoZSBgYnViYmxlc2AgdmFsdWUgd2hlbiBhIHN0cmluZyB3YXMgcGFzc2VkIHRvIGV2ZW50T2JqLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbmNlbGFibGVdIFNwZWNpZmllcyB0aGUgYGNhbmNlbGFibGVgIHZhbHVlIHdoZW4gYSBzdHJpbmcgd2FzIHBhc3NlZCB0byBldmVudE9iai5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIGBwcmV2ZW50RGVmYXVsdCgpYCB3YXMgY2FsbGVkIG9uIGEgY2FuY2VsYWJsZSBldmVudCwgdHJ1ZSBvdGhlcndpc2UuXG4gICAgICoqL1xuICAgIHAuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRPYmogPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gc2tpcCBldmVyeXRoaW5nIGlmIHRoZXJlJ3Mgbm8gbGlzdGVuZXJzIGFuZCBpdCBkb2Vzbid0IGJ1YmJsZTpcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgICAgICBpZiAoIWJ1YmJsZXMgJiYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVyc1tldmVudE9ial0pKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICBldmVudE9iaiA9IG5ldyBjcmVhdGVqcy5FdmVudChldmVudE9iaiwgYnViYmxlcywgY2FuY2VsYWJsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRPYmoudGFyZ2V0ICYmIGV2ZW50T2JqLmNsb25lKSB7XG4gICAgICAgICAgICAvLyByZWRpc3BhdGNoaW5nIGFuIGFjdGl2ZSBldmVudCBvYmplY3QsIHNvIGNsb25lIGl0OlxuICAgICAgICAgICAgZXZlbnRPYmogPSBldmVudE9iai5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPOiBpdCB3b3VsZCBiZSBuaWNlIHRvIGVsaW1pbmF0ZSB0aGlzLiBNYXliZSBpbiBmYXZvdXIgb2YgZXZ0T2JqIGluc3RhbmNlb2YgRXZlbnQ/IE9yICEhZXZ0T2JqLmNyZWF0ZUV2ZW50XG4gICAgICAgIHRyeSB7IGV2ZW50T2JqLnRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9IC8vIHRyeS9jYXRjaCBhbGxvd3MgcmVkaXNwYXRjaGluZyBvZiBuYXRpdmUgZXZlbnRzXG5cbiAgICAgICAgaWYgKCFldmVudE9iai5idWJibGVzIHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdG9wPXRoaXMsIGxpc3Q9W3RvcF07XG4gICAgICAgICAgICB3aGlsZSAodG9wLnBhcmVudCkgeyBsaXN0LnB1c2godG9wID0gdG9wLnBhcmVudCk7IH1cbiAgICAgICAgICAgIHZhciBpLCBsPWxpc3QubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBjYXB0dXJlICYgYXRUYXJnZXRcbiAgICAgICAgICAgIGZvciAoaT1sLTE7IGk+PTAgJiYgIWV2ZW50T2JqLnByb3BhZ2F0aW9uU3RvcHBlZDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMSsoaT09MCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnViYmxpbmdcbiAgICAgICAgICAgIGZvciAoaT0xOyBpPGwgJiYgIWV2ZW50T2JqLnByb3BhZ2F0aW9uU3RvcHBlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFldmVudE9iai5kZWZhdWx0UHJldmVudGVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICAgKiBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICoqL1xuICAgIHAuaGFzRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycywgY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnM7XG4gICAgICAgIHJldHVybiAhISgobGlzdGVuZXJzICYmIGxpc3RlbmVyc1t0eXBlXSkgfHwgKGNhcHR1cmVMaXN0ZW5lcnMgJiYgY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSkpO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgb24gdGhpcyBvYmplY3Qgb3IgYW55IG9mIGl0c1xuICAgICAqIGFuY2VzdG9ycyAocGFyZW50LCBwYXJlbnQncyBwYXJlbnQsIGV0YykuIEEgcmV0dXJuIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgaWYgYSBidWJibGluZyBldmVudCBvZiB0aGVcbiAgICAgKiBzcGVjaWZpZWQgdHlwZSBpcyBkaXNwYXRjaGVkIGZyb20gdGhpcyBvYmplY3QsIGl0IHdpbGwgdHJpZ2dlciBhdCBsZWFzdCBvbmUgbGlzdGVuZXIuXG4gICAgICogXG4gICAgICogVGhpcyBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9oYXNFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LCBidXQgaXQgc2VhcmNoZXMgdGhlIGVudGlyZVxuICAgICAqIGV2ZW50IGZsb3cgZm9yIGEgbGlzdGVuZXIsIG5vdCBqdXN0IHRoaXMgb2JqZWN0LlxuICAgICAqIEBtZXRob2Qgd2lsbFRyaWdnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiovXG4gICAgcC53aWxsVHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgICB3aGlsZSAobykge1xuICAgICAgICAgICAgaWYgKG8uaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgbyA9IG8ucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuICAgICAqKi9cbiAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIltFdmVudERpc3BhdGNoZXJdXCI7XG4gICAgfTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBfZGlzcGF0Y2hFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgRXZlbnR9IGV2ZW50T2JqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50UGhhc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICoqL1xuICAgIHAuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgZXZlbnRQaGFzZSkge1xuICAgICAgICB2YXIgbCwgYXJyLCBsaXN0ZW5lcnMgPSAoZXZlbnRQaGFzZSA8PSAyKSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmIChldmVudE9iaiAmJiBsaXN0ZW5lcnMgJiYgKGFyciA9IGxpc3RlbmVyc1tldmVudE9iai50eXBlXSkgJiYgKGw9YXJyLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRyeSB7IGV2ZW50T2JqLmN1cnJlbnRUYXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgdHJ5IHsgZXZlbnRPYmouZXZlbnRQaGFzZSA9IGV2ZW50UGhhc2V8MDsgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIGV2ZW50T2JqLnJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXJyID0gYXJyLnNsaWNlKCk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGl0ZW1zIGJlaW5nIHJlbW92ZWQgb3IgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaFxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGwgJiYgIWV2ZW50T2JqLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgaWYgKG8uaGFuZGxlRXZlbnQpIHsgby5oYW5kbGVFdmVudChldmVudE9iaik7IH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgbyhldmVudE9iaik7IH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRPYmoucmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZihldmVudE9iai50eXBlLCBvLCBldmVudFBoYXNlPT0xKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRQaGFzZSA9PT0gMikgeyB0aGlzLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAyLjEpOyB9XG4gICAgfTtcblxuXG4gICAgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFByb2dyZXNzRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBjb25zdHJ1Y3RvclxuICAgIC8qKlxuICAgICAqIEEgQ3JlYXRlSlMge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBkaXNwYXRjaGVkIHdoZW4gcHJvZ3Jlc3MgY2hhbmdlcy5cbiAgICAgKiBAY2xhc3MgUHJvZ3Jlc3NFdmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsb2FkZWQgVGhlIGFtb3VudCB0aGF0IGhhcyBiZWVuIGxvYWRlZC4gVGhpcyBjYW4gYmUgYW55IG51bWJlciByZWxhdGl2ZSB0byB0aGUgdG90YWwuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0b3RhbD0xXSBUaGUgdG90YWwgYW1vdW50IHRoYXQgd2lsbCBsb2FkLiBUaGlzIHdpbGwgZGVmYXVsdCB0byAxLCBzbyBpZiB0aGUgYGxvYWRlZGAgdmFsdWUgaXNcbiAgICAgKiBhIHBlcmNlbnRhZ2UgKGJldHdlZW4gMCBhbmQgMSksIGl0IGNhbiBiZSBvbWl0dGVkLlxuICAgICAqIEB0b2RvIENvbnNpZGVyIGhhdmluZyB0aGlzIGV2ZW50IGJlIGEgXCJmaWxlcHJvZ3Jlc3NcIiBldmVudCBhcyB3ZWxsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvZ3Jlc3NFdmVudChsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgIHRoaXMuRXZlbnRfY29uc3RydWN0b3IoXCJwcm9ncmVzc1wiKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCB0aGF0IGhhcyBiZWVuIGxvYWRlZCAob3V0IG9mIGEgdG90YWwgYW1vdW50KVxuICAgICAgICAgKiBAcHJvcGVydHkgbG9hZGVkXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvYWRlZCA9IGxvYWRlZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvdGFsIFwic2l6ZVwiIG9mIHRoZSBsb2FkLlxuICAgICAgICAgKiBAcHJvcGVydHkgdG90YWxcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b3RhbCA9ICh0b3RhbCA9PSBudWxsKSA/IDEgOiB0b3RhbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlcmNlbnRhZ2UgKG91dCBvZiAxKSB0aGF0IHRoZSBsb2FkIGhhcyBiZWVuIGNvbXBsZXRlZC4gVGhpcyBpcyBjYWxjdWxhdGVkIHVzaW5nIGBsb2FkZWQvdG90YWxgLlxuICAgICAgICAgKiBAcHJvcGVydHkgcHJvZ3Jlc3NcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9ICh0b3RhbCA9PSAwKSA/IDAgOiB0aGlzLmxvYWRlZCAvIHRoaXMudG90YWw7XG4gICAgfTtcblxuICAgIHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFByb2dyZXNzRXZlbnQsIGNyZWF0ZWpzLkV2ZW50KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgUHJvZ3Jlc3NFdmVudCBpbnN0YW5jZS5cbiAgICAgKiBAbWV0aG9kIGNsb25lXG4gICAgICogQHJldHVybiB7UHJvZ3Jlc3NFdmVudH0gYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG4gICAgICoqL1xuICAgIHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KHRoaXMubG9hZGVkLCB0aGlzLnRvdGFsKTtcbiAgICB9O1xuXG4gICAgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudCA9IGNyZWF0ZWpzLnByb21vdGUoUHJvZ3Jlc3NFdmVudCwgXCJFdmVudFwiKTtcblxufSh3aW5kb3cpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGpzb24zLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFbGVtZW50cy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZHMgZm9yIGNyZWF0aW5nIHZhcmlvdXMgZWxlbWVudHMgdXNlZCBieSBQcmVsYW9kSlMuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgRG9tVXRpbHNcbiAgICAgKi9cbiAgICB2YXIgcyA9IHt9O1xuXG4gICAgcy5hID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzLmVsKFwiYVwiKTtcbiAgICB9XG5cbiAgICBzLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcy5lbChcInN2Z1wiKTtcbiAgICB9XG5cbiAgICBzLm9iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcy5lbChcIm9iamVjdFwiKTtcbiAgICB9XG5cbiAgICBzLmltYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzLmVsKFwiaW1hZ2VcIik7XG4gICAgfVxuXG4gICAgcy5pbWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHMuZWwoXCJpbWdcIik7XG4gICAgfVxuXG4gICAgcy5zdHlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcy5lbChcInN0eWxlXCIpO1xuICAgIH1cblxuICAgIHMubGluayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcy5lbChcImxpbmtcIik7XG4gICAgfVxuXG4gICAgcy5zY3JpcHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHMuZWwoXCJzY3JpcHRcIik7XG4gICAgfVxuXG4gICAgcy5hdWRpbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcy5lbChcImF1ZGlvXCIpO1xuICAgIH1cblxuICAgIHMudmlkZW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHMuZWwoXCJ2aWRlb1wiKTtcbiAgICB9XG5cbiAgICBzLnRleHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgIH1cblxuICAgIHMuZWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgIH1cblxuICAgIGNyZWF0ZWpzLkVsZW1lbnRzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFVSTFV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogVXRpbGl0aWVzIHRoYXQgYXNzaXN0IHdpdGggcGFyc2luZyBsb2FkIGl0ZW1zLCBhbmQgZGV0ZXJtaW5pbmcgZmlsZSB0eXBlcywgZXRjLlxuICAgICAqIEBjbGFzcyBVUkxVdGlsc1xuICAgICAqL1xuICAgIHZhciBzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgUmVndWxhciBFeHByZXNzaW9uIHVzZWQgdG8gdGVzdCBmaWxlIFVSTFMgZm9yIGFuIGFic29sdXRlIHBhdGguXG4gICAgICogQHByb3BlcnR5IEFCU09MVVRFX1BBVEhcbiAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLkFCU09MVVRFX1BBVFQgPSAvXig/Olxcdys6KT9cXC97Mn0vaTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdXNlZCB0byB0ZXN0IGZpbGUgVVJMUyBmb3IgYSByZWxhdGl2ZSBwYXRoLlxuICAgICAqIEBwcm9wZXJ0eSBSRUxBVElWRV9QQVRIXG4gICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcy5SRUxBVElWRV9QQVRUID0gKC9eWy4vXSo/XFwvL2kpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB1c2VkIHRvIHRlc3QgZmlsZSBVUkxTIGZvciBhbiBleHRlbnNpb24uIE5vdGUgdGhhdCBVUklzIG11c3QgYWxyZWFkeSBoYXZlIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgKiByZW1vdmVkLlxuICAgICAqIEBwcm9wZXJ0eSBFWFRFTlNJT05fUEFUVFxuICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHMuRVhURU5TSU9OX1BBVFQgPSAvXFwvP1teL10rXFwuKFxcd3sxLDV9KSQvaTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgZmlsZSBwYXRoIHRvIGRldGVybWluZSB0aGUgaW5mb3JtYXRpb24gd2UgbmVlZCB0byB3b3JrIHdpdGggaXQuIEN1cnJlbnRseSwgUHJlbG9hZEpTIG5lZWRzIHRvIGtub3c6XG4gICAgICogPHVsPlxuICAgICAqICAgICA8bGk+SWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIEFic29sdXRlIHBhdGhzIHN0YXJ0IHdpdGggYSBwcm90b2NvbCAoc3VjaCBhcyBgaHR0cDovL2AsIGBmaWxlOi8vYCwgb3JcbiAgICAgKiAgICAgYC8vbmV0d29ya1BhdGhgKTwvbGk+XG4gICAgICogICAgIDxsaT5JZiB0aGUgcGF0aCBpcyByZWxhdGl2ZS4gUmVsYXRpdmUgcGF0aHMgc3RhcnQgd2l0aCBgLi4vYCBvciBgL3BhdGhgIChvciBzaW1pbGFyKTwvbGk+XG4gICAgICogICAgIDxsaT5UaGUgZmlsZSBleHRlbnNpb24uIFRoaXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgZmlsZW5hbWUgd2l0aCBhbiBleHRlbnNpb24uIFF1ZXJ5IHN0cmluZ3MgYXJlIGRyb3BwZWQsIGFuZFxuICAgICAqICAgICB0aGUgZmlsZSBwYXRoIGlzIGV4cGVjdGVkIHRvIGZvbGxvdyB0aGUgZm9ybWF0IGBuYW1lLmV4dGAuPC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqXG4gICAgICogQG1ldGhvZCBwYXJzZVVSSVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHJldHVybnMge09iamVjdH0gQW4gT2JqZWN0IHdpdGggYW4gYGFic29sdXRlYCBhbmQgYHJlbGF0aXZlYCBCb29sZWFuIHZhbHVlcyxcbiAgICAgKiAgdGhlIHBpZWNlcyBvZiB0aGUgcGF0aCAocHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0LCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBob3N0KVxuICAgICAqICBhcyB3ZWxsIGFzIGFuIG9wdGlvbmFsICdleHRlbnNpb25gIHByb3BlcnR5LCB3aGljaCBpcyB0aGUgbG93ZXJjYXNlIGV4dGVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLnBhcnNlVVJJID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICBhYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICByZWxhdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBwcm90b2NvbDogbnVsbCxcbiAgICAgICAgICAgIGhvc3RuYW1lOiBudWxsLFxuICAgICAgICAgICAgcG9ydDogbnVsbCxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBudWxsLFxuICAgICAgICAgICAgc2VhcmNoOiBudWxsLFxuICAgICAgICAgICAgaGFzaDogbnVsbCxcbiAgICAgICAgICAgIGhvc3Q6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7IHJldHVybiBpbmZvOyB9XG5cbiAgICAgICAgLy8gSW5qZWN0IHRoZSBwYXRoIHBhcnRzLlxuICAgICAgICB2YXIgcGFyc2VyID0gY3JlYXRlanMuRWxlbWVudHMuYSgpO1xuICAgICAgICBwYXJzZXIuaHJlZiA9IHBhdGg7XG5cbiAgICAgICAgZm9yICh2YXIgbiBpbiBpbmZvKSB7XG4gICAgICAgICAgICBpZiAobiBpbiBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICBpbmZvW25dID0gcGFyc2VyW25dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJvcCB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICAgIHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcbiAgICAgICAgaWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHF1ZXJ5SW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWJzb2x1dGVcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAocy5BQlNPTFVURV9QQVRULnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgIGluZm8uYWJzb2x1dGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBSZWxhdGl2ZVxuICAgICAgICB9IGVsc2UgaWYgKHMuUkVMQVRJVkVfUEFUVC50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICBpbmZvLnJlbGF0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dGVuc2lvblxuICAgICAgICBpZiAobWF0Y2ggPSBwYXRoLm1hdGNoKHMuRVhURU5TSU9OX1BBVFQpKSB7XG4gICAgICAgICAgICBpbmZvLmV4dGVuc2lvbiA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhbiBvYmplY3QgaW50byBhIHF1ZXJ5IHN0cmluZyBmb3IgZWl0aGVyIGEgUE9TVCBvciBHRVQgcmVxdWVzdC5cbiAgICAgKiBAbWV0aG9kIGZvcm1hdFF1ZXJ5U3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydCB0byBhIHF1ZXJ5IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcXVlcnldIEV4aXN0aW5nIG5hbWUvdmFsdWUgcGFpcnMgdG8gYXBwZW5kIG9uIHRvIHRoaXMgcXVlcnkuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHMuZm9ybWF0UXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAoZGF0YSwgcXVlcnkpIHtcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3Qgc3BlY2lmeSBkYXRhLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgIGZvciAodmFyIG4gaW4gZGF0YSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gobiArIFwiPVwiICsgZXNjYXBlKGRhdGFbbl0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcy5jb25jYXQocXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMuam9pbihcIiZcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgdXRpbGl0eSBtZXRob2QgdGhhdCBidWlsZHMgYSBmaWxlIHBhdGggdXNpbmcgYSBzb3VyY2UgYW5kIGEgZGF0YSBvYmplY3QsIGFuZCBmb3JtYXRzIGl0IGludG8gYSBuZXcgcGF0aC5cbiAgICAgKiBAbWV0aG9kIGJ1aWxkVVJJXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIHBhdGggdG8gYWRkIHZhbHVlcyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIE9iamVjdCB1c2VkIHRvIGFwcGVuZCB2YWx1ZXMgdG8gdGhpcyByZXF1ZXN0IGFzIGEgcXVlcnkgc3RyaW5nLiBFeGlzdGluZyBwYXJhbWV0ZXJzIG9uIHRoZVxuICAgICAqIHBhdGggd2lsbCBiZSBwcmVzZXJ2ZWQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBmb3JtYXR0ZWQgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIHBhdGggYW5kIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXJzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmJ1aWxkVVJJID0gZnVuY3Rpb24gKHNyYywgZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHF1ZXJ5ID0gW107XG4gICAgICAgIHZhciBpZHggPSBzcmMuaW5kZXhPZihcIj9cIik7XG5cbiAgICAgICAgaWYgKGlkeCAhPSAtMSkge1xuICAgICAgICAgICAgdmFyIHEgPSBzcmMuc2xpY2UoaWR4ICsgMSk7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmNvbmNhdChxLnNwbGl0KFwiJlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWR4ICE9IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLnNsaWNlKDAsIGlkeCkgKyBcIj9cIiArIHRoaXMuZm9ybWF0UXVlcnlTdHJpbmcoZGF0YSwgcXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYyArIFwiP1wiICsgdGhpcy5mb3JtYXRRdWVyeVN0cmluZyhkYXRhLCBxdWVyeSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBpc0Nyb3NzRG9tYWluXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gQSBsb2FkIGl0ZW0gd2l0aCBhIGBzcmNgIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBsb2FkIGl0ZW0gaXMgbG9hZGluZyBmcm9tIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmlzQ3Jvc3NEb21haW4gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gY3JlYXRlanMuRWxlbWVudHMuYSgpO1xuICAgICAgICB0YXJnZXQuaHJlZiA9IGl0ZW0uc3JjO1xuXG4gICAgICAgIHZhciBob3N0ID0gY3JlYXRlanMuRWxlbWVudHMuYSgpO1xuICAgICAgICBob3N0LmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4gICAgICAgIHZhciBjcm9zc2RvbWFpbiA9ICh0YXJnZXQuaG9zdG5hbWUgIT0gXCJcIikgJiZcbiAgICAgICAgICAgICh0YXJnZXQucG9ydCAhPSBob3N0LnBvcnQgfHxcbiAgICAgICAgICAgIHRhcmdldC5wcm90b2NvbCAhPSBob3N0LnByb3RvY29sIHx8XG4gICAgICAgICAgICB0YXJnZXQuaG9zdG5hbWUgIT0gaG9zdC5ob3N0bmFtZSk7XG4gICAgICAgIHJldHVybiBjcm9zc2RvbWFpbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBpc0xvY2FsXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gQSBsb2FkIGl0ZW0gd2l0aCBhIGBzcmNgIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGxvYWQgaXRlbSBpcyBsb2FkaW5nIGZyb20gdGhlIFwiZmlsZTpcIiBwcm90b2NvbC4gQXNzdW1lIHRoYXQgdGhlIGhvc3QgbXVzdCBiZSBsb2NhbCBhc1xuICAgICAqIHdlbGwuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHMuaXNMb2NhbCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBjcmVhdGVqcy5FbGVtZW50cy5hKCk7XG4gICAgICAgIHRhcmdldC5ocmVmID0gaXRlbS5zcmM7XG4gICAgICAgIHJldHVybiB0YXJnZXQuaG9zdG5hbWUgPT0gXCJcIiAmJiB0YXJnZXQucHJvdG9jb2wgPT0gXCJmaWxlOlwiO1xuICAgIH07XG5cbiAgICBjcmVhdGVqcy5VUkxVdGlscyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEb21VdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEEgZmV3IHV0aWxpdGllcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZG9tLlxuICAgICAqIEBjbGFzcyBEb21VdGlsc1xuICAgICAqL1xuICAgIHZhciBzID0ge1xuICAgICAgICBjb250YWluZXI6IG51bGxcbiAgICB9O1xuXG4gICAgcy5hcHBlbmRUb0hlYWQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcy5nZXRIZWFkKCkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cblxuICAgIHMuYXBwZW5kVG9Cb2R5ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChzLmNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBzLmNvbnRhaW5lci5pZCA9IFwicHJlbG9hZGpzLWNvbnRhaW5lclwiO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gcy5jb250YWluZXIuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgc3R5bGUud2lkdGggPSBzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIjEwcHhcIjtcbiAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLm1zVHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUub1RyYW5zZm9ybSA9IFwidHJhbnNsYXRlKC0xMHB4LCAtMTBweClcIjsgLy9MTTogTm90IHdvcmtpbmdcbiAgICAgICAgICAgIHMuZ2V0Qm9keSgpLmFwcGVuZENoaWxkKHMuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuXG4gICAgcy5nZXRIZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gICAgfVxuXG4gICAgcy5nZXRCb2R5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF07XG4gICAgfVxuXG4gICAgcy5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGlmIChlbC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGVsLnBhcmVudC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTEltYWdlRWxlbWVudFxuICAgICAqIEBtZXRob2QgaXNJbWFnZVRhZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHMuaXNJbWFnZVRhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTEF1ZGlvRWxlbWVudFxuICAgICAqIEBtZXRob2QgaXNBdWRpb1RhZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHMuaXNBdWRpb1RhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKHdpbmRvdy5IVE1MQXVkaW9FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEhUTUxBdWRpb0VsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgaXRlbSBpcyBhIHZhbGlkIEhUTUxWaWRlb0VsZW1lbnRcbiAgICAgKiBAbWV0aG9kIGlzVmlkZW9UYWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmlzVmlkZW9UYWcgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmICh3aW5kb3cuSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNyZWF0ZWpzLkRvbVV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERhdGFVdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEEgZmV3IGRhdGEgdXRpbGl0aWVzIGZvciBmb3JtYXR0aW5nIGRpZmZlcmVudCBkYXRhIHR5cGVzLlxuICAgICAqIEBjbGFzcyBEYXRhVXRpbHNcbiAgICAgKi9cbiAgICB2YXIgcyA9IHt9O1xuXG4gICAgLy8gc3RhdGljIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBQYXJzZSBYTUwgdXNpbmcgdGhlIERPTS4gVGhpcyBpcyByZXF1aXJlZCB3aGVuIHByZWxvYWRpbmcgWE1MIG9yIFNWRy5cbiAgICAgKiBAbWV0aG9kIHBhcnNlWE1MXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHJhdyB0ZXh0IG9yIFhNTCB0aGF0IGlzIGxvYWRlZCBieSBYSFIuXG4gICAgICogQHJldHVybiB7WE1MfSBBbiBYTUwgZG9jdW1lbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcy5wYXJzZVhNTCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciB4bWwgPSBudWxsO1xuICAgICAgICAvLyBDb2Nvb25KUyBkb2VzIG5vdCBzdXBwb3J0IFhNTCBwYXJzaW5nIHdpdGggZWl0aGVyIG1ldGhvZC5cblxuICAgICAgICAvLyBNb3N0IGJyb3dzZXJzIHdpbGwgdXNlIERPTVBhcnNlclxuICAgICAgICAvLyBJRSBmYWlscyBvbiBjZXJ0YWluIFNWRyBmaWxlcywgc28gd2UgaGF2ZSBhIGZhbGxiYWNrIGJlbG93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgICAgIHhtbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgXCJ0ZXh0L3htbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmFsbGJhY2sgZm9yIElFIHN1cHBvcnQuXG4gICAgICAgIGlmICgheG1sKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKTtcbiAgICAgICAgICAgICAgICB4bWwuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB4bWwubG9hZFhNTCh0ZXh0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB4bWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHhtbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBzdHJpbmcgaW50byBhbiBPYmplY3QuXG4gICAgICogQG1ldGhvZCBwYXJzZUpTT05cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGxvYWRlZCBKU09OIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICovXG4gICAgcy5wYXJzZUpTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gVE9ETzsgSGFuZGxlIHRoaXMgd2l0aCBhIGN1c3RvbSBlcnJvcj9cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY3JlYXRlanMuRGF0YVV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFR5cGVzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBnZW5lcmljIGJpbmFyeSB0eXBlcy4gTm90ZSB0aGF0IGltYWdlcyBhcmUgbG9hZGVkIGFzIGJpbmFyeSBmaWxlcyB3aGVuIHVzaW5nIFhIUi5cbiAgICAgKiBAcHJvcGVydHkgQklOQVJZXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBiaW5hcnlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICovXG4gICAgcy5CSU5BUlkgPSBcImJpbmFyeVwiO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWxvYWQgdHlwZSBmb3IgY3NzIGZpbGVzLiBDU1MgZmlsZXMgYXJlIGxvYWRlZCB1c2luZyBhICZsdDtsaW5rJmd0OyB3aGVuIGxvYWRlZCB3aXRoIFhIUiwgb3IgYVxuICAgICAqICZsdDtzdHlsZSZndDsgdGFnIHdoZW4gbG9hZGVkIHdpdGggdGFncy5cbiAgICAgKiBAcHJvcGVydHkgQ1NTXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjc3NcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICovXG4gICAgcy5DU1MgPSBcImNzc1wiO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWxvYWQgdHlwZSBmb3IgZm9udCBmaWxlcy5cbiAgICAgKiBAcHJvcGVydHkgRk9OVFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgZm9udFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC45LjBcbiAgICAgKi9cbiAgICBzLkZPTlQgPSBcImZvbnRcIjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGZvbnRzIHNwZWNpZmllZCB3aXRoIENTUyAoc3VjaCBhcyBHb29nbGUgZm9udHMpXG4gICAgICogQHByb3BlcnR5IEZPTlRDU1NcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IGZvbnRjc3NcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuOS4wXG4gICAgICovXG4gICAgcy5GT05UQ1NTID0gXCJmb250Y3NzXCI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBpbWFnZSBmaWxlcywgdXN1YWxseSBwbmcsIGdpZiwgb3IganBnL2pwZWcuIEltYWdlcyBhcmUgbG9hZGVkIGludG8gYW4gJmx0O2ltYWdlJmd0OyB0YWcuXG4gICAgICogQHByb3BlcnR5IElNQUdFXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBpbWFnZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBzLklNQUdFID0gXCJpbWFnZVwiO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWxvYWQgdHlwZSBmb3IgamF2YXNjcmlwdCBmaWxlcywgdXN1YWxseSB3aXRoIHRoZSBcImpzXCIgZmlsZSBleHRlbnNpb24uIEphdmFTY3JpcHQgZmlsZXMgYXJlIGxvYWRlZCBpbnRvIGFcbiAgICAgKiAmbHQ7c2NyaXB0Jmd0OyB0YWcuXG4gICAgICpcbiAgICAgKiBTaW5jZSB2ZXJzaW9uIDAuNC4xKywgZHVlIHRvIGhvdyB0YWctbG9hZGVkIHNjcmlwdHMgd29yaywgYWxsIEphdmFTY3JpcHQgZmlsZXMgYXJlIGF1dG9tYXRpY2FsbHkgaW5qZWN0ZWQgaW50b1xuICAgICAqIHRoZSBib2R5IG9mIHRoZSBkb2N1bWVudCB0byBtYWludGFpbiBwYXJpdHkgYmV0d2VlbiBYSFIgYW5kIHRhZy1sb2FkZWQgc2NyaXB0cy4gSW4gdmVyc2lvbiAwLjQuMCBhbmQgZWFybGllcixcbiAgICAgKiBvbmx5IHRhZy1sb2FkZWQgc2NyaXB0cyBhcmUgaW5qZWN0ZWQuXG4gICAgICogQHByb3BlcnR5IEpBVkFTQ1JJUFRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IGphdmFzY3JpcHRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICovXG4gICAgcy5KQVZBU0NSSVBUID0gXCJqYXZhc2NyaXB0XCI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqc29uIGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBKU09OIGRhdGEgaXMgbG9hZGVkIGFuZCBwYXJzZWQgaW50byBhXG4gICAgICogSmF2YVNjcmlwdCBvYmplY3QuIE5vdGUgdGhhdCBpZiBhIGBjYWxsYmFja2AgaXMgcHJlc2VudCBvbiB0aGUgbG9hZCBpdGVtLCB0aGUgZmlsZSB3aWxsIGJlIGxvYWRlZCB3aXRoIEpTT05QLFxuICAgICAqIG5vIG1hdHRlciB3aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGlzIHNldCB0bywgYW5kIHRoZSBKU09OXG4gICAgICogbXVzdCBjb250YWluIGEgbWF0Y2hpbmcgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgSlNPTlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQganNvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBzLkpTT04gPSBcImpzb25cIjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGpzb25wIGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBKU09OIGRhdGEgaXMgbG9hZGVkIGFuZCBwYXJzZWQgaW50byBhXG4gICAgICogSmF2YVNjcmlwdCBvYmplY3QuIFlvdSBhcmUgcmVxdWlyZWQgdG8gcGFzcyBhIGNhbGxiYWNrIHBhcmFtZXRlciB0aGF0IG1hdGNoZXMgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgaW4gdGhlIEpTT04uXG4gICAgICogTm90ZSB0aGF0IEpTT05QIHdpbGwgYWx3YXlzIGJlIHVzZWQgaWYgdGhlcmUgaXMgYSBjYWxsYmFjayBwcmVzZW50LCBubyBtYXR0ZXIgd2hhdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIHByb3BlcnR5IGlzIHNldCB0by5cbiAgICAgKiBAcHJvcGVydHkgSlNPTlBcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IGpzb25wXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqL1xuICAgIHMuSlNPTlAgPSBcImpzb25wXCI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqc29uLWJhc2VkIG1hbmlmZXN0IGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNvblwiIGZpbGUgZXh0ZW5zaW9uLiBUaGUgSlNPTiBkYXRhIGlzIGxvYWRlZFxuICAgICAqIGFuZCBwYXJzZWQgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LiBQcmVsb2FkSlMgd2lsbCB0aGVuIGxvb2sgZm9yIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5IGluIHRoZSBKU09OLCB3aGljaCBpcyBhblxuICAgICAqIEFycmF5IG9mIGZpbGVzIHRvIGxvYWQsIGZvbGxvd2luZyB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBtZXRob2QuIElmIGEgXCJjYWxsYmFja1wiIGlzIHNwZWNpZmllZCBvbiB0aGUgbWFuaWZlc3Qgb2JqZWN0LCB0aGVuIGl0IHdpbGwgYmUgbG9hZGVkIHVzaW5nIEpTT05QIGluc3RlYWQsXG4gICAgICogcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGlzIHNldCB0by5cbiAgICAgKiBAcHJvcGVydHkgTUFOSUZFU1RcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IG1hbmlmZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqL1xuICAgIHMuTUFOSUZFU1QgPSBcIm1hbmlmZXN0XCI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBzb3VuZCBmaWxlcywgdXN1YWxseSBtcDMsIG9nZywgb3Igd2F2LiBXaGVuIGxvYWRpbmcgdmlhIHRhZ3MsIGF1ZGlvIGlzIGxvYWRlZCBpbnRvIGFuXG4gICAgICogJmx0O2F1ZGlvJmd0OyB0YWcuXG4gICAgICogQHByb3BlcnR5IFNPVU5EXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBzb3VuZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBzLlNPVU5EID0gXCJzb3VuZFwiO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWxvYWQgdHlwZSBmb3IgdmlkZW8gZmlsZXMsIHVzdWFsbHkgbXA0LCB0cywgb3Igb2dnLiBXaGVuIGxvYWRpbmcgdmlhIHRhZ3MsIHZpZGVvIGlzIGxvYWRlZCBpbnRvIGFuXG4gICAgICogJmx0O3ZpZGVvJmd0OyB0YWcuXG4gICAgICogQHByb3BlcnR5IFZJREVPXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCB2aWRlb1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBzLlZJREVPID0gXCJ2aWRlb1wiO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWxvYWQgdHlwZSBmb3IgU3ByaXRlU2hlZXQgZmlsZXMuIFNwcml0ZVNoZWV0IGZpbGVzIGFyZSBKU09OIGZpbGVzIHRoYXQgY29udGFpbiBzdHJpbmcgaW1hZ2UgcGF0aHMuXG4gICAgICogQHByb3BlcnR5IFNQUklURVNIRUVUXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBzcHJpdGVzaGVldFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBzLlNQUklURVNIRUVUID0gXCJzcHJpdGVzaGVldFwiO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWxvYWQgdHlwZSBmb3IgU1ZHIGZpbGVzLlxuICAgICAqIEBwcm9wZXJ0eSBTVkdcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IHN2Z1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBzLlNWRyA9IFwic3ZnXCI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB0ZXh0IGZpbGVzLCB3aGljaCBpcyBhbHNvIHRoZSBkZWZhdWx0IGZpbGUgdHlwZSBpZiB0aGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQuIFRleHQgaXNcbiAgICAgKiBsb2FkZWQgYXMgcmF3IHRleHQuXG4gICAgICogQHByb3BlcnR5IFRFWFRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IHRleHRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICovXG4gICAgcy5URVhUID0gXCJ0ZXh0XCI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB4bWwgZmlsZXMuIFhNTCBpcyBsb2FkZWQgaW50byBhbiBYTUwgZG9jdW1lbnQuXG4gICAgICogQHByb3BlcnR5IFhNTFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgeG1sXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqL1xuICAgIHMuWE1MID0gXCJ4bWxcIjtcblxuICAgIGNyZWF0ZWpzLlR5cGVzID0gcztcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNZXRob2RzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgUE9TVCByZXF1ZXN0LCB1c2UgZm9yIGEgbWV0aG9kIHZhbHVlIHdoZW4gbG9hZGluZyBkYXRhLlxuICAgICAqIEBwcm9wZXJ0eSBQT1NUXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBwb3N0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHMuUE9TVCA9IFwiUE9TVFwiO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIEdFVCByZXF1ZXN0LCB1c2UgZm9yIGEgbWV0aG9kIHZhbHVlIHdoZW4gbG9hZGluZyBkYXRhLlxuICAgICAqIEBwcm9wZXJ0eSBHRVRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IGdldFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLkdFVCA9IFwiR0VUXCI7XG5cbiAgICBjcmVhdGVqcy5NZXRob2RzID0gcztcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBMb2FkSXRlbS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvKipcbiAgICAgKiBBbGwgbG9hZGVycyBhY2NlcHQgYW4gaXRlbSBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhpcyBjbGFzcy4gSWYgYSByYXcgb2JqZWN0IGlzIHBhc3NlZCBpbnN0ZWFkLFxuICAgICAqIGl0IHdpbGwgbm90IGJlIGFmZmVjdGVkLCBidXQgaXQgbXVzdCBjb250YWluIGF0IGxlYXN0IGEge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LiBBXG4gICAgICogc3RyaW5nIHBhdGggb3IgSFRNTCB0YWcgaXMgYWxzbyBhY2NlcHRhYmxlLCBidXQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhIExvYWRJdGVtIHVzaW5nIHRoZVxuICAgICAqIHt7I2Nyb3NzTGluayBcImNyZWF0ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgYnkge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBAY2xhc3MgTG9hZEl0ZW1cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2FkSXRlbSgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzb3VyY2Ugb2YgdGhlIGZpbGUgdGhhdCBpcyBiZWluZyBsb2FkZWQuIFRoaXMgcHJvcGVydHkgaXMgPGI+cmVxdWlyZWQ8L2I+LiBUaGUgc291cmNlIGNhbiBlaXRoZXIgYmUgYVxuICAgICAgICAgKiBzdHJpbmcgKHJlY29tbWVuZGVkKSwgb3IgYW4gSFRNTCB0YWcuXG4gICAgICAgICAqIFRoaXMgY2FuIGFsc28gYmUgYW4gb2JqZWN0LCBidXQgaW4gdGhhdCBjYXNlIGl0IGhhcyB0byBpbmNsdWRlIGEgdHlwZSBhbmQgYmUgaGFuZGxlZCBieSBhIHBsdWdpbi5cbiAgICAgICAgICogQHByb3BlcnR5IHNyY1xuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNyYyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIGZpbGUgdGhhdCBpcyBiZWluZyBsb2FkZWQuIFRoZSB0eXBlIG9mIHRoZSBmaWxlIGlzIHVzdWFsbHkgaW5mZXJyZWQgYnkgdGhlIGV4dGVuc2lvbiwgYnV0IGNhbiBhbHNvXG4gICAgICAgICAqIGJlIHNldCBtYW51YWxseS4gVGhpcyBpcyBoZWxwZnVsIGluIGNhc2VzIHdoZXJlIGEgZmlsZSBkb2VzIG5vdCBoYXZlIGFuIGV4dGVuc2lvbi5cbiAgICAgICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgaWRlbnRpZmllciB3aGljaCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhlIGxvYWRlZCBvYmplY3QuIElmIG5vbmUgaXMgcHJvdmlkZWQsIHRoaXMgd2lsbCBiZVxuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGUge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgYSBtYW5pZmVzdCB3aWxsIG1haW50YWluIHRoZSBvcmRlciBvZiB0aGlzIGl0ZW0sIGluIHJlbGF0aW9uIHRvIG90aGVyIGl0ZW1zIGluIHRoZSBtYW5pZmVzdFxuICAgICAgICAgKiB0aGF0IGhhdmUgYWxzbyBzZXQgdGhlIGBtYWludGFpbk9yZGVyYCBwcm9wZXJ0eSB0byBgdHJ1ZWAuIFRoaXMgb25seSBhcHBsaWVzIHdoZW4gdGhlIG1heCBjb25uZWN0aW9ucyBoYXNcbiAgICAgICAgICogYmVlbiBzZXQgYWJvdmUgMSAodXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319KS4gRXZlcnl0aGluZyB3aXRoIHRoaXNcbiAgICAgICAgICogcHJvcGVydHkgc2V0IHRvIGBmYWxzZWAgd2lsbCBmaW5pc2ggYXMgaXQgaXMgbG9hZGVkLiBPcmRlcmVkIGl0ZW1zIGFyZSBjb21iaW5lZCB3aXRoIHNjcmlwdCB0YWdzIGxvYWRpbmcgaW5cbiAgICAgICAgICogb3JkZXIgd2hlbiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBzZXQgdG8gYHRydWVgLlxuICAgICAgICAgKiBAcHJvcGVydHkgbWFpbnRhaW5PcmRlclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFpbnRhaW5PcmRlciA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIHVzZWQgYnkgSlNPTlAgcmVxdWVzdHMgdGhhdCBkZWZpbmVzIHdoYXQgZ2xvYmFsIG1ldGhvZCB0byBjYWxsIHdoZW4gdGhlIEpTT05QIGNvbnRlbnQgaXMgbG9hZGVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgY2FsbGJhY2tcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFyYml0cmFyeSBkYXRhIG9iamVjdCwgd2hpY2ggaXMgaW5jbHVkZWQgd2l0aCB0aGUgbG9hZGVkIG9iamVjdC5cbiAgICAgICAgICogQHByb3BlcnR5IGRhdGFcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlcXVlc3QgbWV0aG9kIHVzZWQgZm9yIEhUVFAgY2FsbHMuIEJvdGgge3sjY3Jvc3NMaW5rIFwiTWV0aG9kcy9HRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gb3JcbiAgICAgICAgICoge3sjY3Jvc3NMaW5rIFwiTWV0aG9kcy9QT1NUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHJlcXVlc3QgdHlwZXMgYXJlIHN1cHBvcnRlZCwgYW5kIGFyZSBkZWZpbmVkIGFzXG4gICAgICAgICAqIGNvbnN0YW50cyBvbiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgICAgICogQHByb3BlcnR5IG1ldGhvZFxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCBHRVRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWV0aG9kID0gY3JlYXRlanMuTWV0aG9kcy5HRVQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBoYXNoIG9mIG5hbWUvdmFsdWUgcGFpcnMgdG8gc2VuZCB0byB0aGUgc2VydmVyLlxuICAgICAgICAgKiBAcHJvcGVydHkgdmFsdWVzXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IGhhc2ggb2YgaGVhZGVycyB0byBhdHRhY2ggdG8gYW4gWEhSIHJlcXVlc3QuIFByZWxvYWRKUyB3aWxsIGF1dG9tYXRpY2FsbHkgYXR0YWNoIHNvbWUgZGVmYXVsdFxuICAgICAgICAgKiBoZWFkZXJzIHdoZW4gcmVxdWlyZWQsIGluY2x1ZGluZyBcIk9yaWdpblwiLCBcIkNvbnRlbnQtVHlwZVwiLCBhbmQgXCJYLVJlcXVlc3RlZC1XaXRoXCIuIFlvdSBtYXkgb3ZlcnJpZGUgdGhlXG4gICAgICAgICAqIGRlZmF1bHQgaGVhZGVycyBieSBpbmNsdWRpbmcgdGhlbSBpbiB5b3VyIGhlYWRlcnMgb2JqZWN0LlxuICAgICAgICAgKiBAcHJvcGVydHkgaGVhZGVyc1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUgY3JlZGVudGlhbHMgZm9yIFhIUiByZXF1ZXN0cy5cbiAgICAgICAgICogQHByb3BlcnR5IHdpdGhDcmVkZW50aWFsc1xuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWltZSB0eXBlIG9mIFhIUi1iYXNlZCByZXF1ZXN0cy4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IHNldCB0byBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIiBmb3IgdGV4dFxuICAgICAgICAgKiBiYXNlZCBmaWxlcyAoanNvbiwgeG1sLCB0ZXh0LCBjc3MsIGpzKS5cbiAgICAgICAgICogQHByb3BlcnR5IG1pbWVUeXBlXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWltZVR5cGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgZm9yIENPUlMtZW5hYmxlZCBpbWFnZXMgbG9hZGluZyBjcm9zcy1kb21haW4uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjcm9zc09yaWdpblxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgQW5vbnltb3VzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhIHJlcXVlc3QgdGltZXMgb3V0LiBUaGlzIG9ubHkgYXBwbGllcyB0byB0YWctYmFzZWQgYW5kIGFuZCBYSFJcbiAgICAgICAgICogKGxldmVsIG9uZSkgbG9hZGluZywgYXMgWEhSIChsZXZlbCAyKSBwcm92aWRlcyBpdHMgb3duIHRpbWVvdXQgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBsb2FkVGltZW91dFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCA4MDAwICg4IHNlY29uZHMpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvYWRUaW1lb3V0ID0gcy5MT0FEX1RJTUVPVVRfREVGQVVMVDtcbiAgICB9O1xuXG4gICAgdmFyIHAgPSBMb2FkSXRlbS5wcm90b3R5cGUgPSB7fTtcbiAgICB2YXIgcyA9IExvYWRJdGVtO1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYSByZXF1ZXN0IHRpbWVzIG91dC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gdGFnLWJhc2VkIGFuZCBhbmQgWEhSXG4gICAgICogKGxldmVsIG9uZSkgbG9hZGluZywgYXMgWEhSIChsZXZlbCAyKSBwcm92aWRlcyBpdHMgb3duIHRpbWVvdXQgZXZlbnQuXG4gICAgICogQHByb3BlcnR5IExPQURfVElNRU9VVF9ERUZBVUxUXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcy5MT0FEX1RJTUVPVVRfREVGQVVMVCA9IDgwMDA7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBMb2FkSXRlbS5cbiAgICAgKiA8dWw+XG4gICAgICogICAgIDxsaT5TdHJpbmctYmFzZWQgaXRlbXMgYXJlIGNvbnZlcnRlZCB0byBhIExvYWRJdGVtIHdpdGggYSBwb3B1bGF0ZWQge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LjwvbGk+XG4gICAgICogICAgIDxsaT5Mb2FkSXRlbSBpbnN0YW5jZXMgYXJlIHJldHVybmVkIGFzLWlzPC9saT5cbiAgICAgKiAgICAgPGxpPk9iamVjdHMgYXJlIHJldHVybmVkIHdpdGggYW55IG5lZWRlZCBwcm9wZXJ0aWVzIGFkZGVkPC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxTdHJpbmd8T2JqZWN0fSB2YWx1ZSBUaGUgbG9hZCBpdGVtIHZhbHVlXG4gICAgICogQHJldHVybnMge0xvYWRJdGVtfE9iamVjdH1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcy5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG5ldyBMb2FkSXRlbSgpO1xuICAgICAgICAgICAgaXRlbS5zcmMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2Ygcykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmIHZhbHVlLnNyYykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxvYWRUaW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5sb2FkVGltZW91dCA9IHMuTE9BRF9USU1FT1VUX0RFRkFVTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIG5vdCByZWNvZ25pemVkLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gICAgICpcbiAgICAgKiAgICAgIHZhciBsb2FkSXRlbSA9IG5ldyBjcmVhdGVqcy5Mb2FkSXRlbSgpLnNldCh7c3JjOlwiaW1hZ2UucG5nXCIsIG1haW50YWluT3JkZXI6dHJ1ZX0pO1xuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgTG9hZEl0ZW0gaW5zdGFuY2UuXG4gICAgICogQHJldHVybiB7TG9hZEl0ZW19IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcbiAgICAqL1xuICAgIHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNyZWF0ZWpzLkxvYWRJdGVtID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFJlcXVlc3RVdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdGllcyB0aGF0IGFzc2lzdCB3aXRoIHBhcnNpbmcgbG9hZCBpdGVtcywgYW5kIGRldGVybWluaW5nIGZpbGUgdHlwZXMsIGV0Yy5cbiAgICAgKiBAY2xhc3MgUmVxdWVzdFV0aWxzXG4gICAgICovXG4gICAgdmFyIHMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBhIHNwZWNpZmljIHR5cGUgc2hvdWxkIGJlIGxvYWRlZCBhcyBhIGJpbmFyeSBmaWxlLiBDdXJyZW50bHksIG9ubHkgaW1hZ2VzIGFuZCBpdGVtcyBtYXJrZWRcbiAgICAgKiBzcGVjaWZpY2FsbHkgYXMgXCJiaW5hcnlcIiBhcmUgbG9hZGVkIGFzIGJpbmFyeS4gTm90ZSB0aGF0IGF1ZGlvIGlzIDxiPm5vdDwvYj4gYSBiaW5hcnkgdHlwZSwgYXMgd2UgY2FuIG5vdCBwbGF5XG4gICAgICogYmFjayB1c2luZyBhbiBhdWRpbyB0YWcgaWYgaXQgaXMgbG9hZGVkIGFzIGJpbmFyeS4gUGx1Z2lucyBjYW4gY2hhbmdlIHRoZSBpdGVtIHR5cGUgdG8gYmluYXJ5IHRvIGVuc3VyZSB0aGV5IGdldFxuICAgICAqIGEgYmluYXJ5IHJlc3VsdCB0byB3b3JrIHdpdGguIEJpbmFyeSBmaWxlcyBhcmUgbG9hZGVkIHVzaW5nIFhIUjIuIFR5cGVzIGFyZSBkZWZpbmVkIGFzIHN0YXRpYyBjb25zdGFudHMgb25cbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAbWV0aG9kIGlzQmluYXJ5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGl0ZW0gdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgYmluYXJ5LlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmlzQmluYXJ5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIGNyZWF0ZWpzLlR5cGVzLklNQUdFOlxuICAgICAgICAgICAgY2FzZSBjcmVhdGVqcy5UeXBlcy5CSU5BUlk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyB0eXBlIGlzIGEgdGV4dC1iYXNlZCBhc3NldCwgYW5kIHNob3VsZCBiZSBsb2FkZWQgYXMgVVRGLTguXG4gICAgICogQG1ldGhvZCBpc1RleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgaXRlbSB0eXBlLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBzcGVjaWZpZWQgdHlwZSBpcyB0ZXh0LlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmlzVGV4dCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjcmVhdGVqcy5UeXBlcy5URVhUOlxuICAgICAgICAgICAgY2FzZSBjcmVhdGVqcy5UeXBlcy5KU09OOlxuICAgICAgICAgICAgY2FzZSBjcmVhdGVqcy5UeXBlcy5NQU5JRkVTVDpcbiAgICAgICAgICAgIGNhc2UgY3JlYXRlanMuVHlwZXMuWE1MOlxuICAgICAgICAgICAgY2FzZSBjcmVhdGVqcy5UeXBlcy5DU1M6XG4gICAgICAgICAgICBjYXNlIGNyZWF0ZWpzLlR5cGVzLlNWRzpcbiAgICAgICAgICAgIGNhc2UgY3JlYXRlanMuVHlwZXMuSkFWQVNDUklQVDpcbiAgICAgICAgICAgIGNhc2UgY3JlYXRlanMuVHlwZXMuU1BSSVRFU0hFRVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG9iamVjdCB1c2luZyBjb21tb24gZXh0ZW5zaW9ucy4gTm90ZSB0aGF0IHRoZSB0eXBlIGNhbiBiZSBwYXNzZWQgaW4gd2l0aCB0aGUgbG9hZCBpdGVtXG4gICAgICogaWYgaXQgaXMgYW4gdW51c3VhbCBleHRlbnNpb24uXG4gICAgICogQG1ldGhvZCBnZXRUeXBlQnlFeHRlbnNpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXh0ZW5zaW9uIFRoZSBmaWxlIGV4dGVuc2lvbiB0byB1c2UgdG8gZGV0ZXJtaW5lIHRoZSBsb2FkIHR5cGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgZGV0ZXJtaW5lZCBsb2FkIHR5cGUgKGZvciBleGFtcGxlLCA8Y29kZT5BYnN0cmFjdExvYWRlci5JTUFHRTwvY29kZT4pLiBXaWxsIHJldHVybiBgbnVsbGAgaWZcbiAgICAgKiB0aGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcy5nZXRUeXBlQnlFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgIGlmIChleHRlbnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLlRFWFQ7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwianBlZ1wiOlxuICAgICAgICAgICAgY2FzZSBcImpwZ1wiOlxuICAgICAgICAgICAgY2FzZSBcImdpZlwiOlxuICAgICAgICAgICAgY2FzZSBcInBuZ1wiOlxuICAgICAgICAgICAgY2FzZSBcIndlYnBcIjpcbiAgICAgICAgICAgIGNhc2UgXCJibXBcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlanMuVHlwZXMuSU1BR0U7XG4gICAgICAgICAgICBjYXNlIFwib2dnXCI6XG4gICAgICAgICAgICBjYXNlIFwibXAzXCI6XG4gICAgICAgICAgICBjYXNlIFwid2VibVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVqcy5UeXBlcy5TT1VORDtcbiAgICAgICAgICAgIGNhc2UgXCJtcDRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWJtXCI6XG4gICAgICAgICAgICBjYXNlIFwidHNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlanMuVHlwZXMuVklERU87XG4gICAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVqcy5UeXBlcy5KU09OO1xuICAgICAgICAgICAgY2FzZSBcInhtbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVqcy5UeXBlcy5YTUw7XG4gICAgICAgICAgICBjYXNlIFwiY3NzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZWpzLlR5cGVzLkNTUztcbiAgICAgICAgICAgIGNhc2UgXCJqc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVqcy5UeXBlcy5KQVZBU0NSSVBUO1xuICAgICAgICAgICAgY2FzZSAnc3ZnJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlanMuVHlwZXMuU1ZHO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlanMuVHlwZXMuVEVYVDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMgPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvclxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGxvYWRlciwgd2hpY2ggZGVmaW5lcyBhbGwgdGhlIGdlbmVyaWMgbWV0aG9kcywgcHJvcGVydGllcywgYW5kIGV2ZW50cy4gQWxsIGxvYWRlcnMgZXh0ZW5kIHRoaXMgY2xhc3MsXG4gICAgICogaW5jbHVkaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQGNsYXNzIEFic3RyYWN0TG9hZGVyXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxvYmplY3R8c3RyaW5nfSBsb2FkSXRlbSBUaGUgaXRlbSB0byBiZSBsb2FkZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJlZmVyWEhSXSBEZXRlcm1pbmVzIGlmIHRoZSBMb2FkSXRlbSBzaG91bGQgPGVtPnRyeTwvZW0+IGFuZCBsb2FkIHVzaW5nIFhIUiwgb3IgdGFrZSBhXG4gICAgICogdGFnLWJhc2VkIGFwcHJvYWNoLCB3aGljaCBjYW4gYmUgYmV0dGVyIGluIGNyb3NzLWRvbWFpbiBzaXR1YXRpb25zLiBOb3QgYWxsIGxvYWRlcnMgY2FuIGxvYWQgdXNpbmcgb25lIG9yIHRoZVxuICAgICAqIG90aGVyLCBzbyB0aGlzIGlzIGEgc3VnZ2VzdGVkIGRpcmVjdGl2ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFRoZSB0eXBlIG9mIGxvYWRlci4gTG9hZGVyIHR5cGVzIGFyZSBkZWZpbmVkIGFzIGNvbnN0YW50cyBvbiB0aGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MsXG4gICAgICogc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJJTUFHRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LCBldGMuXG4gICAgICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWJzdHJhY3RMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSkge1xuICAgICAgICB0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG4gICAgICAgIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgbG9hZGVyIGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyBwcm92aWRlcyBhIHF1aWNrIGNoZWNrLCBidXQgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIGRpZmZlcmVudCBhcHByb2FjaGVzXG4gICAgICAgICAqIHVzZWQgZm9yIGxvYWRpbmcgZG8gbm90IHBpbGUgdXAgcmVzdWx0aW5nIGluIG1vcmUgdGhhbiBvbmUgYGNvbXBsZXRlYCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgICAgICogQHByb3BlcnR5IGxvYWRlZFxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZSBpZiB0aGUgbG9hZGVyIHdhcyBjYW5jZWxlZC4gQ2FuY2VsZWQgbG9hZHMgd2lsbCBub3QgZmlyZSBjb21wbGV0ZSBldmVudHMuIE5vdGUgdGhhdCB0aGlzIHByb3BlcnR5XG4gICAgICAgICAqIGlzIHJlYWRvbmx5LCBzbyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gcXVldWVzIHNob3VsZCBiZSBjbG9zZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICAgICAqIGluc3RlYWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjYW5jZWxlZFxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGxvYWQgcHJvZ3Jlc3MgKHBlcmNlbnRhZ2UpIGZvciB0aGlzIGl0ZW0uIFRoaXMgd2lsbCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICAgICAqXG4gICAgICAgICAqIDxoND5FeGFtcGxlPC9oND5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcbiAgICAgICAgICogICAgIHF1ZXVlLmxvYWRGaWxlKFwibGFyZ2VJbWFnZS5wbmdcIik7XG4gICAgICAgICAqICAgICBxdWV1ZS5vbihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKFwiUHJvZ3Jlc3M6XCIsIHF1ZXVlLnByb2dyZXNzLCBldmVudC5wcm9ncmVzcyk7XG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IHByb2dyZXNzXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiBpdGVtIHRoaXMgbG9hZGVyIHdpbGwgbG9hZC4gU2VlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIGZ1bGwgbGlzdCBvZlxuICAgICAgICAgKiBzdXBwb3J0ZWQgdHlwZXMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZvcm1hdHRlciBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIHRoZSBsb2FkZWQgcmF3IHJlc3VsdCBpbnRvIHRoZSBmaW5hbCByZXN1bHQuIEZvciBleGFtcGxlLCB0aGUgSlNPTkxvYWRlclxuICAgICAgICAgKiBjb252ZXJ0cyBhIHN0cmluZyBvZiB0ZXh0IGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC4gTm90IGFsbCBsb2FkZXJzIGhhdmUgYSByZXN1bHRGb3JtYXR0ZXIsIGFuZCB0aGlzIHByb3BlcnR5XG4gICAgICAgICAqIGNhbiBiZSBvdmVycmlkZGVuIHRvIHByb3ZpZGUgY3VzdG9tIGZvcm1hdHRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9wdGlvbmFsbHksIGEgcmVzdWx0Rm9ybWF0dGVyIGNhbiByZXR1cm4gYSBjYWxsYmFjayBmdW5jdGlvbiBpbiBjYXNlcyB3aGVyZSB0aGUgZm9ybWF0dGluZyBuZWVkcyB0byBiZVxuICAgICAgICAgKiBhc3luY2hyb25vdXMsIHN1Y2ggYXMgY3JlYXRpbmcgYSBuZXcgaW1hZ2UuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQgMiBwYXJhbWV0ZXJzLCB3aGljaCBhcmUgY2FsbGJhY2tzXG4gICAgICAgICAqIHRvIGhhbmRsZSBzdWNjZXNzIGFuZCBlcnJvciBjb25kaXRpb25zIGluIHRoZSByZXN1bHRGb3JtYXR0ZXIuIE5vdGUgdGhhdCB0aGUgcmVzdWx0Rm9ybWF0dGVyIG1ldGhvZCBpc1xuICAgICAgICAgKiBjYWxsZWQgaW4gdGhlIGN1cnJlbnQgc2NvcGUsIGFzIHdlbGwgYXMgdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcy5cbiAgICAgICAgICpcbiAgICAgICAgICogPGg0PkV4YW1wbGUgYXN5bmNocm9ub3VzIHJlc3VsdEZvcm1hdHRlcjwvaDQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICBmdW5jdGlvbiBfZm9ybWF0UmVzdWx0KGxvYWRlcikge1xuICAgICAgICAgKiAgICAgIHJldHVybiBmdW5jdGlvbihzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgKiAgICAgICAgICBpZiAoZXJyb3JDb25kaXRpb24pIHsgZXJyb3IoZXJyb3JEZXRhaWxFdmVudCk7IH1cbiAgICAgICAgICogICAgICAgICAgc3VjY2VzcyhyZXN1bHQpO1xuICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICogIH1cbiAgICAgICAgICogQHByb3BlcnR5IHJlc3VsdEZvcm1hdHRlclxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gbnVsbDtcblxuICAgICAgICAvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHRoaXMgbG9hZGVyIHJlcHJlc2VudHMuIE5vdGUgdGhhdCB0aGlzIGlzIG51bGwgaW4gYSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0sXG4gICAgICAgICAqIGJ1dCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiWE1MTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJJbWFnZUxvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgICAgICogQHByb3BlcnR5IF9pdGVtXG4gICAgICAgICAqIEB0eXBlIHtMb2FkSXRlbXxPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobG9hZEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW0gPSBjcmVhdGVqcy5Mb2FkSXRlbS5jcmVhdGUobG9hZEl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXRlbSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbG9hZGVyIHdpbGwgdHJ5IGFuZCBsb2FkIGNvbnRlbnQgdXNpbmcgWEhSICh0cnVlKSBvciBIVE1MIHRhZ3MgKGZhbHNlKS5cbiAgICAgICAgICogQHByb3BlcnR5IF9wcmVmZXJYSFJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcmVmZXJYSFIgPSBwcmVmZXJYSFI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2FkZWQgcmVzdWx0IGFmdGVyIGl0IGlzIGZvcm1hdHRlZCBieSBhbiBvcHRpb25hbCB7eyNjcm9zc0xpbmsgXCJyZXN1bHRGb3JtYXR0ZXJcIn19e3svY3Jvc3NMaW5rfX0uIEZvclxuICAgICAgICAgKiBpdGVtcyB0aGF0IGFyZSBub3QgZm9ybWF0dGVkLCB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHt7I2Nyb3NzTGluayBcIl9yYXdSZXN1bHQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICAgICAqIFRoZSByZXN1bHQgaXMgYWNjZXNzZWQgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfcmVzdWx0XG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R8U3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvYWRlZCByZXN1bHQgYmVmb3JlIGl0IGlzIGZvcm1hdHRlZC4gVGhlIHJhd1Jlc3VsdCBpcyBhY2Nlc3NlZCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICAgICAqIG1ldGhvZCwgYW5kIHBhc3NpbmcgYHRydWVgLlxuICAgICAgICAgKiBAcHJvcGVydHkgX3Jhd1Jlc3VsdFxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fFN0cmluZ31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jhd1Jlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBpdGVtcyB0aGF0IGxvYWRlcnMgbG9hZCBiZWhpbmQgdGhlIHNjZW5lcy4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBtYWluIGl0ZW0gdGhlIGxvYWRlciBpc1xuICAgICAgICAgKiByZXNwb25zaWJsZSBmb3IgbG9hZGluZy4gRXhhbXBsZXMgb2YgbG9hZGVycyB0aGF0IGhhdmUgc3ViLWl0ZW1zIGluY2x1ZGUgdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZFxuICAgICAgICAgKiB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgICAgICogQHByb3BlcnR5IF9sb2FkSXRlbXNcbiAgICAgICAgICogQHR5cGUge251bGx9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWRlZEl0ZW1zID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGF0dHJpYnV0ZSB0aGUgaXRlbXMgbG9hZGVkIHVzaW5nIHRhZ3MgdXNlIGZvciB0aGUgc291cmNlLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBIVE1MIHRhZyAob3Igc2ltaWxhcikgdGhhdCBhIGxvYWRlciBtYXkgdXNlIHRvIGxvYWQgSFRNTCBjb250ZW50LCBzdWNoIGFzIGltYWdlcywgc2NyaXB0cywgZXRjLlxuICAgICAgICAgKiBAcHJvcGVydHkgX3RhZ1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGFnID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RMb2FkZXIsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG4gICAgdmFyIHMgPSBBYnN0cmFjdExvYWRlcjtcblxuLy8gRXZlbnRzXG4gICAgLyoqXG4gICAgICogVGhlIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBvdmVyYWxsIHByb2dyZXNzIGNoYW5nZXMuIFByaW9yIHRvXG4gICAgICogdmVyc2lvbiAwLjYuMCwgdGhpcyB3YXMganVzdCBhIHJlZ3VsYXIge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQGV2ZW50IHByb2dyZXNzXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGEgbG9hZCBzdGFydHMuXG4gICAgICogQGV2ZW50IGxvYWRzdGFydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBzaW5jZSAwLjMuMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgZW50aXJlIHF1ZXVlIGhhcyBiZWVuIGxvYWRlZC5cbiAgICAgKiBAZXZlbnQgY29tcGxldGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFcnJvckV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgbG9hZGVyIGVuY291bnRlcnMgYW4gZXJyb3IuIElmIHRoZSBlcnJvciB3YXNcbiAgICAgKiBlbmNvdW50ZXJlZCBieSBhIGZpbGUsIHRoZSBldmVudCB3aWxsIGNvbnRhaW4gdGhlIGl0ZW0gdGhhdCBjYXVzZWQgdGhlIGVycm9yLiBQcmlvciB0byB2ZXJzaW9uIDAuNi4wLCB0aGlzIHdhc1xuICAgICAqIGp1c3QgYSByZWd1bGFyIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBldmVudCBlcnJvclxuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgbG9hZGVyIGVuY291bnRlcnMgYW4gaW50ZXJuYWwgZmlsZSBsb2FkIGVycm9yLlxuICAgICAqIFRoaXMgZW5hYmxlcyBsb2FkZXJzIHRvIG1haW50YWluIGludGVybmFsIHF1ZXVlcywgYW5kIHN1cmZhY2UgZmlsZSBsb2FkIGVycm9ycy5cbiAgICAgKiBAZXZlbnQgZmlsZWVycm9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUgKFwiZmlsZWVycm9yXCIpXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxvYmplY3R9IFRoZSBpdGVtIHRoYXQgZW5jb3VudGVyZWQgdGhlIGVycm9yXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGEgbG9hZGVyIGludGVybmFsbHkgbG9hZHMgYSBmaWxlLiBUaGlzIGVuYWJsZXNcbiAgICAgKiBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gdG8gbWFpbnRhaW4gaW50ZXJuYWwge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319c1xuICAgICAqIGFuZCBub3RpZnkgd2hlbiB0aGV5IGhhdmUgbG9hZGVkIGEgZmlsZS4gVGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBkaXNwYXRjaGVzIGFcbiAgICAgKiBzbGlnaHRseSBkaWZmZXJlbnQge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LlxuICAgICAqIEBldmVudCBmaWxlbG9hZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlIChcImZpbGVsb2FkXCIpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGZpbGUgaXRlbSB3aGljaCB3YXMgc3BlY2lmaWVkIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG4gICAgICogb2JqZWN0IHdpbGwgY29udGFpbiB0aGF0IHZhbHVlIGFzIGEgYHNyY2AgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBUaGUgSFRNTCB0YWcgb3IgcGFyc2VkIHJlc3VsdCBvZiB0aGUgbG9hZGVkIGl0ZW0uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJhd1Jlc3VsdCBUaGUgdW5wcm9jZXNzZWQgcmVzdWx0LCB1c3VhbGx5IHRoZSByYXcgdGV4dCBvciBiaW5hcnkgZGF0YSBiZWZvcmUgaXQgaXMgY29udmVydGVkXG4gICAgICogdG8gYSB1c2FibGUgb2JqZWN0LlxuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgYWZ0ZXIgdGhlIGludGVybmFsIHJlcXVlc3QgaXMgY3JlYXRlZCwgYnV0IGJlZm9yZSBhIGxvYWQuXG4gICAgICogVGhpcyBhbGxvd3MgdXBkYXRlcyB0byB0aGUgbG9hZGVyIGZvciBzcGVjaWZpYyBsb2FkaW5nIG5lZWRzLCBzdWNoIGFzIGJpbmFyeSBvciBYSFIgaW1hZ2UgbG9hZGluZy5cbiAgICAgKiBAZXZlbnQgaW5pdGlhbGl6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlIChcImluaXRpYWxpemVcIilcbiAgICAgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIGxvYWRlciB0aGF0IGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIG1hbmlmZXN0IGl0ZW0gdGhhdCBpcyBsb2FkZWQgYnkgdGhpcyBsb2FkZXIuIEluIHNvbWUgY2FzZXMgdGhpcyB3aWxsIGJlIHRoZSB2YWx1ZSB0aGF0IHdhc1xuICAgICAqIHBhc3NlZCBpbnRvIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3JcbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBIb3dldmVyIGlmIG9ubHkgYSBTdHJpbmcgcGF0aCB3YXMgcGFzc2VkIGluLCB0aGVuIGl0IHdpbGxcbiAgICAgKiBiZSBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBtZXRob2QgZ2V0SXRlbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1hbmlmZXN0IGl0ZW0gdGhhdCB0aGlzIGxvYWRlciBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZy5cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBwLmdldEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkIGJ5IHRoZSBsb2FkZXIgKG9ubHkgYXZhaWxhYmxlIGFmdGVyIHRoZSB7eyNjcm9zc0xpbmsgXCJjb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIGV2ZW50IGlzIGRpc3BhdGNoZWQuXG4gICAgICogQG1ldGhvZCBnZXRSZXN1bHRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXc9ZmFsc2VdIERldGVybWluZXMgaWYgdGhlIHJldHVybmVkIHJlc3VsdCB3aWxsIGJlIHRoZSBmb3JtYXR0ZWQgY29udGVudCwgb3IgdGhlIHJhdyBsb2FkZWRcbiAgICAgKiBkYXRhIChpZiBpdCBleGlzdHMpLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBwLmdldFJlc3VsdCA9IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgcmV0dXJuIHJhdyA/IHRoaXMuX3Jhd1Jlc3VsdCA6IHRoaXMuX3Jlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBgdGFnYCB0aGlzIG9iamVjdCBjcmVhdGVzIG9yIHVzZXMgZm9yIGxvYWRpbmcuXG4gICAgICogQG1ldGhvZCBnZXRUYWdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YWcgaW5zdGFuY2VcbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBwLmdldFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBgdGFnYCB0aGlzIGl0ZW0gdXNlcyBmb3IgbG9hZGluZy5cbiAgICAgKiBAbWV0aG9kIHNldFRhZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YWcgVGhlIHRhZyBpbnN0YW5jZVxuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqL1xuICAgIHAuc2V0VGFnID0gZnVuY3Rpb24odGFnKSB7XG4gICAgICB0aGlzLl90YWcgPSB0YWc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEJlZ2luIGxvYWRpbmcgdGhlIGl0ZW0uIFRoaXMgbWV0aG9kIGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgYSBsb2FkZXIgYnkgaXRzZWxmLlxuICAgICAqXG4gICAgICogPGg0PkV4YW1wbGU8L2g0PlxuICAgICAqXG4gICAgICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG4gICAgICogICAgICBxdWV1ZS5vbihcImNvbXBsZXRlXCIsIGhhbmRsZUNvbXBsZXRlKTtcbiAgICAgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChmaWxlQXJyYXksIGZhbHNlKTsgLy8gTm90ZSB0aGUgMm5kIGFyZ3VtZW50IHRoYXQgdGVsbHMgdGhlIHF1ZXVlIG5vdCB0byBzdGFydCBsb2FkaW5nIHlldFxuICAgICAqICAgICAgcXVldWUubG9hZCgpO1xuICAgICAqXG4gICAgICogQG1ldGhvZCBsb2FkXG4gICAgICovXG4gICAgcC5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVSZXF1ZXN0KCk7XG5cbiAgICAgICAgdGhpcy5fcmVxdWVzdC5vbihcImNvbXBsZXRlXCIsIHRoaXMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0Lm9uKFwicHJvZ3Jlc3NcIiwgdGhpcywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3Qub24oXCJsb2FkU3RhcnRcIiwgdGhpcywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3Qub24oXCJhYm9ydFwiLCB0aGlzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdC5vbihcInRpbWVvdXRcIiwgdGhpcywgdGhpcyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCB0aGlzLCB0aGlzKTtcblxuICAgICAgICB2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiaW5pdGlhbGl6ZVwiKTtcbiAgICAgICAgZXZ0LmxvYWRlciA9IHRoaXMuX3JlcXVlc3Q7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICAgIHRoaXMuX3JlcXVlc3QubG9hZCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgdGhlIGl0ZW0uIFRoaXMgd2lsbCBzdG9wIGFueSBvcGVuIHJlcXVlc3RzIChhbHRob3VnaCBkb3dubG9hZHMgdXNpbmcgSFRNTCB0YWdzIG1heSBzdGlsbCBjb250aW51ZSBpblxuICAgICAqIHRoZSBiYWNrZ3JvdW5kKSwgYnV0IGV2ZW50cyB3aWxsIG5vdCBsb25nZXIgYmUgZGlzcGF0Y2hlZC5cbiAgICAgKiBAbWV0aG9kIGNhbmNlbFxuICAgICAqL1xuICAgIHAuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIHRoZSBsb2FkZXIuXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgcC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2l0ZW0gPSBudWxsO1xuICAgICAgICB0aGlzLl9yYXdSZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2xvYWRJdGVtcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW55IGl0ZW1zIGxvYWRlZCBpbnRlcm5hbGx5IGJ5IHRoZSBsb2FkZXIuIFRoZSBlbmFibGVzIGxvYWRlcnMgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIHRvIGV4cG9zZSBpdGVtcyBpdCBsb2FkcyBpbnRlcm5hbGx5LlxuICAgICAqIEBtZXRob2QgZ2V0TG9hZGVkSXRlbXNcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBsaXN0IG9mIHRoZSBpdGVtcyBsb2FkZWQgYnkgdGhlIGxvYWRlci5cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBwLmdldExvYWRlZEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkSXRlbXM7XG4gICAgfTtcblxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGludGVybmFsIHJlcXVlc3QgdXNlZCBmb3IgbG9hZGluZy4gQnkgZGVmYXVsdCwgYW4ge3sjY3Jvc3NMaW5rIFwiWEhSUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSBvclxuICAgICAqIHt7I2Nyb3NzTGluayBcIlRhZ1JlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gaXMgY3JlYXRlZCwgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiB7eyNjcm9zc0xpbmsgXCJwcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogT3RoZXIgbG9hZGVycyBtYXkgb3ZlcnJpZGUgdGhpcyB0byB1c2UgZGlmZmVyZW50IHJlcXVlc3QgdHlwZXMsIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sXG4gICAgICogd2hpY2ggdXNlcyB7eyNjcm9zc0xpbmsgXCJKU09OTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IHVuZGVyIHRoZSBob29kLlxuICAgICAqIEBtZXRob2QgX2NyZWF0ZVJlcXVlc3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByZWZlclhIUikge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5UYWdSZXF1ZXN0KHRoaXMuX2l0ZW0sIHRoaXMuX3RhZyB8fCB0aGlzLl9jcmVhdGVUYWcoKSwgdGhpcy5fdGFnU3JjQXR0cmlidXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuWEhSUmVxdWVzdCh0aGlzLl9pdGVtKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIEhUTUwgdGFnIHVzZWQgZm9yIGxvYWRpbmcuIFRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyBieSBkZWZhdWx0LCBhbmQgbmVlZHMgdG8gYmUgaW1wbGVtZW50ZWRcbiAgICAgKiBieSBsb2FkZXJzIHRoYXQgcmVxdWlyZSB0YWcgbG9hZGluZy5cbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVUYWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSB0YWcgc291cmNlXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSB0YWcgdGhhdCB3YXMgY3JlYXRlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbihzcmMpIHsgcmV0dXJuIG51bGw7IH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIGxvYWRzdGFydCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZHN0YXJ0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG4gICAgICogQG1ldGhvZCBfc2VuZExvYWRTdGFydFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl9zZW5kTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxlZCgpKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAbWV0aG9kIF9zZW5kUHJvZ3Jlc3NcbiAgICAgKiBAcGFyYW0ge051bWJlciB8IE9iamVjdH0gdmFsdWUgVGhlIHByb2dyZXNzIG9mIHRoZSBsb2FkZWQgaXRlbSwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgPGNvZGU+bG9hZGVkPC9jb2RlPlxuICAgICAqIGFuZCA8Y29kZT50b3RhbDwvY29kZT4gcHJvcGVydGllcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcC5fc2VuZFByb2dyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGVkKCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YodmFsdWUpID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSB2YWx1ZTtcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQodGhpcy5wcm9ncmVzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHZhbHVlLmxvYWRlZCAvIHZhbHVlLnRvdGFsO1xuICAgICAgICAgICAgZXZlbnQucHJvZ3Jlc3MgPSB0aGlzLnByb2dyZXNzO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJvZ3Jlc3MpIHx8IHRoaXMucHJvZ3Jlc3MgPT0gSW5maW5pdHkpIHsgdGhpcy5wcm9ncmVzcyA9IDA7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIGNvbXBsZXRlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuICAgICAqIEBtZXRob2QgX3NlbmRDb21wbGV0ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl9zZW5kQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGVkKCkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImNvbXBsZXRlXCIpO1xuICAgICAgICBldmVudC5yYXdSZXN1bHQgPSB0aGlzLl9yYXdSZXN1bHQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBldmVudC5yZXN1bHQgPSB0aGlzLl9yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhbiBlcnJvciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBldmVudCBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cbiAgICAgKiBAbWV0aG9kIF9zZW5kRXJyb3JcbiAgICAgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBzcGVjaWZpYyBlcnJvciBwcm9wZXJ0aWVzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl9zZW5kRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSB8fCAhdGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZXJyb3JcIikpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChldmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9FUlJPUl9FTVBUWVwiKTsgLy8gVE9ETzogUG9wdWxhdGUgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIGxvYWQgaGFzIGJlZW4gY2FuY2VsZWQuIFRoaXMgaXMgaW1wb3J0YW50IHRvIGVuc3VyZSB0aGF0IG1ldGhvZCBjYWxscyBvciBhc3luY2hyb25vdXMgZXZlbnRzXG4gICAgICogZG8gbm90IGNhdXNlIGlzc3VlcyBhZnRlciB0aGUgcXVldWUgaGFzIGJlZW4gY2xlYW5lZCB1cC5cbiAgICAgKiBAbWV0aG9kIF9pc0NhbmNlbGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGxvYWRlciBoYXMgYmVlbiBjYW5jZWxlZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcC5faXNDYW5jZWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jcmVhdGVqcyA9PSBudWxsIHx8IHRoaXMuY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBjdXN0b20gcmVzdWx0IGZvcm1hdHRlciBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIGp1c3QgYmVmb3JlIGEgcmVxdWVzdCBkaXNwYXRjaGVzIGl0cyBjb21wbGV0ZSBldmVudC4gTW9zdFxuICAgICAqIGxvYWRlciB0eXBlcyBhbHJlYWR5IGhhdmUgYW4gaW50ZXJuYWwgZm9ybWF0dGVyLCBidXQgdGhpcyBjYW4gYmUgdXNlci1vdmVycmlkZGVuIGZvciBjdXN0b20gZm9ybWF0dGluZy4gVGhlXG4gICAgICogZm9ybWF0dGVkIHJlc3VsdCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBMb2FkZXJzIHVzaW5nIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHBhc3NpbmcgYHRydWVgLlxuICAgICAqIEBwcm9wZXJ0eSByZXN1bHRGb3JtYXR0ZXJcbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGZvcm1hdHRlZCByZXN1bHRcbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBwLnJlc3VsdEZvcm1hdHRlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZXZlbnRzIGZyb20gaW50ZXJuYWwgcmVxdWVzdHMuIEJ5IGRlZmF1bHQsIGxvYWRlcnMgd2lsbCBoYW5kbGUsIGFuZCByZWRpc3BhdGNoIHRoZSBuZWNlc3NhcnkgZXZlbnRzLCBidXRcbiAgICAgKiB0aGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBmb3IgY3VzdG9tIGJlaGF2aW91cnMuXG4gICAgICogQG1ldGhvZCBoYW5kbGVFdmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0aGF0IHRoZSBpbnRlcm5hbCByZXF1ZXN0IGRpc3BhdGNoZXMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqL1xuICAgIHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY29tcGxldGVcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuX3Jlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEZvcm1hdHRlciAmJiB0aGlzLnJlc3VsdEZvcm1hdHRlcih0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0Rm9ybWF0dGVyIGlzIGFzeW5jaHJvbm91c1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWpzLnByb3h5KHRoaXMuX3Jlc3VsdEZvcm1hdFN1Y2Nlc3MsIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWpzLnByb3h5KHRoaXMuX3Jlc3VsdEZvcm1hdEZhaWxlZCwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0IGZvcm1hdHRlciBpcyBzeW5jaHJvbm91c1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdCA9ICByZXN1bHQgfHwgdGhpcy5fcmF3UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicHJvZ3Jlc3NcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kUHJvZ3Jlc3MoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsb2Fkc3RhcnRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kTG9hZFN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYWJvcnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ0aW1lb3V0XCI6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9cIiArIGV2ZW50LnR5cGUudG9VcHBlckNhc2UoKSArIFwiX0VSUk9SXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIFwic3VjY2Vzc1wiIGNhbGxiYWNrIHBhc3NlZCB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9yZXN1bHRGb3JtYXR0ZXJcIn19e3svY3Jvc3NMaW5rfX0gYXN5bmNocm9ub3VzXG4gICAgICogZnVuY3Rpb25zLlxuICAgICAqIEBtZXRob2QgX3Jlc3VsdEZvcm1hdFN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFRoZSBmb3JtYXR0ZWQgcmVzdWx0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9yZXN1bHRGb3JtYXRTdWNjZXNzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgXCJlcnJvclwiIGNhbGxiYWNrIHBhc3NlZCB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9yZXN1bHRGb3JtYXR0ZXJcIn19e3svY3Jvc3NMaW5rfX0gYXN5bmNocm9ub3VzXG4gICAgICogZnVuY3Rpb25zLlxuICAgICAqIEBtZXRob2QgX3Jlc3VsdEZvcm1hdFN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXJyb3IgVGhlIGVycm9yIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9yZXN1bHRGb3JtYXRGYWlsZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIltQcmVsb2FkSlMgQWJzdHJhY3RMb2FkZXJdXCI7XG4gICAgfTtcblxuICAgIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdExvYWRlciwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBYnN0cmFjdE1lZGlhTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgLyoqXG4gICAgICogVGhlIEFic3RyYWN0TWVkaWFMb2FkZXIgaXMgYSBiYXNlIGNsYXNzIHRoYXQgaGFuZGxlcyBzb21lIG9mIHRoZSBzaGFyZWQgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBvZiBsb2FkZXJzIHRoYXRcbiAgICAgKiBoYW5kbGUgSFRNTCBtZWRpYSBlbGVtZW50cywgc3VjaCBhcyBWaWRlbyBhbmQgQXVkaW8uXG4gICAgICogQGNsYXNzIEFic3RyYWN0TWVkaWFMb2FkZXJcbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIG1lZGlhIHRvIGxvYWQuIFVzdWFsbHkgXCJ2aWRlb1wiIG9yIFwiYXVkaW9cIi5cbiAgICAgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0TWVkaWFMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSkge1xuICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIHR5cGUpO1xuXG4gICAgICAgIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG4gICAgICAgIC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwic3JjXCI7XG5cbiAgICAgICAgdGhpcy5vbihcImluaXRpYWxpemVcIiwgdGhpcy5fdXBkYXRlWEhSLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgdmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RNZWRpYUxvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXG4gICAgLy8gc3RhdGljIHByb3BlcnRpZXNcbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGFnUmVxdWVzdCB3aWxsIGhhbmRsZSBtb3N0IG9mIHRoaXMsIGJ1dCBTb3VuZCAvIFZpZGVvIG5lZWQgYSBmZXcgY3VzdG9tIHByb3BlcnRpZXMsIHNvIGp1c3QgaGFuZGxlIHRoZW0gaGVyZS5cbiAgICAgICAgaWYgKCF0aGlzLl90YWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhZyA9IHRoaXMuX2NyZWF0ZVRhZyh0aGlzLl9pdGVtLnNyYyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90YWcucHJlbG9hZCA9IFwiYXV0b1wiO1xuICAgICAgICB0aGlzLl90YWcubG9hZCgpO1xuXG4gICAgICAgIHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuICAgIH07XG5cbiAgICAvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGFnIGZvciBsb2FkaW5nIGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0LlxuICAgICAqIEBtZXRob2QgX2NyZWF0ZVRhZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKCkge307XG5cblxuICAgIHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuTWVkaWFUYWdSZXF1ZXN0KHRoaXMuX2l0ZW0sIHRoaXMuX3RhZyB8fCB0aGlzLl9jcmVhdGVUYWcoKSwgdGhpcy5fdGFnU3JjQXR0cmlidXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuWEhSUmVxdWVzdCh0aGlzLl9pdGVtKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIEJlZm9yZSB0aGUgaXRlbSBsb2Fkcywgc2V0IGl0cyBtaW1lVHlwZSBhbmQgcmVzcG9uc2VUeXBlLlxuICAgICAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX3VwZGF0ZVhIUiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBPbmx5IGV4aXN0cyBmb3IgWEhSXG4gICAgICAgIGlmIChldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYmxvYlwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgbWVkaWEgZmlsZXMuXG4gICAgICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG4gICAgICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG4gICAgICogQHJldHVybnMge0hUTUxWaWRlb0VsZW1lbnR8SFRNTEF1ZGlvRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9sb2FkZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fdGFnLm9uc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcbiAgICAgICAgICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblxuICAgICAgICAgICAgbG9hZGVyLmdldFRhZygpLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9hZGVyLmdldFRhZygpO1xuICAgIH07XG5cbiAgICBjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdE1lZGlhTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8qKlxuICAgICAqIEEgYmFzZSBjbGFzcyBmb3IgYWN0dWFsIGRhdGEgcmVxdWVzdHMsIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiWEhSUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiVGFnUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSxcbiAgICAgKiBhbmQge3sjY3Jvc3NMaW5rIFwiTWVkaWFSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBQcmVsb2FkSlMgbG9hZGVycyB3aWxsIHR5cGljYWxseSB1c2UgYSBkYXRhIGxvYWRlciB1bmRlciB0aGVcbiAgICAgKiBob29kIHRvIGdldCBkYXRhLlxuICAgICAqIEBjbGFzcyBBYnN0cmFjdFJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfSBpdGVtXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0UmVxdWVzdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMuX2l0ZW0gPSBpdGVtO1xuICAgIH07XG5cbiAgICB2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBYnN0cmFjdFJlcXVlc3QsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIEJlZ2luIGEgbG9hZC5cbiAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgKi9cbiAgICBwLmxvYWQgPSAgZnVuY3Rpb24oKSB7fTtcblxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIGEgcmVxdWVzdC5cbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGFuIGluLXByb2dyZXNzIHJlcXVlc3QuXG4gICAgICogQG1ldGhvZCBjYW5jZWxcbiAgICAgKi9cbiAgICBwLmNhbmNlbCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICBjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0UmVxdWVzdCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUYWdSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgLyoqXG4gICAgICogQW4ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgbG9hZHMgSFRNTCB0YWdzLCBzdWNoIGFzIGltYWdlcyBhbmQgc2NyaXB0cy5cbiAgICAgKiBAY2xhc3MgVGFnUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW19IGxvYWRJdGVtXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyY0F0dHJpYnV0ZSBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGFnUmVxdWVzdChsb2FkSXRlbSwgdGFnLCBzcmNBdHRyaWJ1dGUpIHtcbiAgICAgICAgdGhpcy5BYnN0cmFjdFJlcXVlc3RfY29uc3RydWN0b3IobG9hZEl0ZW0pO1xuXG4gICAgICAgIC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSFRNTCB0YWcgaW5zdGFuY2UgdGhhdCBpcyB1c2VkIHRvIGxvYWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdGFnXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGFnID0gdGFnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfdGFnU3JjQXR0cmlidXRlXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IHNyY0F0dHJpYnV0ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBtZXRob2QgY2xvc3VyZSB1c2VkIGZvciBoYW5kbGluZyB0aGUgdGFnIGxvYWQgZXZlbnQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfbG9hZGVkSGFuZGxlclxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnQ29tcGxldGUsIHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBlbGVtZW50IHdhcyBhZGRlZCB0byB0aGUgRE9NIGF1dG9tYXRpY2FsbHkgYnkgUHJlbG9hZEpTLCBzbyBpdCBjYW4gYmUgY2xlYW5lZCB1cCBhZnRlci5cbiAgICAgICAgICogQHByb3BlcnR5IF9hZGRlZFRvRE9NXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWRkZWRUb0RPTSA9IGZhbHNlO1xuXG4gICAgfTtcblxuICAgIHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRhZ1JlcXVlc3QsIGNyZWF0ZWpzLkFic3RyYWN0UmVxdWVzdCk7XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFnLm9ubG9hZCA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UsIHRoaXMpO1xuICAgICAgICB0aGlzLl90YWcub25lcnJvciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblxuICAgICAgICB2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiaW5pdGlhbGl6ZVwiKTtcbiAgICAgICAgZXZ0LmxvYWRlciA9IHRoaXMuX3RhZztcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgICB0aGlzLl9sb2FkVGltZW91dCA9IHNldFRpbWVvdXQoY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGltZW91dCwgdGhpcyksIHRoaXMuX2l0ZW0ubG9hZFRpbWVvdXQpO1xuXG4gICAgICAgIHRoaXMuX3RhZ1t0aGlzLl90YWdTcmNBdHRyaWJ1dGVdID0gdGhpcy5faXRlbS5zcmM7XG5cbiAgICAgICAgLy8gd2RnOjogQXBwZW5kIHRoZSB0YWcgQUZURVIgc2V0dGluZyB0aGUgc3JjLCBvciBTVkcgbG9hZGluZyBvbiBpT1Mgd2lsbCBmYWlsLlxuICAgICAgICBpZiAodGhpcy5fdGFnLnBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY3JlYXRlanMuRG9tVXRpbHMuYXBwZW5kVG9Cb2R5KHRoaXMuX3RhZyk7XG4gICAgICAgICAgICB0aGlzLl9hZGRlZFRvRE9NID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgICAgdGhpcy5fdGFnID0gbnVsbDtcblxuICAgICAgICB0aGlzLkFic3RyYWN0UmVxdWVzdF9kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgcmVhZHlTdGF0ZUNoYW5nZSBldmVudCBmcm9tIGEgdGFnLiBXZSBuZWVkIHRoaXMgaW4gcGxhY2Ugb2YgdGhlIGBvbmxvYWRgIGNhbGxiYWNrIChtYWlubHkgU0NSSVBUXG4gICAgICogYW5kIExJTksgdGFncyksIGJ1dCBvdGhlciBjYXNlcyBtYXkgZXhpc3QuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcbiAgICAgICAgLy8gVGhpcyBpcyBzdHJpY3RseSBmb3IgdGFncyBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IG9ubG9hZC5cbiAgICAgICAgdmFyIHRhZyA9IHRoaXMuX3RhZztcblxuICAgICAgICAvLyBDb21wbGV0ZSBpcyBmb3Igb2xkIElFIHN1cHBvcnQuXG4gICAgICAgIGlmICh0YWcucmVhZHlTdGF0ZSA9PSBcImxvYWRlZFwiIHx8IHRhZy5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlVGFnQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW55IGVycm9yIGV2ZW50cyBmcm9tIHRoZSB0YWcuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlRXJyb3JcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiZXJyb3JcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgdGFnJ3Mgb25sb2FkIGNhbGxiYWNrLlxuICAgICAqIEBtZXRob2QgX2hhbmRsZVRhZ0NvbXBsZXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVUYWdDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmF3UmVzdWx0ID0gdGhpcy5fdGFnO1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSB0aGlzLnJlc3VsdEZvcm1hdHRlciAmJiB0aGlzLnJlc3VsdEZvcm1hdHRlcih0aGlzKSB8fCB0aGlzLl9yYXdSZXN1bHQ7XG5cbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRhZyByZXF1ZXN0IGhhcyBub3QgbG9hZGVkIHdpdGhpbiB0aGUgdGltZSBzcGVjaWZpZWQgaW4gbG9hZFRpbWVvdXQuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlRXJyb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBlcnJvciBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aW1lb3V0XCIpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycywgYnV0IGRvbid0IGRlc3Ryb3kgdGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAgICogQG1ldGhvZCBfY2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2NsZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RhZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl90YWcub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGFnLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fYWRkZWRUb0RPTSAmJiB0aGlzLl90YWcucGFyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl90YWcpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIHN0YWxsZWQgYXVkaW8gZXZlbnQuIFRoZSBtYWluIHBsYWNlIHRoaXMgaGFwcGVucyBpcyB3aXRoIEhUTUxBdWRpbyBpbiBDaHJvbWUgd2hlbiBwbGF5aW5nIGJhY2sgYXVkaW9cbiAgICAgKiB0aGF0IGlzIGFscmVhZHkgaW4gYSBsb2FkLCBidXQgbm90IGNvbXBsZXRlLlxuICAgICAqIEBtZXRob2QgX2hhbmRsZVN0YWxsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2hhbmRsZVN0YWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vSWdub3JlLCBsZXQgdGhlIHRpbWVvdXQgdGFrZSBjYXJlIG9mIGl0LiBTb21ldGltZXMgaXRzIG5vdCByZWFsbHkgc3RvcHBlZC5cbiAgICB9O1xuXG4gICAgY3JlYXRlanMuVGFnUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoVGFnUmVxdWVzdCwgXCJBYnN0cmFjdFJlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNZWRpYVRhZ1JlcXVlc3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gY29uc3RydWN0b3JcbiAgICAvKipcbiAgICAgKiBBbiB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgbG9hZHMgSFRNTCB0YWdzIGZvciB2aWRlbyBhbmQgYXVkaW8uXG4gICAgICogQGNsYXNzIE1lZGlhVGFnUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW19IGxvYWRJdGVtXG4gICAgICogQHBhcmFtIHtIVE1MQXVkaW9FbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHRhZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNBdHRyaWJ1dGUgVGhlIHRhZyBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgdGhlIHNvdXJjZSwgc3VjaCBhcyBcInNyY1wiLCBcImhyZWZcIiwgZXRjLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lZGlhVGFnUmVxdWVzdChsb2FkSXRlbSwgdGFnLCBzcmNBdHRyaWJ1dGUpIHtcbiAgICAgICAgdGhpcy5BYnN0cmFjdFJlcXVlc3RfY29uc3RydWN0b3IobG9hZEl0ZW0pO1xuXG4gICAgICAgIC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuX3RhZyA9IHRhZztcbiAgICAgICAgdGhpcy5fdGFnU3JjQXR0cmlidXRlID0gc3JjQXR0cmlidXRlO1xuICAgICAgICB0aGlzLl9sb2FkZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnQ29tcGxldGUsIHRoaXMpO1xuICAgIH07XG5cbiAgICB2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNZWRpYVRhZ1JlcXVlc3QsIGNyZWF0ZWpzLlRhZ1JlcXVlc3QpO1xuICAgIHZhciBzID0gTWVkaWFUYWdSZXF1ZXN0O1xuXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICBwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzYyA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVN0YWxsZWQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9zdGFsbGVkQ2FsbGJhY2sgPSBzYztcblxuICAgICAgICB2YXIgcGMgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZVByb2dyZXNzID0gcGM7XG5cbiAgICAgICAgdGhpcy5fdGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGFsbGVkXCIsIHNjKTtcbiAgICAgICAgdGhpcy5fdGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBwYyk7XG5cbiAgICAgICAgLy8gVGhpcyB3aWxsIHRlbGwgdXMgd2hlbiBhdWRpbyBpcyBidWZmZXJlZCBlbm91Z2ggdG8gcGxheSB0aHJvdWdoLCBidXQgbm90IHdoZW4gaXRzIGxvYWRlZC5cbiAgICAgICAgLy8gVGhlIHRhZyBkb2Vzbid0IGtlZXAgbG9hZGluZyBpbiBDaHJvbWUgb25jZSBlbm91Z2ggaGFzIGJ1ZmZlcmVkLCBhbmQgd2UgaGF2ZSBkZWNpZGVkIHRoYXQgYmVoYXZpb3VyIGlzIHN1ZmZpY2llbnQuXG4gICAgICAgIHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyICYmIHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fbG9hZGVkSGFuZGxlciwgZmFsc2UpOyAvLyBjYW5wbGF5dGhyb3VnaCBjYWxsYmFjayBkb2Vzbid0IHdvcmsgaW4gQ2hyb21lLCBzbyB3ZSB1c2UgYW4gZXZlbnQuXG5cbiAgICAgICAgdGhpcy5UYWdSZXF1ZXN0X2xvYWQoKTtcbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgcC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcbiAgICAgICAgLy8gVGhpcyBpcyBzdHJpY3RseSBmb3IgdGFncyBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IG9ubG9hZC5cbiAgICAgICAgdmFyIHRhZyA9IHRoaXMuX3RhZztcblxuICAgICAgICAvLyBDb21wbGV0ZSBpcyBmb3Igb2xkIElFIHN1cHBvcnQuXG4gICAgICAgIGlmICh0YWcucmVhZHlTdGF0ZSA9PSBcImxvYWRlZFwiIHx8IHRhZy5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlVGFnQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwLl9oYW5kbGVTdGFsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvL0lnbm9yZSwgbGV0IHRoZSB0aW1lb3V0IHRha2UgY2FyZSBvZiBpdC4gU29tZXRpbWVzIGl0cyBub3QgcmVhbGx5IHN0b3BwZWQuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFuIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBwcm9ncmVzcy5cbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVQcm9ncmVzc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHByb2dyZXNzIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudCB8fCBldmVudC5sb2FkZWQgPiAwICYmIGV2ZW50LnRvdGFsID09IDApIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gU29tZXRpbWVzIHdlIGdldCBubyBcInRvdGFsXCIsIHNvIGp1c3QgaWdub3JlIHRoZSBwcm9ncmVzcyBldmVudC5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KGV2ZW50LmxvYWRlZCwgZXZlbnQudG90YWwpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIH07XG5cbiAgICAvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuICAgIHAuX2NsZWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YWxsZWRcIiwgdGhpcy5fc3RhbGxlZENhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCB0aGlzLl9wcm9ncmVzc0NhbGxiYWNrKTtcblxuICAgICAgICB0aGlzLlRhZ1JlcXVlc3RfX2NsZWFuKCk7XG4gICAgfTtcblxuICAgIGNyZWF0ZWpzLk1lZGlhVGFnUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoTWVkaWFUYWdSZXF1ZXN0LCBcIlRhZ1JlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYSFJSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3JcbiAgICAvKipcbiAgICAgKiBBIHByZWxvYWRlciB0aGF0IGxvYWRzIGl0ZW1zIHVzaW5nIFhIUiByZXF1ZXN0cywgdXN1YWxseSBYTUxIdHRwUmVxdWVzdC4gSG93ZXZlciBYRG9tYWluUmVxdWVzdHMgd2lsbCBiZSB1c2VkXG4gICAgICogZm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cyBpZiBwb3NzaWJsZSwgYW5kIG9sZGVyIHZlcnNpb25zIG9mIElFIGZhbGwgYmFjayBvbiB0byBBY3RpdmVYIG9iamVjdHMgd2hlbiBuZWNlc3NhcnkuXG4gICAgICogWEhSIHJlcXVlc3RzIGxvYWQgdGhlIGNvbnRlbnQgYXMgdGV4dCBvciBiaW5hcnkgZGF0YSwgcHJvdmlkZSBwcm9ncmVzcyBhbmQgY29uc2lzdGVudCBjb21wbGV0aW9uIGV2ZW50cywgYW5kXG4gICAgICogY2FuIGJlIGNhbmNlbGVkIGR1cmluZyBsb2FkLiBOb3RlIHRoYXQgWEhSIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUgNiBvciBlYXJsaWVyLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvclxuICAgICAqIGNyb3NzLWRvbWFpbiBsb2FkaW5nLlxuICAgICAqIEBjbGFzcyBYSFJSZXF1ZXN0XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGZpbGUgdG8gbG9hZC4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogZm9yIGFuIG92ZXJ2aWV3IG9mIHN1cHBvcnRlZCBmaWxlIHByb3BlcnRpZXMuXG4gICAgICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBYSFJSZXF1ZXN0IChpdGVtKSB7XG4gICAgICAgIHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2NvbnN0cnVjdG9yKGl0ZW0pO1xuXG4gICAgICAgIC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgWEhSIHJlcXVlc3QgdXNlZCB0byBsb2FkIHRoZSBjb250ZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgX3JlcXVlc3RcbiAgICAgICAgICogQHR5cGUge1hNTEh0dHBSZXF1ZXN0IHwgWERvbWFpblJlcXVlc3QgfCBBY3RpdmVYLlhNTEhUVFB9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYW51YWwgbG9hZCB0aW1lb3V0IHRoYXQgaXMgdXNlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB0aGUgb25UaW1lb3V0IGV2ZW50IG9uIFhIUiAoWEhSIGxldmVsIDEsXG4gICAgICAgICAqIHR5cGljYWxseSBJRTkpLlxuICAgICAgICAgKiBAcHJvcGVydHkgX2xvYWRUaW1lb3V0XG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkVGltZW91dCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBicm93c2VyJ3MgWEhSIChYTUxIVFRQUmVxdWVzdCkgdmVyc2lvbi4gU3VwcG9ydGVkIHZlcnNpb25zIGFyZSAxIGFuZCAyLiBUaGVyZSBpcyBubyBvZmZpY2lhbCB3YXkgdG8gZGV0ZWN0XG4gICAgICAgICAqIHRoZSB2ZXJzaW9uLCBzbyB3ZSB1c2UgY2FwYWJpbGl0aWVzIHRvIG1ha2UgYSBiZXN0IGd1ZXNzLlxuICAgICAgICAgKiBAcHJvcGVydHkgX3hockxldmVsXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3hockxldmVsID0gMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlc3BvbnNlIG9mIGEgbG9hZGVkIGZpbGUuIFRoaXMgaXMgc2V0IGJlY2F1c2UgaXQgaXMgZXhwZW5zaXZlIHRvIGxvb2sgdXAgY29uc3RhbnRseS4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlXG4gICAgICAgICAqIG51bGwgdW50aWwgdGhlIGZpbGUgaXMgbG9hZGVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgX3Jlc3BvbnNlXG4gICAgICAgICAqIEB0eXBlIHttaXhlZH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlc3BvbnNlIG9mIHRoZSBsb2FkZWQgZmlsZSBiZWZvcmUgaXQgaXMgbW9kaWZpZWQuIEluIG1vc3QgY2FzZXMsIGNvbnRlbnQgaXMgY29udmVydGVkIGZyb20gcmF3IHRleHQgdG9cbiAgICAgICAgICogYW4gSFRNTCB0YWcgb3IgYSBmb3JtYXR0ZWQgb2JqZWN0IHdoaWNoIGlzIHNldCB0byB0aGUgPGNvZGU+cmVzdWx0PC9jb2RlPiBwcm9wZXJ0eSwgYnV0IHRoZSBkZXZlbG9wZXIgbWF5IHN0aWxsXG4gICAgICAgICAqIHdhbnQgdG8gYWNjZXNzIHRoZSByYXcgY29udGVudCBhcyBpdCB3YXMgbG9hZGVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgX3Jhd1Jlc3BvbnNlXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd8T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmF3UmVzcG9uc2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2V0dXAgb3VyIGV2ZW50IGhhbmRsZXJzIG5vdy5cbiAgICAgICAgdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkU3RhcnQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUHJvZ3Jlc3MsIHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVBYm9ydFByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlQWJvcnQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVFcnJvclByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlRXJyb3IsIHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZGxlTG9hZFByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5fY3JlYXRlWEhSKGl0ZW0pKSB7XG4gICAgICAgICAgICAvL1RPRE86IFRocm93IGVycm9yP1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFhIUlJlcXVlc3QsIGNyZWF0ZWpzLkFic3RyYWN0UmVxdWVzdCk7XG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIFhNTEhUVFAgb2JqZWN0IElEcyB0byB0cnkgd2hlbiBidWlsZGluZyBhbiBBY3RpdmVYIG9iamVjdCBmb3IgWEhSIHJlcXVlc3RzIGluIGVhcmxpZXIgdmVyc2lvbnMgb2YgSUUuXG4gICAgICogQHByb3BlcnR5IEFDVElWRVhfVkVSU0lPTlNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQHNpbmNlIDAuNC4yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBYSFJSZXF1ZXN0LkFDVElWRVhfVkVSU0lPTlMgPSBbXG4gICAgICAgIFwiTXN4bWwyLlhNTEhUVFAuNi4wXCIsXG4gICAgICAgIFwiTXN4bWwyLlhNTEhUVFAuNS4wXCIsXG4gICAgICAgIFwiTXN4bWwyLlhNTEhUVFAuNC4wXCIsXG4gICAgICAgIFwiTVNYTUwyLlhNTEhUVFAuMy4wXCIsXG4gICAgICAgIFwiTVNYTUwyLlhNTEhUVFBcIixcbiAgICAgICAgXCJNaWNyb3NvZnQuWE1MSFRUUFwiXG4gICAgXTtcblxuLy8gUHVibGljIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBMb29rIHVwIHRoZSBsb2FkZWQgcmVzdWx0LlxuICAgICAqIEBtZXRob2QgZ2V0UmVzdWx0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmF3PWZhbHNlXSBSZXR1cm4gYSByYXcgcmVzdWx0IGluc3RlYWQgb2YgYSBmb3JtYXR0ZWQgcmVzdWx0LiBUaGlzIGFwcGxpZXMgdG8gY29udGVudFxuICAgICAqIGxvYWRlZCB2aWEgWEhSIHN1Y2ggYXMgc2NyaXB0cywgWE1MLCBDU1MsIGFuZCBJbWFnZXMuIElmIHRoZXJlIGlzIG5vIHJhdyByZXN1bHQsIHRoZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZCBpbnN0ZWFkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkLCBzdWNoIGFzOlxuICAgICAqIDx1bD5cbiAgICAgKiAgICAgIDxsaT5BbiBpbWFnZSB0YWcgKCZsdDtpbWFnZSAvJmd0OykgZm9yIGltYWdlczwvbGk+XG4gICAgICogICAgICA8bGk+QSBzY3JpcHQgdGFnIGZvciBKYXZhU2NyaXB0ICgmbHQ7c2NyaXB0IC8mZ3Q7KS4gTm90ZSB0aGF0IHNjcmlwdHMgbG9hZGVkIHdpdGggdGFncyBtYXkgYmUgYWRkZWQgdG8gdGhlXG4gICAgICogICAgICBIVE1MIGhlYWQuPC9saT5cbiAgICAgKiAgICAgIDxsaT5BIHN0eWxlIHRhZyBmb3IgQ1NTICgmbHQ7c3R5bGUgLyZndDspPC9saT5cbiAgICAgKiAgICAgIDxsaT5SYXcgdGV4dCBmb3IgVEVYVDwvbGk+XG4gICAgICogICAgICA8bGk+QSBmb3JtYXR0ZWQgSmF2YVNjcmlwdCBvYmplY3QgZGVmaW5lZCBieSBKU09OPC9saT5cbiAgICAgKiAgICAgIDxsaT5BbiBYTUwgZG9jdW1lbnQ8L2xpPlxuICAgICAqICAgICAgPGxpPkFuIGJpbmFyeSBhcnJheWJ1ZmZlciBsb2FkZWQgYnkgWEhSPC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqIE5vdGUgdGhhdCBpZiBhIHJhdyByZXN1bHQgaXMgcmVxdWVzdGVkLCBidXQgbm90IGZvdW5kLCB0aGUgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBwLmdldFJlc3VsdCA9IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgaWYgKHJhdyAmJiB0aGlzLl9yYXdSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jhd1Jlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGVzIGFic3RyYWN0IG1ldGhvZCBpbiBBYnN0cmFjdFJlcXVlc3RcbiAgICBwLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGVzIGFic3RyYWN0IG1ldGhvZCBpbiBBYnN0cmFjdExvYWRlclxuICAgIHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vRXZlbnRzXG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZHN0YXJ0XCIsIHRoaXMuX2hhbmRsZUxvYWRTdGFydFByb3h5LCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5LCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0aGlzLl9oYW5kbGVBYm9ydFByb3h5LCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVFcnJvclByb3h5LCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCBnZXQgb25sb2FkIGluIGFsbCBicm93c2VycyAoZWFybGllciBGRiBhbmQgSUUpLiBvblJlYWR5U3RhdGVDaGFuZ2UgaGFuZGxlcyB0aGVzZS5cbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5faGFuZGxlTG9hZFByb3h5LCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSUU5IHN1cHBvcnRcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3Qub25sb2Fkc3RhcnQgPSB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0Lm9uYWJvcnQgPSB0aGlzLl9oYW5kbGVBYm9ydFByb3h5O1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdC5vbmVycm9yID0gdGhpcy5faGFuZGxlRXJyb3JQcm94eTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3Qub250aW1lb3V0ID0gdGhpcy5faGFuZGxlVGltZW91dFByb3h5O1xuXG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCBnZXQgb25sb2FkIGluIGFsbCBicm93c2VycyAoZWFybGllciBGRiBhbmQgSUUpLiBvblJlYWR5U3RhdGVDaGFuZ2UgaGFuZGxlcyB0aGVzZS5cbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3Qub25sb2FkID0gdGhpcy5faGFuZGxlTG9hZFByb3h5O1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdXAgYSB0aW1lb3V0IGlmIHdlIGRvbid0IGhhdmUgWEhSMlxuICAgICAgICBpZiAodGhpcy5feGhyTGV2ZWwgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aW1lcyB3ZSBnZXQgYmFjayA0MDRzIGltbWVkaWF0ZWx5LCBwYXJ0aWN1bGFybHkgd2hlbiB0aGVyZSBpcyBhIGNyb3NzIG9yaWdpbiByZXF1ZXN0LiAgLy8gbm90ZSB0aGlzIGRvZXMgbm90IGNhdGNoIGluIENocm9tZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pdGVtLnZhbHVlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LnNlbmQoY3JlYXRlanMuVVJMVXRpbHMuZm9ybWF0UXVlcnlTdHJpbmcodGhpcy5faXRlbS52YWx1ZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlhIUl9TRU5EXCIsIG51bGwsIGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcC5zZXRSZXNwb25zZVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAvLyBTb21lIG9sZCBicm93c2VycyBkb2Vzbid0IHN1cHBvcnQgYmxvYiwgc28gd2UgY29udmVydCBhcnJheWJ1ZmZlciB0byBibG9iIGFmdGVyIHJlc3BvbnNlIGlzIGRvd25sb2FkZWRcbiAgICAgICAgaWYgKHR5cGUgPT09ICdibG9iJykge1xuICAgICAgICAgICAgdHlwZSA9IHdpbmRvdy5VUkwgPyAnYmxvYicgOiAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VUeXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHR5cGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIHJlc3BvbnNlIGhlYWRlcnMgZnJvbSB0aGUgWG1sSHR0cFJlcXVlc3QuXG4gICAgICpcbiAgICAgKiA8c3Ryb25nPkZyb20gdGhlIGRvY3M6PC9zdHJvbmc+IFJldHVybiBhbGwgdGhlIEhUVFAgaGVhZGVycywgZXhjbHVkaW5nIGhlYWRlcnMgdGhhdCBhcmUgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoXG4gICAgICogZm9yIFNldC1Db29raWUgb3IgU2V0LUNvb2tpZTIsIGFzIGEgc2luZ2xlIHN0cmluZywgd2l0aCBlYWNoIGhlYWRlciBsaW5lIHNlcGFyYXRlZCBieSBhIFUrMDAwRCBDUiBVKzAwMEEgTEYgcGFpcixcbiAgICAgKiBleGNsdWRpbmcgdGhlIHN0YXR1cyBsaW5lLCBhbmQgd2l0aCBlYWNoIGhlYWRlciBuYW1lIGFuZCBoZWFkZXIgdmFsdWUgc2VwYXJhdGVkIGJ5IGEgVSswMDNBIENPTE9OIFUrMDAyMCBTUEFDRVxuICAgICAqIHBhaXIuXG4gICAgICogQG1ldGhvZCBnZXRBbGxSZXNwb25zZUhlYWRlcnNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHNpbmNlIDAuNC4xXG4gICAgICovXG4gICAgcC5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIHJlc3BvbnNlIGhlYWRlciBmcm9tIHRoZSBYbWxIdHRwUmVxdWVzdC5cbiAgICAgKlxuICAgICAqIDxzdHJvbmc+RnJvbSB0aGUgZG9jczo8L3N0cm9uZz4gUmV0dXJucyB0aGUgaGVhZGVyIGZpZWxkIHZhbHVlIGZyb20gdGhlIHJlc3BvbnNlIG9mIHdoaWNoIHRoZSBmaWVsZCBuYW1lIG1hdGNoZXNcbiAgICAgKiBoZWFkZXIsIHVubGVzcyB0aGUgZmllbGQgbmFtZSBpcyBTZXQtQ29va2llIG9yIFNldC1Db29raWUyLlxuICAgICAqIEBtZXRob2QgZ2V0UmVzcG9uc2VIZWFkZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBoZWFkZXIgbmFtZSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHNpbmNlIDAuNC4xXG4gICAgICovXG4gICAgcC5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuLy8gcHJvdGVjdGVkIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIHByb2dyZXNzLlxuICAgICAqIEBtZXRob2QgX2hhbmRsZVByb2dyZXNzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgcHJvZ3Jlc3MgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50IHx8IGV2ZW50LmxvYWRlZCA+IDAgJiYgZXZlbnQudG90YWwgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBTb21ldGltZXMgd2UgZ2V0IG5vIFwidG90YWxcIiwgc28ganVzdCBpZ25vcmUgdGhlIHByb2dyZXNzIGV2ZW50LlxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQoZXZlbnQubG9hZGVkLCBldmVudC50b3RhbCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYSBsb2FkIHN0YXJ0LlxuICAgICAqIEBtZXRob2QgX2hhbmRsZUxvYWRTdGFydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGxvYWRTdGFydCBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2hhbmRsZUxvYWRTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYW4gYWJvcnQgZXZlbnQuXG4gICAgICogQG1ldGhvZCBoYW5kbGVBYm9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGFib3J0IGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5faGFuZGxlQWJvcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiWEhSX0FCT1JURURcIiwgbnVsbCwgZXZlbnQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBhbiBlcnJvciBldmVudC5cbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGVycm9yIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KGV2ZW50Lm1lc3NhZ2UpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBhIHJlYWR5U3RhdGUgY2hhbmdlLiBOb3RlIHRoYXQgb2xkZXIgYnJvd3NlcnMgKElFIDcgJiA4KSBkbyBub3QgcHJvdmlkZSBhbiBvbmxvYWRcbiAgICAgKiBldmVudCwgc28gd2UgbXVzdCBtb25pdG9yIHRoZSByZWFkeVN0YXRlQ2hhbmdlIHRvIGRldGVybWluZSBpZiB0aGUgZmlsZSBpcyBsb2FkZWQuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHJlYWR5U3RhdGVDaGFuZ2UgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0LnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlTG9hZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgY29tcGxldGVkLiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgWEhSIHJlcXVlc3QgZGlyZWN0bHksIG9yIGJ5IGEgcmVhZHlTdGF0ZUNoYW5nZSB0aGF0IGhhc1xuICAgICAqIDxjb2RlPnJlcXVlc3QucmVhZHlTdGF0ZSA9PSA0PC9jb2RlPi4gT25seSB0aGUgZmlyc3QgY2FsbCB0byB0aGlzIG1ldGhvZCB3aWxsIGJlIHByb2Nlc3NlZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBUaGlzIG1ldGhvZCB1c2VzIHt7I2Nyb3NzTGluayBcIl9jaGVja0Vycm9yXCJ9fXt7L2Nyb3NzTGlua319IHRvIGRldGVybWluZSBpZiB0aGUgc2VydmVyIGhhcyByZXR1cm5lZCBhblxuICAgICAqIGVycm9yIGNvZGUuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlTG9hZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGxvYWQgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9jaGVja0Vycm9yKCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVzcG9uc2UgPSB0aGlzLl9nZXRSZXNwb25zZSgpO1xuICAgICAgICAvLyBDb252ZXJ0IGFycmF5YnVmZmVyIGJhY2sgdG8gYmxvYlxuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlID0gbmV3IEJsb2IoW3RoaXMuX3Jlc3BvbnNlXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gdXNlIEJsb2JCdWlsZGVyIGlmIEJsb2IgY29uc3RydWN0b3IgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIC8vIFRlc3RlZCBvbiBBbmRyb2lkIDIuMyB+IDQuMiBhbmQgaU9TNSBzYWZhcmlcbiAgICAgICAgICAgICAgICB3aW5kb3cuQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fCB3aW5kb3cuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgICAgICBpZiAoZS5uYW1lID09PSAnVHlwZUVycm9yJyAmJiB3aW5kb3cuQmxvYkJ1aWxkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hcHBlbmQodGhpcy5fcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZSA9IGJ1aWxkZXIuZ2V0QmxvYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXZlbnQoXCJjb21wbGV0ZVwiKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgdGltZWQgb3V0LiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgWEhSIHJlcXVlc3QgZGlyZWN0bHksIG9yIHZpYSBhIDxjb2RlPnNldFRpbWVvdXQ8L2NvZGU+XG4gICAgICogY2FsbGJhY2suXG4gICAgICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRdIFRoZSBYSFIgdGltZW91dCBldmVudC4gVGhpcyBpcyBvY2Nhc2lvbmFsbHkgbnVsbCB3aGVuIGNhbGxlZCBieSB0aGUgYmFja3VwIHNldFRpbWVvdXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfVElNRU9VVFwiLCBudWxsLCBldmVudCkpO1xuICAgIH07XG5cbi8vIFByb3RlY3RlZFxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgY3VycmVudCBsb2FkLlxuICAgICAqIEN1cnJlbnRseSB0aGlzIGNoZWNrcyB0aGUgc3RhdHVzIG9mIHRoZSByZXF1ZXN0IGZvciBwcm9ibGVtIGNvZGVzLCBhbmQgbm90IGFjdHVhbCByZXNwb25zZSBjb250ZW50OlxuICAgICAqIDx1bD5cbiAgICAgKiAgICAgPGxpPlN0YXR1cyBjb2RlcyBiZXR3ZWVuIDQwMCBhbmQgNTk5IChIVFRQIGVycm9yIHJhbmdlKTwvbGk+XG4gICAgICogICAgIDxsaT5BIHN0YXR1cyBvZiAwLCBidXQgKm9ubHkgd2hlbiB0aGUgYXBwbGljYXRpb24gaXMgcnVubmluZyBvbiBhIHNlcnZlciouIElmIHRoZSBhcHBsaWNhdGlvbiBpcyBydW5uaW5nXG4gICAgICogICAgIG9uIGBmaWxlOmAsIHRoZW4gaXQgbWF5IGluY29ycmVjdGx5IHRyZWF0IGFuIGVycm9yIG9uIGxvY2FsIChvciBlbWJlZGRlZCBhcHBsaWNhdGlvbnMpIGFzIGEgc3VjY2Vzc2Z1bFxuICAgICAqICAgICBsb2FkLjwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKiBAbWV0aG9kIF9jaGVja0Vycm9yXG4gICAgICogQHJldHVybiB7RXJyb3J9IEFuIGVycm9yIHdpdGggdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBgbWVzc2FnZWAgYXJndW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9jaGVja0Vycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gcGFyc2VJbnQodGhpcy5fcmVxdWVzdC5zdGF0dXMpO1xuICAgICAgICBpZiAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPD0gNTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKHN0YXR1cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09IDApIHtcbiAgICAgICAgICAgIGlmICgoL15odHRwcz86LykudGVzdChsb2NhdGlvbi5wcm90b2NvbCkpIHsgcmV0dXJuIG5ldyBFcnJvcigwKTsgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIExpa2VseSBhbiBlbWJlZGRlZCBhcHAuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSByZXNwb25zZS4gRGlmZmVyZW50IGJyb3dzZXJzIGhhdmUgZGlmZmVyZW50IGFwcHJvYWNoZXMsIHNvbWUgb2Ygd2hpY2ggdGhyb3cgZXJyb3JzIHdoZW4gYWNjZXNzZWRcbiAgICAgKiBpbiBvdGhlciBicm93c2Vycy4gSWYgdGhlcmUgaXMgbm8gcmVzcG9uc2UsIHRoZSA8Y29kZT5fcmVzcG9uc2U8L2NvZGU+IHByb3BlcnR5IHdpbGwgcmVtYWluIG51bGwuXG4gICAgICogQG1ldGhvZCBfZ2V0UmVzcG9uc2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2dldFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QucmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmRyb2lkIDIuMiB1c2VzIC5yZXNwb25zZVRleHRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGVuIGxvYWRpbmcgWE1MLCBJRTkgZG9lcyBub3QgcmV0dXJuIC5yZXNwb25zZSwgaW5zdGVhZCBpdCByZXR1cm5zIHJlc3BvbnNlWE1MLnhtbFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2VYTUwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlWE1MO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIFhIUiByZXF1ZXN0LiBEZXBlbmRpbmcgb24gYSBudW1iZXIgb2YgZmFjdG9ycywgd2UgZ2V0IHRvdGFsbHkgZGlmZmVyZW50IHJlc3VsdHMuXG4gICAgICogPG9sPjxsaT5Tb21lIGJyb3dzZXJzIGdldCBhbiA8Y29kZT5YRG9tYWluUmVxdWVzdDwvY29kZT4gd2hlbiBsb2FkaW5nIGNyb3NzLWRvbWFpbi48L2xpPlxuICAgICAqICAgICAgPGxpPlhNTEh0dHBSZXF1ZXN0IGFyZSBjcmVhdGVkIHdoZW4gYXZhaWxhYmxlLjwvbGk+XG4gICAgICogICAgICA8bGk+QWN0aXZlWC5YTUxIVFRQIG9iamVjdHMgYXJlIHVzZWQgaW4gb2xkZXIgSUUgYnJvd3NlcnMuPC9saT5cbiAgICAgKiAgICAgIDxsaT5UZXh0IHJlcXVlc3RzIG92ZXJyaWRlIHRoZSBtaW1lIHR5cGUgaWYgcG9zc2libGU8L2xpPlxuICAgICAqICAgICAgPGxpPk9yaWdpbiBoZWFkZXJzIGFyZSBzZW50IGZvciBjcm9zc2RvbWFpbiByZXF1ZXN0cyBpbiBzb21lIGJyb3dzZXJzLjwvbGk+XG4gICAgICogICAgICA8bGk+QmluYXJ5IGxvYWRzIHNldCB0aGUgcmVzcG9uc2UgdHlwZSB0byBcImFycmF5YnVmZmVyXCI8L2xpPjwvb2w+XG4gICAgICogQG1ldGhvZCBfY3JlYXRlWEhSXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIHJlcXVlc3RlZCBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IElmIGFuIFhIUiByZXF1ZXN0IG9yIGVxdWl2YWxlbnQgd2FzIHN1Y2Nlc3NmdWxseSBjcmVhdGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5fY3JlYXRlWEhSID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNyb3NzLWRvbWFpbiBsb2Fkcy4gV2UgY2FuJ3QgZnVsbHkgc3VwcG9ydCB0aGVtLCBidXQgd2UgY2FuIHRyeS5cbiAgICAgICAgdmFyIGNyb3NzZG9tYWluID0gY3JlYXRlanMuVVJMVXRpbHMuaXNDcm9zc0RvbWFpbihpdGVtKTtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHJlcXVlc3QuIEZhbGxiYWNrIHRvIHdoYXRldmVyIHN1cHBvcnQgd2UgaGF2ZS5cbiAgICAgICAgdmFyIHJlcSA9IG51bGw7XG4gICAgICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyA4IG9yIDksIHNvIHVzZSBYRG9tYWluUmVxdWVzdCBpbnN0ZWFkLlxuICAgICAgICAgICAgaWYgKGNyb3NzZG9tYWluICYmIHJlcS53aXRoQ3JlZGVudGlhbHMgPT09IHVuZGVmaW5lZCAmJiB3aW5kb3cuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXEgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gT2xkIElFIHZlcnNpb25zIHVzZSBhIGRpZmZlcmVudCBhcHByb2FjaFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzLkFDVElWRVhfVkVSU0lPTlMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4VmVyc2lvbiA9IHMuQUNUSVZFWF9WRVJTSU9OU1tpXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXEgPSBuZXcgQWN0aXZlWE9iamVjdChheFZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byB1dGYtOCBmb3IgVGV4dCByZXF1ZXN0cy5cbiAgICAgICAgaWYgKGl0ZW0ubWltZVR5cGUgPT0gbnVsbCAmJiBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNUZXh0KGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICAgIGl0ZW0ubWltZVR5cGUgPSBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgb3ZlcnJpZGVNaW1lVHlwZSgpLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBpdC5cbiAgICAgICAgaWYgKGl0ZW0ubWltZVR5cGUgJiYgcmVxLm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgICAgICAgIHJlcS5vdmVycmlkZU1pbWVUeXBlKGl0ZW0ubWltZVR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBYSFIgbGV2ZWxcbiAgICAgICAgdGhpcy5feGhyTGV2ZWwgPSAodHlwZW9mIHJlcS5yZXNwb25zZVR5cGUgPT09IFwic3RyaW5nXCIpID8gMiA6IDE7XG5cbiAgICAgICAgdmFyIHNyYyA9IG51bGw7XG4gICAgICAgIGlmIChpdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5NZXRob2RzLkdFVCkge1xuICAgICAgICAgICAgc3JjID0gY3JlYXRlanMuVVJMVXRpbHMuYnVpbGRVUkkoaXRlbS5zcmMsIGl0ZW0udmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNyYyA9IGl0ZW0uc3JjO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3BlbiB0aGUgcmVxdWVzdC4gIFNldCBjcm9zcy1kb21haW4gZmxhZ3MgaWYgaXQgaXMgc3VwcG9ydGVkIChYSFIgbGV2ZWwgMSBvbmx5KVxuICAgICAgICByZXEub3BlbihpdGVtLm1ldGhvZCB8fCBjcmVhdGVqcy5NZXRob2RzLkdFVCwgc3JjLCB0cnVlKTtcblxuICAgICAgICBpZiAoY3Jvc3Nkb21haW4gJiYgcmVxIGluc3RhbmNlb2YgWE1MSHR0cFJlcXVlc3QgJiYgdGhpcy5feGhyTGV2ZWwgPT0gMSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIk9yaWdpblwiXSA9IGxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvIHNlbmQgZGF0YSB3ZSBuZWVkIHRvIHNldCB0aGUgQ29udGVudC10eXBlIGhlYWRlcilcbiAgICAgICAgaWYgKGl0ZW0udmFsdWVzICYmIGl0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLk1ldGhvZHMuUE9TVCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNyb3NzZG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS5oZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuIGluIGl0ZW0uaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbbl0gPSBpdGVtLmhlYWRlcnNbbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKG4gaW4gaGVhZGVycykge1xuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIobiwgaGVhZGVyc1tuXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXEgaW5zdGFuY2VvZiBYTUxIdHRwUmVxdWVzdCAmJiBpdGVtLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gaXRlbS53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIHJlcXVlc3QgaGFzIGNvbXBsZXRlZCAob3IgZmFpbGVkIG9yIGNhbmNlbGVkKSwgYW5kIG5lZWRzIHRvIGJlIGRpc3Bvc2VkLlxuICAgICAqIEBtZXRob2QgX2NsZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9jbGVhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLCB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5KTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMuX2hhbmRsZUFib3J0UHJveHkpO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlRXJyb3JQcm94eSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMuX2hhbmRsZUxvYWRQcm94eSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3Qub25wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0Lm9uYWJvcnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdC5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3Qub250aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3Qub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbUHJlbG9hZEpTIFhIUlJlcXVlc3RdXCI7XG4gICAgfTtcblxuICAgIGNyZWF0ZWpzLlhIUlJlcXVlc3QgPSBjcmVhdGVqcy5wcm9tb3RlKFhIUlJlcXVlc3QsIFwiQWJzdHJhY3RSZXF1ZXN0XCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTG9hZFF1ZXVlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuLypcbiBUT0RPOiBXSU5ET1dTIElTU1VFU1xuICogTm8gZXJyb3IgZm9yIEhUTUwgYXVkaW8gaW4gSUUgNjc4XG4gKiBTVkcgbm8gZmFpbHVyZSBlcnJvciBpbiBJRSA2NyAobWF5YmUgOCkgVEFHUyBBTkQgWEhSXG4gKiBObyBzY3JpcHQgY29tcGxldGUgaGFuZGxlciBpbiBJRSA2NyBUQUdTIChYSFIgaXMgZmluZSlcbiAqIE5vIFhNTC9KU09OIGluIElFNiBUQUdTXG4gKiBOZWVkIHRvIGhpZGUgbG9hZGluZyBTVkcgaW4gT3BlcmEgVEFHU1xuICogTm8gQ1NTIG9ubG9hZC9yZWFkeXN0YXRlY2hhbmdlIGluIFNhZmFyaSBvciBBbmRyb2lkIFRBR1MgKHJlcXVpcmVzIHJ1bGUgY2hlY2tpbmcpXG4gKiBTVkcgbm8gbG9hZCBvciBmYWlsdXJlIGluIE9wZXJhIFhIUlxuICogUmVwb3J0ZWQgaXNzdWVzIHdpdGggSUU3LzhcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvclxuICAgIC8qKlxuICAgICAqIFRoZSBMb2FkUXVldWUgY2xhc3MgaXMgdGhlIG1haW4gQVBJIGZvciBwcmVsb2FkaW5nIGNvbnRlbnQuIExvYWRRdWV1ZSBpcyBhIGxvYWQgbWFuYWdlciwgd2hpY2ggY2FuIHByZWxvYWQgZWl0aGVyXG4gICAgICogYSBzaW5nbGUgZmlsZSwgb3IgcXVldWUgb2YgZmlsZXMuXG4gICAgICpcbiAgICAgKiA8Yj5DcmVhdGluZyBhIFF1ZXVlPC9iPjxiciAvPlxuICAgICAqIFRvIHVzZSBMb2FkUXVldWUsIGNyZWF0ZSBhIExvYWRRdWV1ZSBpbnN0YW5jZS4gSWYgeW91IHdhbnQgdG8gZm9yY2UgdGFnIGxvYWRpbmcgd2hlcmUgcG9zc2libGUsIHNldCB0aGUgcHJlZmVyWEhSXG4gICAgICogYXJndW1lbnQgdG8gZmFsc2UuXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUodHJ1ZSk7XG4gICAgICpcbiAgICAgKiA8Yj5MaXN0ZW5pbmcgZm9yIEV2ZW50czwvYj48YnIgLz5cbiAgICAgKiBBZGQgYW55IGxpc3RlbmVycyB5b3Ugd2FudCB0byB0aGUgcXVldWUuIFNpbmNlIFByZWxvYWRKUyAwLjMuMCwgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIGxldHMgeW91IGFkZCBhcyBtYW55IGxpc3RlbmVycyBhcyB5b3Ugd2FudCBmb3IgZXZlbnRzLiBZb3UgY2FuIHN1YnNjcmliZSB0byB0aGUgZm9sbG93aW5nIGV2ZW50czo8dWw+XG4gICAgICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fTogZmlyZWQgd2hlbiBhIHF1ZXVlIGNvbXBsZXRlcyBsb2FkaW5nIGFsbFxuICAgICAqICAgICBmaWxlczwvbGk+XG4gICAgICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9lcnJvcjpldmVudFwifX17ey9jcm9zc0xpbmt9fTogZmlyZWQgd2hlbiB0aGUgcXVldWUgZW5jb3VudGVycyBhbiBlcnJvciB3aXRoXG4gICAgICogICAgIGFueSBmaWxlLjwvbGk+XG4gICAgICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9wcm9ncmVzczpldmVudFwifX17ey9jcm9zc0xpbmt9fTogUHJvZ3Jlc3MgZm9yIHRoZSBlbnRpcmUgcXVldWUgaGFzXG4gICAgICogICAgIGNoYW5nZWQuPC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fTogQSBzaW5nbGUgZmlsZSBoYXMgY29tcGxldGVkIGxvYWRpbmcuPC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlcHJvZ3Jlc3M6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IFByb2dyZXNzIGZvciBhIHNpbmdsZSBmaWxlIGhhcyBjaGFuZ2VzLiBOb3RlXG4gICAgICogICAgIHRoYXQgb25seSBmaWxlcyBsb2FkZWQgd2l0aCBYSFIgKG9yIHBvc3NpYmx5IGJ5IHBsdWdpbnMpIHdpbGwgZmlyZSBwcm9ncmVzcyBldmVudHMgb3RoZXIgdGhhbiAwIG9yIDEwMCUuPC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqXG4gICAgICogICAgICBxdWV1ZS5vbihcImZpbGVsb2FkXCIsIGhhbmRsZUZpbGVMb2FkLCB0aGlzKTtcbiAgICAgKiAgICAgIHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUsIHRoaXMpO1xuICAgICAqXG4gICAgICogPGI+QWRkaW5nIGZpbGVzIGFuZCBtYW5pZmVzdHM8L2I+PGJyIC8+XG4gICAgICogQWRkIGZpbGVzIHlvdSB3YW50IHRvIGxvYWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG9yIGFkZCBtdWx0aXBsZSBmaWxlcyBhdCBhXG4gICAgICogdGltZSB1c2luZyBhIGxpc3Qgb3IgYSBtYW5pZmVzdCBkZWZpbml0aW9uIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0uIEZpbGVzIGFyZVxuICAgICAqIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFjdGl2ZSBxdWV1ZSwgc28geW91IGNhbiB1c2UgdGhlc2UgbWV0aG9kcyBhcyBtYW55IHRpbWVzIGFzIHlvdSBsaWtlLCB3aGVuZXZlciB5b3VcbiAgICAgKiBsaWtlLlxuICAgICAqXG4gICAgICogICAgICBxdWV1ZS5sb2FkRmlsZShcImZpbGVQYXRoL2ZpbGUuanBnXCIpO1xuICAgICAqICAgICAgcXVldWUubG9hZEZpbGUoe2lkOlwiaW1hZ2VcIiwgc3JjOlwiZmlsZVBhdGgvZmlsZS5qcGdcIn0pO1xuICAgICAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFtcImZpbGVQYXRoL2ZpbGUuanBnXCIsIHtpZDpcImltYWdlXCIsIHNyYzpcImZpbGVQYXRoL2ZpbGUuanBnXCJ9XSk7XG4gICAgICpcbiAgICAgKiAgICAgIC8vIFVzZSBhbiBleHRlcm5hbCBtYW5pZmVzdFxuICAgICAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFwicGF0aC90by9tYW5pZmVzdC5qc29uXCIpO1xuICAgICAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KHtzcmM6XCJtYW5pZmVzdC5qc29uXCIsIHR5cGU6XCJtYW5pZmVzdFwifSk7XG4gICAgICpcbiAgICAgKiBJZiB5b3UgcGFzcyBgZmFsc2VgIGFzIHRoZSBgbG9hZE5vd2AgcGFyYW1ldGVyLCB0aGUgcXVldWUgd2lsbCBub3Qga2ljayBvZiB0aGUgbG9hZCBvZiB0aGUgZmlsZXMsIGJ1dCBpdCB3aWxsIG5vdFxuICAgICAqIHN0b3AgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkLiBDYWxsIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2FkXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB0byBiZWdpblxuICAgICAqIGEgcGF1c2VkIHF1ZXVlLiBOb3RlIHRoYXQgYSBwYXVzZWQgcXVldWUgd2lsbCBhdXRvbWF0aWNhbGx5IHJlc3VtZSB3aGVuIG5ldyBmaWxlcyBhcmUgYWRkZWQgdG8gaXQgd2l0aCBhXG4gICAgICogYGxvYWROb3dgIGFyZ3VtZW50IG9mIGB0cnVlYC5cbiAgICAgKlxuICAgICAqICAgICAgcXVldWUubG9hZCgpO1xuICAgICAqXG4gICAgICogPGI+RmlsZSBUeXBlczwvYj48YnIgLz5cbiAgICAgKiBUaGUgZmlsZSB0eXBlIG9mIGEgbWFuaWZlc3QgaXRlbSBpcyBhdXRvLWRldGVybWluZWQgYnkgdGhlIGZpbGUgZXh0ZW5zaW9uLiBUaGUgcGF0dGVybiBtYXRjaGluZyBpbiBQcmVsb2FkSlNcbiAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSBtYWpvcml0eSBvZiBzdGFuZGFyZCBmaWxlIGFuZCB1cmwgZm9ybWF0cywgYW5kIHdvcmtzIHdpdGggY29tbW9uIGZpbGUgZXh0ZW5zaW9ucy4gSWYgeW91IGhhdmVcbiAgICAgKiBlaXRoZXIgYSBub24tc3RhbmRhcmQgZmlsZSBleHRlbnNpb24sIG9yIGFyZSBzZXJ2aW5nIHRoZSBmaWxlIHVzaW5nIGEgcHJveHkgc2NyaXB0LCB0aGVuIHlvdSBjYW4gcGFzcyBpbiBhXG4gICAgICogPGNvZGU+dHlwZTwvY29kZT4gcHJvcGVydHkgd2l0aCBhbnkgbWFuaWZlc3QgaXRlbS5cbiAgICAgKlxuICAgICAqICAgICAgcXVldWUubG9hZEZpbGUoe3NyYzpcInBhdGgvdG8vbXlGaWxlLm1wM3hcIiwgdHlwZTpjcmVhdGVqcy5UeXBlcy5TT1VORH0pO1xuICAgICAqXG4gICAgICogICAgICAvLyBOb3RlIHRoYXQgUHJlbG9hZEpTIHdpbGwgbm90IHJlYWQgYSBmaWxlIGV4dGVuc2lvbiBmcm9tIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKHtzcmM6XCJodHRwOi8vc2VydmVyLmNvbS9wcm94eT9maWxlPWltYWdlLmpwZ1wiLCB0eXBlOmNyZWF0ZWpzLlR5cGVzLklNQUdFfSk7XG4gICAgICpcbiAgICAgKiBTdXBwb3J0ZWQgdHlwZXMgYXJlIGRlZmluZWQgb24gdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzLCBhbmQgaW5jbHVkZTpcbiAgICAgKiA8dWw+XG4gICAgICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUeXBlcy9CSU5BUlk6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFJhdyBiaW5hcnkgZGF0YSB2aWEgWEhSPC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR5cGVzL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQ1NTIGZpbGVzPC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR5cGVzL0lNQUdFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBDb21tb24gaW1hZ2UgZm9ybWF0czwvbGk+XG4gICAgICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUeXBlcy9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKYXZhU2NyaXB0IGZpbGVzPC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR5cGVzL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gZGF0YTwvbGk+XG4gICAgICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUeXBlcy9KU09OUDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogSlNPTiBmaWxlcyBjcm9zcy1kb21haW48L2xpPlxuICAgICAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHlwZXMvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEEgbGlzdCBvZiBmaWxlcyB0byBsb2FkIGluIEpTT04gZm9ybWF0LCBzZWVcbiAgICAgKiAgICAge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319PC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR5cGVzL1NPVU5EOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBBdWRpbyBmaWxlIGZvcm1hdHM8L2xpPlxuICAgICAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHlwZXMvU1BSSVRFU0hFRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gU3ByaXRlU2hlZXQgZGVmaW5pdGlvbnMuIFRoaXNcbiAgICAgKiAgICAgd2lsbCBhbHNvIGxvYWQgc3ViLWltYWdlcywgYW5kIHByb3ZpZGUgYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZS48L2xpPlxuICAgICAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHlwZXMvU1ZHOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBTVkcgZmlsZXM8L2xpPlxuICAgICAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHlwZXMvVEVYVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogVGV4dCBmaWxlcyAtIFhIUiBvbmx5PC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR5cGVzL1ZJREVPOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBWaWRlbyBvYmplY3RzPC9saT5cbiAgICAgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR5cGVzL1hNTDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogWE1MIGRhdGE8L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICpcbiAgICAgKiA8ZW0+Tm90ZTogTG9hZGVyIHR5cGVzIHVzZWQgdG8gYmUgZGVmaW5lZCBvbiBMb2FkUXVldWUsIGJ1dCBoYXZlIGJlZW4gbW92ZWQgdG8gdGhlIFR5cGVzIGNsYXNzPC9lbT5cbiAgICAgKlxuICAgICAqIDxiPkhhbmRsaW5nIFJlc3VsdHM8L2I+PGJyIC8+XG4gICAgICogV2hlbiBhIGZpbGUgaXMgZmluaXNoZWQgZG93bmxvYWRpbmcsIGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGlzXG4gICAgICogZGlzcGF0Y2hlZC4gSW4gYW4gZXhhbXBsZSBhYm92ZSwgdGhlcmUgaXMgYW4gZXZlbnQgbGlzdGVuZXIgc25pcHBldCBmb3IgZmlsZWxvYWQuIExvYWRlZCBmaWxlcyBhcmUgdXN1YWxseSBhXG4gICAgICogZm9ybWF0dGVkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGltbWVkaWF0ZWx5LCBpbmNsdWRpbmc6XG4gICAgICogPHVsPlxuICAgICAqICAgICA8bGk+QmluYXJ5OiBUaGUgYmluYXJ5IGxvYWRlZCByZXN1bHQ8L2xpPlxuICAgICAqICAgICA8bGk+Q1NTOiBBICZsdDtsaW5rIC8mZ3Q7IHRhZzwvbGk+XG4gICAgICogICAgIDxsaT5JbWFnZTogQW4gJmx0O2ltZyAvJmd0OyB0YWc8L2xpPlxuICAgICAqICAgICA8bGk+SmF2YVNjcmlwdDogQSAmbHQ7c2NyaXB0IC8mZ3Q7IHRhZzwvbGk+XG4gICAgICogICAgIDxsaT5KU09OL0pTT05QOiBBIGZvcm1hdHRlZCBKYXZhU2NyaXB0IE9iamVjdDwvbGk+XG4gICAgICogICAgIDxsaT5NYW5pZmVzdDogQSBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgKiAgICAgPGxpPlNvdW5kOiBBbiAmbHQ7YXVkaW8gLyZndDsgdGFnPC9hPlxuICAgICAqICAgICA8bGk+U3ByaXRlU2hlZXQ6IEEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UsIGNvbnRhaW5pbmcgbG9hZGVkIGltYWdlcy5cbiAgICAgKiAgICAgPGxpPlNWRzogQW4gJmx0O29iamVjdCAvJmd0OyB0YWc8L2xpPlxuICAgICAqICAgICA8bGk+VGV4dDogUmF3IHRleHQ8L2xpPlxuICAgICAqICAgICA8bGk+VmlkZW86IEEgVmlkZW8gRE9NIG5vZGU8L2xpPlxuICAgICAqICAgICA8bGk+WE1MOiBBbiBYTUwgRE9NIG5vZGU8L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICpcbiAgICAgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUZpbGVMb2FkKGV2ZW50KSB7XG4gICAgICogICAgICAgICAgdmFyIGl0ZW0gPSBldmVudC5pdGVtOyAvLyBBIHJlZmVyZW5jZSB0byB0aGUgaXRlbSB0aGF0IHdhcyBwYXNzZWQgaW4gdG8gdGhlIExvYWRRdWV1ZVxuICAgICAqICAgICAgICAgIHZhciB0eXBlID0gaXRlbS50eXBlO1xuICAgICAqXG4gICAgICogICAgICAgICAgLy8gQWRkIGFueSBpbWFnZXMgdG8gdGhlIHBhZ2UgYm9keS5cbiAgICAgKiAgICAgICAgICBpZiAodHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5JTUFHRSkge1xuICAgICAqICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGV2ZW50LnJlc3VsdCk7XG4gICAgICogICAgICAgICAgfVxuICAgICAqICAgICAgfVxuICAgICAqXG4gICAgICogQXQgYW55IHRpbWUgYWZ0ZXIgdGhlIGZpbGUgaGFzIGJlZW4gbG9hZGVkICh1c3VhbGx5IGFmdGVyIHRoZSBxdWV1ZSBoYXMgY29tcGxldGVkKSwgYW55IHJlc3VsdCBjYW4gYmUgbG9va2VkIHVwXG4gICAgICogdmlhIGl0cyBcImlkXCIgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2dldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fS4gSWYgbm8gaWQgd2FzIHByb3ZpZGVkLCB0aGVuIHRoZVxuICAgICAqIFwic3JjXCIgb3IgZmlsZSBwYXRoIGNhbiBiZSB1c2VkIGluc3RlYWQsIGluY2x1ZGluZyB0aGUgYHBhdGhgIGRlZmluZWQgYnkgYSBtYW5pZmVzdCwgYnV0IDxzdHJvbmc+bm90IGluY2x1ZGluZzwvc3Ryb25nPlxuICAgICAqIGEgYmFzZSBwYXRoIGRlZmluZWQgb24gdGhlIExvYWRRdWV1ZS4gSXQgaXMgcmVjb21tZW5kZWQgdG8gYWx3YXlzIHBhc3MgYW4gaWQgaWYgeW91IHdhbnQgdG8gbG9vayB1cCBjb250ZW50LlxuICAgICAqXG4gICAgICogICAgICB2YXIgaW1hZ2UgPSBxdWV1ZS5nZXRSZXN1bHQoXCJpbWFnZVwiKTtcbiAgICAgKiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1hZ2UpO1xuICAgICAqXG4gICAgICogUmF3IGxvYWRlZCBjb250ZW50IGNhbiBiZSBhY2Nlc3NlZCB1c2luZyB0aGUgPGNvZGU+cmF3UmVzdWx0PC9jb2RlPiBwcm9wZXJ0eSBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogZXZlbnQsIG9yIGNhbiBiZSBsb29rZWQgdXAgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2dldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fSwgcGFzc2luZyBgdHJ1ZWAgYXMgdGhlIDJuZFxuICAgICAqIGFyZ3VtZW50LiBUaGlzIGlzIG9ubHkgYXBwbGljYWJsZSBmb3IgY29udGVudCB0aGF0IGhhcyBiZWVuIHBhcnNlZCBmb3IgdGhlIGJyb3dzZXIsIHNwZWNpZmljYWxseTogSmF2YVNjcmlwdCxcbiAgICAgKiBDU1MsIFhNTCwgU1ZHLCBhbmQgSlNPTiBvYmplY3RzLCBvciBhbnl0aGluZyBsb2FkZWQgd2l0aCBYSFIuXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpbWFnZSA9IHF1ZXVlLmdldFJlc3VsdChcImltYWdlXCIsIHRydWUpOyAvLyBsb2FkIHRoZSBiaW5hcnkgaW1hZ2UgZGF0YSBsb2FkZWQgd2l0aCBYSFIuXG4gICAgICpcbiAgICAgKiA8Yj5QbHVnaW5zPC9iPjxiciAvPlxuICAgICAqIExvYWRRdWV1ZSBoYXMgYSBzaW1wbGUgcGx1Z2luIGFyY2hpdGVjdHVyZSB0byBoZWxwIHByb2Nlc3MgYW5kIHByZWxvYWQgY29udGVudC4gRm9yIGV4YW1wbGUsIHRvIHByZWxvYWQgYXVkaW8sXG4gICAgICogbWFrZSBzdXJlIHRvIGluc3RhbGwgdGhlIDxhIGhyZWY9XCJodHRwOi8vc291bmRqcy5jb21cIj5Tb3VuZEpTPC9hPiBTb3VuZCBjbGFzcywgd2hpY2ggd2lsbCBoZWxwIGxvYWQgSFRNTCBhdWRpbyxcbiAgICAgKiBGbGFzaCBhdWRpbywgYW5kIFdlYkF1ZGlvIGZpbGVzLiBUaGlzIHNob3VsZCBiZSBpbnN0YWxsZWQgPHN0cm9uZz5iZWZvcmU8L3N0cm9uZz4gbG9hZGluZyBhbnkgYXVkaW8gZmlsZXMuXG4gICAgICpcbiAgICAgKiAgICAgIHF1ZXVlLmluc3RhbGxQbHVnaW4oY3JlYXRlanMuU291bmQpO1xuICAgICAqXG4gICAgICogPGg0Pktub3duIEJyb3dzZXIgSXNzdWVzPC9oND5cbiAgICAgKiA8dWw+XG4gICAgICogICAgIDxsaT5Ccm93c2VycyB3aXRob3V0IGF1ZGlvIHN1cHBvcnQgY2FuIG5vdCBsb2FkIGF1ZGlvIGZpbGVzLjwvbGk+XG4gICAgICogICAgIDxsaT5TYWZhcmkgb24gTWFjIE9TIFggY2FuIG9ubHkgcGxheSBIVE1MIGF1ZGlvIGlmIFF1aWNrVGltZSBpcyBpbnN0YWxsZWQ8L2xpPlxuICAgICAqICAgICA8bGk+SFRNTCBBdWRpbyB0YWdzIHdpbGwgb25seSBkb3dubG9hZCB1bnRpbCB0aGVpciA8Y29kZT5jYW5QbGF5VGhyb3VnaDwvY29kZT4gZXZlbnQgaXMgZmlyZWQuIEJyb3dzZXJzIG90aGVyXG4gICAgICogICAgIHRoYW4gQ2hyb21lIHdpbGwgY29udGludWUgdG8gZG93bmxvYWQgaW4gdGhlIGJhY2tncm91bmQuPC9saT5cbiAgICAgKiAgICAgPGxpPldoZW4gbG9hZGluZyBzY3JpcHRzIHVzaW5nIHRhZ3MsIHRoZXkgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGRvY3VtZW50LjwvbGk+XG4gICAgICogICAgIDxsaT5TY3JpcHRzIGxvYWRlZCB2aWEgWEhSIG1heSBub3QgYmUgcHJvcGVybHkgaW5zcGVjdGFibGUgd2l0aCBicm93c2VyIHRvb2xzLjwvbGk+XG4gICAgICogICAgIDxsaT5JRTYgYW5kIElFNyAoYW5kIHNvbWUgb3RoZXIgYnJvd3NlcnMpIG1heSBub3QgYmUgYWJsZSB0byBsb2FkIFhNTCwgVGV4dCwgb3IgSlNPTiwgc2luY2UgdGhleSByZXF1aXJlXG4gICAgICogICAgIFhIUiB0byB3b3JrLjwvbGk+XG4gICAgICogICAgIDxsaT5Db250ZW50IGxvYWRlZCB2aWEgdGFncyB3aWxsIG5vdCBzaG93IHByb2dyZXNzLCBhbmQgd2lsbCBjb250aW51ZSB0byBkb3dubG9hZCBpbiB0aGUgYmFja2dyb3VuZCB3aGVuXG4gICAgICogICAgIGNhbmNlbGVkLCBhbHRob3VnaCBubyBldmVudHMgd2lsbCBiZSBkaXNwYXRjaGVkLjwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBMb2FkUXVldWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmVmZXJYSFI9dHJ1ZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcmVsb2FkIGluc3RhbmNlIHdpbGwgZmF2b3IgbG9hZGluZyB3aXRoIFhIUiAoWE1MIEhUVFBcbiAgICAgKiBSZXF1ZXN0cyksIG9yIEhUTUwgdGFncy4gV2hlbiB0aGlzIGlzIGBmYWxzZWAsIHRoZSBxdWV1ZSB3aWxsIHVzZSB0YWcgbG9hZGluZyB3aGVuIHBvc3NpYmxlLCBhbmQgZmFsbCBiYWNrIG9uIFhIUlxuICAgICAqIHdoZW4gbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGg9XCJcIl0gQSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgb24gdG8gdGhlIHNvdXJjZSBwYXJhbWV0ZXIgb2YgYWxsIGl0ZW1zIGluIHRoZSBxdWV1ZVxuICAgICAqIGJlZm9yZSB0aGV5IGFyZSBsb2FkZWQuICBTb3VyY2VzIGJlZ2lubmluZyB3aXRoIGEgcHJvdG9jb2wgc3VjaCBhcyBgaHR0cDovL2Agb3IgYSByZWxhdGl2ZSBwYXRoIHN1Y2ggYXMgYC4uL2BcbiAgICAgKiB3aWxsIG5vdCByZWNlaXZlIGEgYmFzZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IFtjcm9zc09yaWdpbj1cIlwiXSBBbiBvcHRpb25hbCBmbGFnIHRvIHN1cHBvcnQgaW1hZ2VzIGxvYWRlZCBmcm9tIGEgQ09SUy1lbmFibGVkIHNlcnZlci4gVG9cbiAgICAgKiB1c2UgaXQsIHNldCB0aGlzIHZhbHVlIHRvIGB0cnVlYCwgd2hpY2ggd2lsbCBkZWZhdWx0IHRoZSBjcm9zc09yaWdpbiBwcm9wZXJ0eSBvbiBpbWFnZXMgdG8gXCJBbm9ueW1vdXNcIi4gQW55XG4gICAgICogc3RyaW5nIHZhbHVlIHdpbGwgYmUgcGFzc2VkIHRocm91Z2gsIGJ1dCBvbmx5IFwiXCIgYW5kIFwiQW5vbnltb3VzXCIgYXJlIHJlY29tbWVuZGVkLiA8c3Ryb25nPk5vdGU6IFRoZSBjcm9zc09yaWdpblxuICAgICAqIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkLiBVc2UgTG9hZEl0ZW0uY3Jvc3NPcmlnaW4gaW5zdGVhZDwvc3Ryb25nPlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2FkUXVldWUgKHByZWZlclhIUiwgYmFzZVBhdGgsIGNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgdGhlIHBsdWdpbnMgcmVnaXN0ZXJlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgICAgICogQHByb3BlcnR5IF9wbHVnaW5zXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHNpbmNlIDAuNi4xXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wbHVnaW5zID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBoYXNoIG9mIGNhbGxiYWNrcyB0aGF0IGFyZSBmaXJlZCBmb3IgZWFjaCBmaWxlIHR5cGUgYmVmb3JlIHRoZSBmaWxlIGlzIGxvYWRlZCwgZ2l2aW5nIHBsdWdpbnMgdGhlXG4gICAgICAgICAqIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcHJvcGVydGllcyBvZiB0aGUgbG9hZC4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgICAgICogbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAcHJvcGVydHkgX3R5cGVDYWxsYmFja3NcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3R5cGVDYWxsYmFja3MgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IGhhc2ggb2YgY2FsbGJhY2tzIHRoYXQgYXJlIGZpcmVkIGZvciBlYWNoIGZpbGUgZXh0ZW5zaW9uIGJlZm9yZSB0aGUgZmlsZSBpcyBsb2FkZWQsIGdpdmluZyBwbHVnaW5zIHRoZVxuICAgICAgICAgKiBhYmlsaXR5IHRvIG92ZXJyaWRlIHByb3BlcnRpZXMgb2YgdGhlIGxvYWQuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICAgICAqIG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQHByb3BlcnR5IF9leHRlbnNpb25DYWxsYmFja3NcbiAgICAgICAgICogQHR5cGUge251bGx9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9leHRlbnNpb25DYWxsYmFja3MgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5leHQgcHJlbG9hZCBxdWV1ZSB0byBwcm9jZXNzIHdoZW4gdGhpcyBvbmUgaXMgY29tcGxldGUuIElmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgY3VycmVudCBxdWV1ZSwgYW5kXG4gICAgICAgICAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zdG9wT25FcnJvcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBgdHJ1ZWAsIHRoZSBuZXh0IHF1ZXVlIHdpbGwgbm90IGJlIHByb2Nlc3NlZC5cbiAgICAgICAgICogQHByb3BlcnR5IG5leHRcbiAgICAgICAgICogQHR5cGUge0xvYWRRdWV1ZX1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5zdXJlIGxvYWRlZCBzY3JpcHRzIFwiY29tcGxldGVcIiBpbiB0aGUgb3JkZXIgdGhleSBhcmUgc3BlY2lmaWVkLiBMb2FkZWQgc2NyaXB0cyBhcmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50IGhlYWRcbiAgICAgICAgICogb25jZSB0aGV5IGFyZSBsb2FkZWQuIFNjcmlwdHMgbG9hZGVkIHZpYSB0YWdzIHdpbGwgbG9hZCBvbmUtYXQtYS10aW1lIHdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIHdoZXJlYXNcbiAgICAgICAgICogc2NyaXB0cyBsb2FkZWQgdXNpbmcgWEhSIGNhbiBsb2FkIGluIGFueSBvcmRlciwgYnV0IHdpbGwgXCJmaW5pc2hcIiBhbmQgYmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50IGluIHRoZSBvcmRlclxuICAgICAgICAgKiBzcGVjaWZpZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBpdGVtcyBjYW4gYmUgc2V0IHRvIGxvYWQgaW4gb3JkZXIgYnkgc2V0dGluZyB0aGUge3sjY3Jvc3NMaW5rIFwibWFpbnRhaW5PcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAgICAgKiBwcm9wZXJ0eSBvbiB0aGUgbG9hZCBpdGVtLCBvciBieSBlbnN1cmluZyB0aGF0IG9ubHkgb25lIGNvbm5lY3Rpb24gY2FuIGJlIG9wZW4gYXQgYSB0aW1lIHVzaW5nXG4gICAgICAgICAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHdoZW4gdGhlIGBtYWludGFpblNjcmlwdE9yZGVyYCBwcm9wZXJ0eVxuICAgICAgICAgKiBpcyBzZXQgdG8gYHRydWVgLCBzY3JpcHRzIGl0ZW1zIGFyZSBhdXRvbWF0aWNhbGx5IHNldCB0byBgbWFpbnRhaW5PcmRlcj10cnVlYCwgYW5kIGNoYW5naW5nIHRoZVxuICAgICAgICAgKiBgbWFpbnRhaW5TY3JpcHRPcmRlcmAgdG8gYGZhbHNlYCBkdXJpbmcgYSBsb2FkIHdpbGwgbm90IGNoYW5nZSBpdGVtcyBhbHJlYWR5IGluIGEgcXVldWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIDxoND5FeGFtcGxlPC9oND5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG4gICAgICAgICAqICAgICAgcXVldWUuc2V0TWF4Q29ubmVjdGlvbnMoMyk7IC8vIFNldCBhIGhpZ2hlciBudW1iZXIgdG8gbG9hZCBtdWx0aXBsZSBpdGVtcyBhdCBvbmNlXG4gICAgICAgICAqICAgICAgcXVldWUubWFpbnRhaW5TY3JpcHRPcmRlciA9IHRydWU7IC8vIEVuc3VyZSBzY3JpcHRzIGFyZSBsb2FkZWQgaW4gb3JkZXJcbiAgICAgICAgICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoW1xuICAgICAgICAgKiAgICAgICAgICBcInNjcmlwdDEuanNcIixcbiAgICAgICAgICogICAgICAgICAgXCJzY3JpcHQyLmpzXCIsXG4gICAgICAgICAqICAgICAgICAgIFwiaW1hZ2UucG5nXCIsIC8vIExvYWQgYW55IHRpbWVcbiAgICAgICAgICogICAgICAgICAge3NyYzogXCJpbWFnZTIucG5nXCIsIG1haW50YWluT3JkZXI6IHRydWV9IC8vIFdpbGwgd2FpdCBmb3Igc2NyaXB0Mi5qc1xuICAgICAgICAgKiAgICAgICAgICBcImltYWdlMy5wbmdcIixcbiAgICAgICAgICogICAgICAgICAgXCJzY3JpcHQzLmpzXCIgLy8gV2lsbCB3YWl0IGZvciBpbWFnZTIucG5nIGJlZm9yZSBsb2FkaW5nIChvciBjb21wbGV0aW5nIHdoZW4gbG9hZGluZyB3aXRoIFhIUilcbiAgICAgICAgICogICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3BlcnR5IG1haW50YWluU2NyaXB0T3JkZXJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFpbnRhaW5TY3JpcHRPcmRlciA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIExvYWRRdWV1ZSB3aWxsIHN0b3AgcHJvY2Vzc2luZyB0aGUgY3VycmVudCBxdWV1ZSB3aGVuIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgc3RvcE9uRXJyb3JcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BPbkVycm9yID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgbWF4aW11bSBvcGVuIGNvbm5lY3Rpb25zIHRoYXQgYSBsb2FkUXVldWUgdHJpZXMgdG8gbWFpbnRhaW4uIFBsZWFzZSBzZWVcbiAgICAgICAgICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAcHJvcGVydHkgX21heENvbm5lY3Rpb25zXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21heENvbm5lY3Rpb25zID0gMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgbGlzdCBvZiBhbGwgdGhlIGRlZmF1bHQgTG9hZGVycyB0aGF0IGFyZSBpbmNsdWRlZCB3aXRoIFByZWxvYWRKUy4gQmVmb3JlIGFuIGl0ZW0gaXMgbG9hZGVkLCB0aGVcbiAgICAgICAgICogYXZhaWxhYmxlIGxvYWRlciBsaXN0IGlzIGl0ZXJhdGVkLCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgaW5jbHVkZWQsIGFuZCBhcyBzb29uIGFzIGEgbG9hZGVyIGluZGljYXRlcyBpdCBjYW5cbiAgICAgICAgICogaGFuZGxlIHRoZSBjb250ZW50LCBpdCB3aWxsIGJlIHNlbGVjdGVkLiBUaGUgZGVmYXVsdCBsb2FkZXIsICh7eyNjcm9zc0xpbmsgXCJUZXh0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGlzXG4gICAgICAgICAqIGxhc3QgaW4gdGhlIGxpc3QsIHNvIGl0IHdpbGwgYmUgdXNlZCBpZiBubyBvdGhlciBtYXRjaCBpcyBmb3VuZC4gVHlwaWNhbGx5LCBsb2FkZXJzIHdpbGwgbWF0Y2ggYmFzZWQgb24gdGhlXG4gICAgICAgICAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGVcIn19e3svY3Jvc3NMaW5rfX0sIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lZCB1c2luZyB0aGUgZmlsZSBleHRlbnNpb24gb2ZcbiAgICAgICAgICogdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3NyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgICAgICpcbiAgICAgICAgICogTG9hZGVycyBjYW4gYmUgcmVtb3ZlZCBmcm9tIFByZWxvYWRKUyBieSBzaW1wbHkgbm90IGluY2x1ZGluZyB0aGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDdXN0b20gbG9hZGVycyBpbnN0YWxsZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwicmVnaXN0ZXJMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhpcyBsaXN0XG4gICAgICAgICAqIHNvIHRoYXQgdGhleSBhcmUgY2hlY2tlZCBmaXJzdC5cbiAgICAgICAgICogQHByb3BlcnR5IF9hdmFpbGFibGVMb2FkZXJzXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHNpbmNlIDAuNi4wXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hdmFpbGFibGVMb2FkZXJzID0gW1xuICAgICAgICAgICAgY3JlYXRlanMuRm9udExvYWRlcixcbiAgICAgICAgICAgIGNyZWF0ZWpzLkltYWdlTG9hZGVyLFxuICAgICAgICAgICAgY3JlYXRlanMuSmF2YVNjcmlwdExvYWRlcixcbiAgICAgICAgICAgIGNyZWF0ZWpzLkNTU0xvYWRlcixcbiAgICAgICAgICAgIGNyZWF0ZWpzLkpTT05Mb2FkZXIsXG4gICAgICAgICAgICBjcmVhdGVqcy5KU09OUExvYWRlcixcbiAgICAgICAgICAgIGNyZWF0ZWpzLlNvdW5kTG9hZGVyLFxuICAgICAgICAgICAgY3JlYXRlanMuTWFuaWZlc3RMb2FkZXIsXG4gICAgICAgICAgICBjcmVhdGVqcy5TcHJpdGVTaGVldExvYWRlcixcbiAgICAgICAgICAgIGNyZWF0ZWpzLlhNTExvYWRlcixcbiAgICAgICAgICAgIGNyZWF0ZWpzLlNWR0xvYWRlcixcbiAgICAgICAgICAgIGNyZWF0ZWpzLkJpbmFyeUxvYWRlcixcbiAgICAgICAgICAgIGNyZWF0ZWpzLlZpZGVvTG9hZGVyLFxuICAgICAgICAgICAgY3JlYXRlanMuVGV4dExvYWRlclxuICAgICAgICBdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGJ1aWx0IGluIGxvYWRlcnMsIHNvIHRoZXkgY2FuJ3QgYmUgcmVtb3ZlZCBieSB7eyNjcm9zc0xpbmsgXCJ1bnJlZ2lzdGVyTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua30uXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IF9kZWZhdWx0TG9hZGVyTGVuZ3RoXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGVmYXVsdExvYWRlckxlbmd0aCA9IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuaW5pdChwcmVmZXJYSFIsIGJhc2VQYXRoLCBjcm9zc09yaWdpbik7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTG9hZFF1ZXVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG4gICAgdmFyIHMgPSBMb2FkUXVldWU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBpbml0aWFsaXphdGlvbiBtZXRob2QsIHdoaWNoIGlzIHVzZWQgZm9yIGluaXRpYWwgc2V0IHVwLCBidXQgYWxzbyB0byByZXNldCB0aGUgTG9hZFF1ZXVlLlxuICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAqIEBwYXJhbSBwcmVmZXJYSFJcbiAgICAgKiBAcGFyYW0gYmFzZVBhdGhcbiAgICAgKiBAcGFyYW0gY3Jvc3NPcmlnaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuaW5pdCA9IGZ1bmN0aW9uIChwcmVmZXJYSFIsIGJhc2VQYXRoLCBjcm9zc09yaWdpbikge1xuXG4gICAgICAgIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyeSBhbmQgdXNlIFhNTEh0dHBSZXF1ZXN0IChYSFIpIHdoZW4gcG9zc2libGUuIE5vdGUgdGhhdCBMb2FkUXVldWUgd2lsbCBkZWZhdWx0IHRvIHRhZyBsb2FkaW5nIG9yIFhIUlxuICAgICAgICAgKiBsb2FkaW5nIGRlcGVuZGluZyBvbiB0aGUgcmVxdWlyZW1lbnRzIGZvciBhIG1lZGlhIHR5cGUuIEZvciBleGFtcGxlLCBIVE1MIGF1ZGlvIGNhbiBub3QgYmUgbG9hZGVkIHdpdGggWEhSLFxuICAgICAgICAgKiBhbmQgcGxhaW4gdGV4dCBjYW4gbm90IGJlIGxvYWRlZCB3aXRoIHRhZ3MsIHNvIGl0IHdpbGwgZGVmYXVsdCB0aGUgdGhlIGNvcnJlY3QgdHlwZSBpbnN0ZWFkIG9mIHVzaW5nIHRoZVxuICAgICAgICAgKiB1c2VyLWRlZmluZWQgdHlwZS5cbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICogQHNpbmNlIDAuNi4wXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZWZlclhIUiA9IHRydWU7IC8vVE9ETzogR2V0L1NldFxuICAgICAgICB0aGlzLl9wcmVmZXJYSFIgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFByZWZlclhIUihwcmVmZXJYSFIpO1xuXG4gICAgICAgIC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgcGF1c2VkIG9yIG5vdC5cbiAgICAgICAgICogQHByb3BlcnR5IF9wYXVzZWRcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgb24gdG8gdGhlIGl0ZW0ncyB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9zcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uIFRoZVxuICAgICAgICAgKiBgX2Jhc2VQYXRoYCBwcm9wZXJ0eSB3aWxsIG9ubHkgYmUgdXNlZCBpZiBhbiBpdGVtJ3Mgc291cmNlIGlzIHJlbGF0aXZlLCBhbmQgZG9lcyBub3QgaW5jbHVkZSBhIHByb3RvY29sIHN1Y2hcbiAgICAgICAgICogYXMgYGh0dHA6Ly9gLCBvciBhIHJlbGF0aXZlIHBhdGggc3VjaCBhcyBgLi4vYC5cbiAgICAgICAgICogQHByb3BlcnR5IF9iYXNlUGF0aFxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAc2luY2UgMC4zLjFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Jhc2VQYXRoID0gYmFzZVBhdGg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIGZsYWcgdG8gc2V0IG9uIGltYWdlcyB0aGF0IGFyZSBsb2FkZWQgdXNpbmcgUHJlbG9hZEpTLCB3aGljaCBlbmFibGVzIENPUlMgc3VwcG9ydC4gSW1hZ2VzIGxvYWRlZFxuICAgICAgICAgKiBjcm9zcy1kb21haW4gYnkgc2VydmVycyB0aGF0IHN1cHBvcnQgQ09SUyByZXF1aXJlIHRoZSBjcm9zc09yaWdpbiBmbGFnIHRvIGJlIGxvYWRlZCBhbmQgaW50ZXJhY3RlZCB3aXRoIGJ5XG4gICAgICAgICAqIGEgY2FudmFzLiBXaGVuIGxvYWRpbmcgbG9jYWxseSwgb3Igd2l0aCBhIHNlcnZlciB3aXRoIG5vIENPUlMgc3VwcG9ydCwgdGhpcyBmbGFnIGNhbiBjYXVzZSBvdGhlciBzZWN1cml0eSBpc3N1ZXMsXG4gICAgICAgICAqIHNvIGl0IGlzIHJlY29tbWVuZGVkIHRvIG9ubHkgc2V0IGl0IGlmIHlvdSBhcmUgc3VyZSB0aGUgc2VydmVyIHN1cHBvcnRzIGl0LiBDdXJyZW50bHksIHN1cHBvcnRlZCB2YWx1ZXMgYXJlIFwiXCJcbiAgICAgICAgICogYW5kIFwiQW5vbnltb3VzXCIuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfY3Jvc3NPcmlnaW5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgXCJcIlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAc2luY2UgMC40LjFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Nyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIGxvYWRTdGFydCBldmVudCB3YXMgZGlzcGF0Y2hlZCBhbHJlYWR5LiBUaGlzIGV2ZW50IGlzIG9ubHkgZmlyZWQgb25lIHRpbWUsIHdoZW4gdGhlIGZpcnN0XG4gICAgICAgICAqIGZpbGUgaXMgcmVxdWVzdGVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgX2xvYWRTdGFydFdhc0Rpc3BhdGNoZWRcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlcmUgaXMgY3VycmVudGx5IGEgc2NyaXB0IGxvYWRpbmcuIFRoaXMgaGVscHMgZW5zdXJlIHRoYXQgb25seSBhIHNpbmdsZSBzY3JpcHQgbG9hZHMgYXQgb25jZSB3aGVuXG4gICAgICAgICAqIHVzaW5nIGEgc2NyaXB0IHRhZyB0byBkbyBwcmVsb2FkaW5nLlxuICAgICAgICAgKiBAcHJvcGVydHkgX2N1cnJlbnRseUxvYWRpbmdTY3JpcHRcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgY3VycmVudGx5IGRvd25sb2FkaW5nIGZpbGVzLlxuICAgICAgICAgKiBAcHJvcGVydHkgX2N1cnJlbnRMb2Fkc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jdXJyZW50TG9hZHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcXVldWVkIGl0ZW1zIHRoYXQgaGF2ZSBub3QgeWV0IHN0YXJ0ZWQgZG93bmxvYWRpbmcuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfbG9hZFF1ZXVlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWRRdWV1ZSA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGRvd25sb2FkcyB0aGF0IGhhdmUgbm90IGNvbXBsZXRlZCwgc28gdGhhdCB0aGUgTG9hZFF1ZXVlIGNhbiBiZSBwcm9wZXJseSByZXNldC5cbiAgICAgICAgICogQHByb3BlcnR5IF9sb2FkUXVldWVCYWNrdXBcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9hZFF1ZXVlQmFja3VwID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBoYXNoIG9mIGl0ZW1zIHRoYXQgaGF2ZSBmaW5pc2hlZCBkb3dubG9hZGluZywgaW5kZXhlZCBieSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgICAgICogaWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfbG9hZEl0ZW1zQnlJZFxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9hZEl0ZW1zQnlJZCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvYmplY3QgaGFzaCBvZiBpdGVtcyB0aGF0IGhhdmUgZmluaXNoZWQgZG93bmxvYWRpbmcsIGluZGV4ZWQgYnkge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgICAgICogc291cmNlLlxuICAgICAgICAgKiBAcHJvcGVydHkgX2xvYWRJdGVtc0J5U3JjXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkSXRlbXNCeVNyYyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvYmplY3QgaGFzaCBvZiBsb2FkZWQgaXRlbXMsIGluZGV4ZWQgYnkgdGhlIElEIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgICAgICogQHByb3BlcnR5IF9sb2FkZWRSZXN1bHRzXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkZWRSZXN1bHRzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBoYXNoIG9mIHVuLXBhcnNlZCBsb2FkZWQgaXRlbXMsIGluZGV4ZWQgYnkgdGhlIElEIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgICAgICogQHByb3BlcnR5IF9sb2FkZWRSYXdSZXN1bHRzXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBoYXZlIGJlZW4gcmVxdWVzdGVkLiBUaGlzIGhlbHBzIG1hbmFnZSBhbiBvdmVyYWxsIHByb2dyZXNzIHdpdGhvdXQga25vd2luZyBob3cgbGFyZ2VcbiAgICAgICAgICogdGhlIGZpbGVzIGFyZSBiZWZvcmUgdGhleSBhcmUgZG93bmxvYWRlZC4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIGl0ZW1zIGluc2lkZSBvZiBsb2FkZXJzIHN1Y2ggYXMgdGhlXG4gICAgICAgICAqIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAgICAgKiBAcHJvcGVydHkgX251bUl0ZW1zXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX251bUl0ZW1zID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IGhhdmUgY29tcGxldGVkIGxvYWRlZC4gVGhpcyBoZWxwcyBtYW5hZ2UgYW4gb3ZlcmFsbCBwcm9ncmVzcyB3aXRob3V0IGtub3dpbmcgaG93IGxhcmdlXG4gICAgICAgICAqIHRoZSBmaWxlcyBhcmUgYmVmb3JlIHRoZXkgYXJlIGRvd25sb2FkZWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfbnVtSXRlbXNMb2FkZWRcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbnVtSXRlbXNMb2FkZWQgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2Ygc2NyaXB0cyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHJlcXVlc3RlZC4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBzY3JpcHRzIGFyZSBcImNvbXBsZXRlZFwiIGluIHRoZSByaWdodFxuICAgICAgICAgKiBvcmRlci5cbiAgICAgICAgICogQHByb3BlcnR5IF9zY3JpcHRPcmRlclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zY3JpcHRPcmRlciA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2Ygc2NyaXB0cyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQuIEl0ZW1zIGFyZSBhZGRlZCB0byB0aGlzIGxpc3QgYXMgPGNvZGU+bnVsbDwvY29kZT4gd2hlbiB0aGV5IGFyZVxuICAgICAgICAgKiByZXF1ZXN0ZWQsIGNvbnRhaW4gdGhlIGxvYWRlZCBpdGVtIGlmIGl0IGhhcyBjb21wbGV0ZWQsIGJ1dCBub3QgYmVlbiBkaXNwYXRjaGVkIHRvIHRoZSB1c2VyLCBhbmQgPGNvZGU+dHJ1ZTwvdHJ1ZT5cbiAgICAgICAgICogb25jZSB0aGV5IGFyZSBjb21wbGV0ZSBhbmQgaGF2ZSBiZWVuIGRpc3BhdGNoZWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfbG9hZGVkU2NyaXB0c1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkZWRTY3JpcHRzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IHByb2dyZXNzIGFtb3VudC4gVGhpcyBpcyB1c2VkIHRvIHN1cHByZXNzIGR1cGxpY2F0ZSBwcm9ncmVzcyBldmVudHMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfbGFzdFByb2dyZXNzXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0gTmFOO1xuXG4gICAgfTtcblxuLy8gc3RhdGljIHByb3BlcnRpZXNcblxuLy8gZXZlbnRzXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFuIGluZGl2aWR1YWwgZmlsZSBoYXMgbG9hZGVkLCBhbmQgYmVlbiBwcm9jZXNzZWQuXG4gICAgICogQGV2ZW50IGZpbGVsb2FkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGZpbGUgaXRlbSB3aGljaCB3YXMgc3BlY2lmaWVkIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG4gICAgICogb2JqZWN0IHdpbGwgY29udGFpbiB0aGF0IHZhbHVlIGFzIGEgYHNyY2AgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBUaGUgSFRNTCB0YWcgb3IgcGFyc2VkIHJlc3VsdCBvZiB0aGUgbG9hZGVkIGl0ZW0uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJhd1Jlc3VsdCBUaGUgdW5wcm9jZXNzZWQgcmVzdWx0LCB1c3VhbGx5IHRoZSByYXcgdGV4dCBvciBiaW5hcnkgZGF0YSBiZWZvcmUgaXQgaXMgY29udmVydGVkXG4gICAgICogdG8gYSB1c2FibGUgb2JqZWN0LlxuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhpcyB7eyNjcm9zc0xpbmsgXCJQcm9ncmVzc0V2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiBhbiBhbiBpbmRpdmlkdWFsIGZpbGUncyBwcm9ncmVzcyBjaGFuZ2VzLlxuICAgICAqIEBldmVudCBmaWxlcHJvZ3Jlc3NcbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGZpbGUgc3RhcnRzIHRvIGxvYWQuXG4gICAgICogQGV2ZW50IGZpbGVzdGFydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBmaWxlIGl0ZW0gd2hpY2ggd2FzIHNwZWNpZmllZCBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBJZiBvbmx5IGEgc3RyaW5nIHBhdGggb3IgdGFnIHdhcyBzcGVjaWZpZWQsIHRoZVxuICAgICAqIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhhdCB2YWx1ZSBhcyBhIHByb3BlcnR5LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQWx0aG91Z2ggaXQgZXh0ZW5kcyB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgdGhlIGBpbml0aWFsaXplYCBldmVudCBpcyBuZXZlciBmaXJlZCBmcm9tXG4gICAgICogYSBMb2FkUXVldWUgaW5zdGFuY2UuXG4gICAgICogQGV2ZW50IGluaXRpYWxpemVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4vLyBwdWJsaWMgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY3VzdG9tIGxvYWRlcnMgY2xhc3MuIE5ldyBsb2FkZXJzIGFyZSBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgbG9hZGVycyBhZGRlZCBlYXJsaWVyIGFuZCBkZWZhdWx0IGxvYWRlcnMuXG4gICAgICogSXQgaXMgcmVjb21tZW5kZWQgdGhhdCBsb2FkZXJzIGV4dGVuZCB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS4gTG9hZGVycyBjYW4gb25seSBiZSBhZGRlZFxuICAgICAqIG9uY2UsIGFuZCB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbG9hZGVycy5cbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyTG9hZGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBBYnN0cmFjdExvYWRlciBjbGFzcyB0byBhZGQuXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICovXG4gICAgcC5yZWdpc3RlckxvYWRlciA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgaWYgKCFsb2FkZXIgfHwgIWxvYWRlci5jYW5Mb2FkSXRlbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZGVyIGlzIG9mIGFuIGluY29ycmVjdCB0eXBlLlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmluZGV4T2YobG9hZGVyKSAhPSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZGVyIGFscmVhZHkgZXhpc3RzLlwiKTsgLy9MTTogTWF5YmUganVzdCBzaWxlbnRseSBmYWlsIGhlcmVcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMudW5zaGlmdChsb2FkZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjdXN0b20gbG9hZGVyIGFkZGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcInJlZ2lzdGVyTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LiBPbmx5IGN1c3RvbSBsb2FkZXJzIGNhbiBiZVxuICAgICAqIHVucmVnaXN0ZXJlZCwgdGhlIGRlZmF1bHQgbG9hZGVycyB3aWxsIGFsd2F5cyBiZSBhdmFpbGFibGUuXG4gICAgICogQG1ldGhvZCB1bnJlZ2lzdGVyTG9hZGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBBYnN0cmFjdExvYWRlciBjbGFzcyB0byByZW1vdmVcbiAgICAgKi9cbiAgICBwLnVucmVnaXN0ZXJMb2FkZXIgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmluZGV4T2YobG9hZGVyKTtcbiAgICAgICAgaWYgKGlkeCAhPSAtMSAmJiBpZHggPCB0aGlzLl9kZWZhdWx0TG9hZGVyTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy5fYXZhaWxhYmxlTG9hZGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIHt7I2Nyb3NzTGluayBcInByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB2YWx1ZS4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgc2V0IHRvIGB0cnVlYCwgaXQgbWF5XG4gICAgICogZmFpbCwgb3IgYmUgaWdub3JlZCBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIncyBjYXBhYmlsaXRpZXMgYW5kIHRoZSBsb2FkIHR5cGUuXG4gICAgICogQG1ldGhvZCBzZXRQcmVmZXJYSFJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRoZSB2YWx1ZSBvZiB7eyNjcm9zc0xpbmsgXCJwcmVmZXJYSFJcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCB3YXMgc3VjY2Vzc2Z1bGx5IHNldC5cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBwLnNldFByZWZlclhIUiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgY2FuIHVzZSBYSFIuIFhIUiBkZWZhdWx0cyB0byBUUlVFLCBidXQgdGhlIGJyb3dzZXIgbWF5IG5vdCBzdXBwb3J0IGl0LlxuICAgICAgICAvL1RPRE86IFNob3VsZCB3ZSBiZSBjaGVja2luZyBmb3IgdGhlIG90aGVyIFhIUiB0eXBlcz8gTWlnaHQgaGF2ZSB0byBkbyBhIHRyeS9jYXRjaCBvbiB0aGUgZGlmZmVyZW50IHR5cGVzIHNpbWlsYXIgdG8gY3JlYXRlWEhSLlxuICAgICAgICB0aGlzLnByZWZlclhIUiA9ICh2YWx1ZSAhPSBmYWxzZSAmJiB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgIT0gbnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWZlclhIUjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcHMgYWxsIHF1ZXVlZCBhbmQgbG9hZGluZyBpdGVtcywgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgYWxzbyByZW1vdmVzIGFsbCBpbnRlcm5hbCByZWZlcmVuY2VzIHRvIGxvYWRlZFxuICAgICAqIGNvbnRlbnQsIGFuZCBhbGxvd3MgdGhlIHF1ZXVlIHRvIGJlIHVzZWQgYWdhaW4uXG4gICAgICogQG1ldGhvZCByZW1vdmVBbGxcbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKi9cbiAgICBwLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcHMgYW4gaXRlbSBmcm9tIGJlaW5nIGxvYWRlZCwgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgcXVldWUuIElmIG5vdGhpbmcgaXMgcGFzc2VkLCBhbGwgaXRlbXMgYXJlIHJlbW92ZWQuXG4gICAgICogVGhpcyBhbHNvIHJlbW92ZXMgaW50ZXJuYWwgcmVmZXJlbmNlcyB0byBsb2FkZWQgaXRlbShzKS5cbiAgICAgKlxuICAgICAqIDxoND5FeGFtcGxlPC9oND5cbiAgICAgKlxuICAgICAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFtcbiAgICAgKiAgICAgICAgICB7c3JjOlwidGVzdC5wbmdcIiwgaWQ6XCJwbmdcIn0sXG4gICAgICogICAgICAgICAge3NyYzpcInRlc3QuanBnXCIsIGlkOlwianBnXCJ9LFxuICAgICAqICAgICAgICAgIHtzcmM6XCJ0ZXN0Lm1wM1wiLCBpZDpcIm1wM1wifVxuICAgICAqICAgICAgXSk7XG4gICAgICogICAgICBxdWV1ZS5yZW1vdmUoXCJwbmdcIik7IC8vIFNpbmdsZSBpdGVtIGJ5IElEXG4gICAgICogICAgICBxdWV1ZS5yZW1vdmUoXCJwbmdcIiwgXCJ0ZXN0LmpwZ1wiKTsgLy8gSXRlbXMgYXMgYXJndW1lbnRzLiBNaXhlZCBpZCBhbmQgc3JjLlxuICAgICAqICAgICAgcXVldWUucmVtb3ZlKFtcInRlc3QucG5nXCIsIFwianBnXCJdKTsgLy8gSXRlbXMgaW4gYW4gQXJyYXkuIE1peGVkIGlkIGFuZCBzcmMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXl9IGlkc09yVXJscyogVGhlIGlkIG9yIGlkcyB0byByZW1vdmUgZnJvbSB0aGlzIHF1ZXVlLiBZb3UgY2FuIHBhc3MgYW4gaXRlbSwgYW4gYXJyYXkgb2ZcbiAgICAgKiBpdGVtcywgb3IgbXVsdGlwbGUgaXRlbXMgYXMgYXJndW1lbnRzLlxuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqL1xuICAgIHAucmVtb3ZlID0gZnVuY3Rpb24gKGlkc09yVXJscykge1xuICAgICAgICB2YXIgYXJncyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGlkc09yVXJscyAmJiAhQXJyYXkuaXNBcnJheShpZHNPclVybHMpKSB7XG4gICAgICAgICAgICBhcmdzID0gW2lkc09yVXJsc107XG4gICAgICAgIH0gZWxzZSBpZiAoaWRzT3JVcmxzKSB7XG4gICAgICAgICAgICBhcmdzID0gaWRzT3JVcmxzO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbXNXZXJlUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIERlc3Ryb3kgZXZlcnl0aGluZ1xuICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIG4gaW4gdGhpcy5fbG9hZEl0ZW1zQnlJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VJdGVtKHRoaXMuX2xvYWRJdGVtc0J5SWRbbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbml0KHRoaXMucHJlZmVyWEhSLCB0aGlzLl9iYXNlUGF0aCk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBzcGVjaWZpYyBpdGVtc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5nZXRSZXN1bHQoaXRlbSk7XG5cbiAgICAgICAgICAgICAgICAvL1JlbW92ZSBmcm9tIHRoZSBtYWluIGxvYWQgUXVldWVcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSB0aGlzLl9sb2FkUXVldWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZEl0ZW0gPSB0aGlzLl9sb2FkUXVldWVbaV0uZ2V0SXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZEl0ZW0uaWQgPT0gaXRlbSB8fCBsb2FkSXRlbS5zcmMgPT0gaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZFF1ZXVlLnNwbGljZShpLCAxKVswXS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9SZW1vdmUgZnJvbSB0aGUgYmFja3VwIHF1ZXVlXG4gICAgICAgICAgICAgICAgZm9yIChpID0gdGhpcy5fbG9hZFF1ZXVlQmFja3VwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRJdGVtID0gdGhpcy5fbG9hZFF1ZXVlQmFja3VwW2ldLmdldEl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRJdGVtLmlkID09IGl0ZW0gfHwgbG9hZEl0ZW0uc3JjID09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5zcGxpY2UoaSwgMSlbMF0uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VJdGVtKHRoaXMuZ2V0SXRlbShpdGVtKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvYWRJdGVtID0gdGhpcy5fY3VycmVudExvYWRzW2ldLmdldEl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkSXRlbS5pZCA9PSBpdGVtIHx8IGxvYWRJdGVtLnNyYyA9PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExvYWRzLnNwbGljZShpLCAxKVswXS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1dlcmVSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgY2FsbGVkIGR1cmluZyBhIGxvYWQsIHRyeSB0byBsb2FkIHRoZSBuZXh0IGl0ZW0uXG4gICAgICAgICAgICBpZiAoaXRlbXNXZXJlUmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWROZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcHMgYWxsIG9wZW4gbG9hZHMsIGRlc3Ryb3lzIGFueSBsb2FkZWQgaXRlbXMsIGFuZCByZXNldHMgdGhlIHF1ZXVlLCBzbyBhbGwgaXRlbXMgY2FuXG4gICAgICogYmUgcmVsb2FkZWQgYWdhaW4gYnkgY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2FkXCJ9fXt7L2Nyb3NzTGlua319LiBJdGVtcyBhcmUgbm90IHJlbW92ZWQgZnJvbSB0aGVcbiAgICAgKiBxdWV1ZS4gVG8gcmVtb3ZlIGl0ZW1zIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBvclxuICAgICAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9yZW1vdmVBbGxcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuICAgICAqIEBtZXRob2QgcmVzZXRcbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKi9cbiAgICBwLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGZvciAodmFyIG4gaW4gdGhpcy5fbG9hZEl0ZW1zQnlJZCkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUl0ZW0odGhpcy5fbG9hZEl0ZW1zQnlJZFtuXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1Jlc2V0IHRoZSBxdWV1ZSB0byBpdHMgc3RhcnQgc3RhdGVcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9sb2FkUXVldWVCYWNrdXAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBhLnB1c2godGhpcy5fbG9hZFF1ZXVlQmFja3VwW2ldLmdldEl0ZW0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvYWRNYW5pZmVzdChhLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgcGx1Z2luLiBQbHVnaW5zIGNhbiBtYXAgdG8gbG9hZCB0eXBlcyAoc291bmQsIGltYWdlLCBldGMpLCBvciBzcGVjaWZpYyBleHRlbnNpb25zIChwbmcsIG1wMywgZXRjKS5cbiAgICAgKiBDdXJyZW50bHksIG9ubHkgb25lIHBsdWdpbiBjYW4gZXhpc3QgcGVyIHR5cGUvZXh0ZW5zaW9uLlxuICAgICAqXG4gICAgICogV2hlbiBhIHBsdWdpbiBpcyBpbnN0YWxsZWQsIGEgPGNvZGU+Z2V0UHJlbG9hZEhhbmRsZXJzKCk8L2NvZGU+IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiBpdC4gRm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICAgKiBvbiB0aGlzIG1ldGhvZCwgY2hlY2sgb3V0IHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vZ2V0UHJlbG9hZEhhbmRsZXJzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBpbiB0aGVcbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MuXG4gICAgICpcbiAgICAgKiBCZWZvcmUgYSBmaWxlIGlzIGxvYWRlZCwgYSBtYXRjaGluZyBwbHVnaW4gaGFzIGFuIG9wcG9ydHVuaXR5IHRvIG1vZGlmeSB0aGUgbG9hZC4gSWYgYSBgY2FsbGJhY2tgIGlzIHJldHVybmVkXG4gICAgICogZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2dldFByZWxvYWRIYW5kbGVyc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIGl0IHdpbGwgYmUgaW52b2tlZCBmaXJzdCwgYW5kIGl0c1xuICAgICAqIHJlc3VsdCBtYXkgY2FuY2VsIG9yIG1vZGlmeSB0aGUgaXRlbS4gVGhlIGNhbGxiYWNrIG1ldGhvZCBjYW4gYWxzbyByZXR1cm4gYSBgY29tcGxldGVIYW5kbGVyYCB0byBiZSBmaXJlZCB3aGVuXG4gICAgICogdGhlIGZpbGUgaXMgbG9hZGVkLCBvciBhIGB0YWdgIG9iamVjdCwgd2hpY2ggd2lsbCBtYW5hZ2UgdGhlIGFjdHVhbCBkb3dubG9hZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2VcbiAgICAgKiBtZXRob2RzLCBjaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9wcmVsb2FkSGFuZGxlclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2ZpbGVMb2FkSGFuZGxlclwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIG1ldGhvZHMgb24gdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5zdGFsbFBsdWdpblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHBsdWdpbiBUaGUgcGx1Z2luIGNsYXNzIHRvIGluc3RhbGwuXG4gICAgICovXG4gICAgcC5pbnN0YWxsUGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICBpZiAocGx1Z2luID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwbHVnaW4uZ2V0UHJlbG9hZEhhbmRsZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgdmFyIG1hcCA9IHBsdWdpbi5nZXRQcmVsb2FkSGFuZGxlcnMoKTtcbiAgICAgICAgICAgIG1hcC5zY29wZSA9IHBsdWdpbjtcblxuICAgICAgICAgICAgaWYgKG1hcC50eXBlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBtYXAudHlwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3R5cGVDYWxsYmFja3NbbWFwLnR5cGVzW2ldXSA9IG1hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXAuZXh0ZW5zaW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG1hcC5leHRlbnNpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHRlbnNpb25DYWxsYmFja3NbbWFwLmV4dGVuc2lvbnNbaV1dID0gbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgY29ubmVjdGlvbnMuIE5vdGUgdGhhdCBicm93c2VycyBhbmQgc2VydmVycyBtYXkgaGF2ZSBhIGJ1aWx0LWluIG1heGltdW1cbiAgICAgKiBudW1iZXIgb2Ygb3BlbiBjb25uZWN0aW9ucywgc28gYW55IGFkZGl0aW9uYWwgY29ubmVjdGlvbnMgbWF5IHJlbWFpbiBpbiBhIHBlbmRpbmcgc3RhdGUgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgKiBvcGVucyB0aGUgY29ubmVjdGlvbi4gV2hlbiBsb2FkaW5nIHNjcmlwdHMgdXNpbmcgdGFncywgYW5kIHdoZW4ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL21haW50YWluU2NyaXB0T3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBpcyBgdHJ1ZWAsIG9ubHkgb25lIHNjcmlwdCBpcyBsb2FkZWQgYXQgYSB0aW1lIGR1ZSB0byBicm93c2VyIGxpbWl0YXRpb25zLlxuICAgICAqXG4gICAgICogPGg0PkV4YW1wbGU8L2g0PlxuICAgICAqXG4gICAgICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG4gICAgICogICAgICBxdWV1ZS5zZXRNYXhDb25uZWN0aW9ucygxMCk7IC8vIEFsbG93IDEwIGNvbmN1cnJlbnQgbG9hZHNcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0TWF4Q29ubmVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiBjb25jdXJyZW50IGxvYWRzIHRvIGFsbG93LiBCeSBkZWZhdWx0LCBvbmx5IGEgc2luZ2xlIGNvbm5lY3Rpb24gcGVyIExvYWRRdWV1ZVxuICAgICAqIGlzIG9wZW4gYXQgYW55IHRpbWUuXG4gICAgICovXG4gICAgcC5zZXRNYXhDb25uZWN0aW9ucyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tYXhDb25uZWN0aW9ucyA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl9sb2FkUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZE5leHQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgc2luZ2xlIGZpbGUuIFRvIGFkZCBtdWx0aXBsZSBmaWxlcyBhdCBvbmNlLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiBGaWxlcyBhcmUgYWx3YXlzIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50IHF1ZXVlLCBzbyB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBtdWx0aXBsZSB0aW1lcyB0byBhZGQgZmlsZXMuXG4gICAgICogVG8gY2xlYXIgdGhlIHF1ZXVlIGZpcnN0LCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cbiAgICAgKiBAbWV0aG9kIGxvYWRGaWxlXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R8U3RyaW5nfSBmaWxlIFRoZSBmaWxlIG9iamVjdCBvciBwYXRoIHRvIGxvYWQuIEEgZmlsZSBjYW4gYmUgZWl0aGVyXG4gICAgICogPHVsPlxuICAgICAqICAgICA8bGk+QSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZTwvbGk+XG4gICAgICogICAgIDxsaT5BbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuICAgICAqICAgICA8bGk+T1IgQSBzdHJpbmcgcGF0aCB0byBhIHJlc291cmNlLiBOb3RlIHRoYXQgdGhpcyBraW5kIG9mIGxvYWQgaXRlbSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogICAgIGluIHRoZSBiYWNrZ3JvdW5kLjwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb2FkTm93PXRydWVdIEtpY2sgb2ZmIGFuIGltbWVkaWF0ZSBsb2FkICh0cnVlKSBvciB3YWl0IGZvciBhIGxvYWQgY2FsbCAoZmFsc2UpLiBUaGUgZGVmYXVsdFxuICAgICAqIHZhbHVlIGlzIHRydWUuIElmIHRoZSBxdWV1ZSBpcyBwYXVzZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHRoZSB2YWx1ZSBpc1xuICAgICAqIGB0cnVlYCwgdGhlIHF1ZXVlIHdpbGwgcmVzdW1lIGF1dG9tYXRpY2FsbHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gQSBiYXNlIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUuIFRoZSBiYXNlUGF0aCBhcmd1bWVudCBvdmVycmlkZXMgdGhlXG4gICAgICogcGF0aCBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLiBOb3RlIHRoYXQgaWYgeW91IGxvYWQgYSBtYW5pZmVzdCB1c2luZyBhIGZpbGUgb2YgdHlwZSB7eyNjcm9zc0xpbmsgXCJUeXBlcy9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcbiAgICAgKiBpdHMgZmlsZXMgd2lsbCA8c3Ryb25nPk5PVDwvc3Ryb25nPiB1c2UgdGhlIGJhc2VQYXRoIHBhcmFtZXRlci4gPHN0cm9uZz5UaGUgYmFzZVBhdGggcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQuPC9zdHJvbmc+XG4gICAgICogVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFBsZWFzZSBlaXRoZXIgdXNlIHRoZSBgYmFzZVBhdGhgIHBhcmFtZXRlciBpbiB0aGUgTG9hZFF1ZXVlXG4gICAgICogY29uc3RydWN0b3IsIG9yIGEgYHBhdGhgIHByb3BlcnR5IGluIGEgbWFuaWZlc3QgZGVmaW5pdGlvbi5cbiAgICAgKi9cbiAgICBwLmxvYWRGaWxlID0gZnVuY3Rpb24gKGZpbGUsIGxvYWROb3csIGJhc2VQYXRoKSB7XG4gICAgICAgIGlmIChmaWxlID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9OT19GSUxFXCIpO1xuICAgICAgICAgICAgdGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRJdGVtKGZpbGUsIG51bGwsIGJhc2VQYXRoKTtcblxuICAgICAgICBpZiAobG9hZE5vdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGF1c2VkKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvYWQgYW4gYXJyYXkgb2YgZmlsZXMuIFRvIGxvYWQgYSBzaW5nbGUgZmlsZSwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuICAgICAqIFRoZSBmaWxlcyBpbiB0aGUgbWFuaWZlc3QgYXJlIHJlcXVlc3RlZCBpbiB0aGUgc2FtZSBvcmRlciwgYnV0IG1heSBjb21wbGV0ZSBpbiBhIGRpZmZlcmVudCBvcmRlciBpZiB0aGUgbWF4XG4gICAgICogY29ubmVjdGlvbnMgYXJlIHNldCBhYm92ZSAxIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fS4gU2NyaXB0cyB3aWxsIGxvYWRcbiAgICAgKiBpbiB0aGUgcmlnaHQgb3JkZXIgYXMgbG9uZyBhcyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlclwifX17ey9jcm9zc0xpbmt9fSBpcyB0cnVlICh3aGljaCBpc1xuICAgICAqIGRlZmF1bHQpLlxuICAgICAqXG4gICAgICogRmlsZXMgYXJlIGFsd2F5cyBhcHBlbmRlZCB0byB0aGUgY3VycmVudCBxdWV1ZSwgc28gdGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgbXVsdGlwbGUgdGltZXMgdG8gYWRkIGZpbGVzLlxuICAgICAqIFRvIGNsZWFyIHRoZSBxdWV1ZSBmaXJzdCwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jbG9zZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG4gICAgICogQG1ldGhvZCBsb2FkTWFuaWZlc3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xPYmplY3R9IG1hbmlmZXN0IEFuIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZC4gVGhlIGxvYWRNYW5pZmVzdCBjYWxsIHN1cHBvcnRzIGZvdXIgdHlwZXMgb2ZcbiAgICAgKiBtYW5pZmVzdHM6XG4gICAgICogPG9sPlxuICAgICAqICAgICA8bGk+QSBzdHJpbmcgcGF0aCwgd2hpY2ggcG9pbnRzIHRvIGEgbWFuaWZlc3QgZmlsZSwgd2hpY2ggaXMgYSBKU09OIGZpbGUgdGhhdCBjb250YWlucyBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSxcbiAgICAgKiAgICAgd2hpY2ggZGVmaW5lcyB0aGUgbGlzdCBvZiBmaWxlcyB0byBsb2FkLCBhbmQgY2FuIG9wdGlvbmFsbHkgY29udGFpbiBhIFwicGF0aFwiIHByb3BlcnR5LCB3aGljaCB3aWxsIGJlXG4gICAgICogICAgIHByZXBlbmRlZCB0byBlYWNoIGZpbGUgaW4gdGhlIGxpc3QuPC9saT5cbiAgICAgKiAgICAgPGxpPkFuIG9iamVjdCB3aGljaCBkZWZpbmVzIGEgXCJzcmNcIiwgd2hpY2ggaXMgYSBKU09OIG9yIEpTT05QIGZpbGUuIEEgXCJjYWxsYmFja1wiIGNhbiBiZSBkZWZpbmVkIGZvciBKU09OUFxuICAgICAqICAgICBmaWxlLiBUaGUgSlNPTi9KU09OUCBmaWxlIHNob3VsZCBjb250YWluIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5LCB3aGljaCBkZWZpbmVzIHRoZSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQsXG4gICAgICogICAgIGFuZCBjYW4gb3B0aW9uYWxseSBjb250YWluIGEgXCJwYXRoXCIgcHJvcGVydHksIHdoaWNoIHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZSBpbiB0aGUgbGlzdC48L2xpPlxuICAgICAqICAgICA8bGk+QW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5LCB3aGljaCBkZWZpbmVzIHRoZSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQsIGFuZCBjYW5cbiAgICAgKiAgICAgb3B0aW9uYWxseSBjb250YWluIGEgXCJwYXRoXCIgcHJvcGVydHksIHdoaWNoIHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZSBpbiB0aGUgbGlzdC48L2xpPlxuICAgICAqICAgICA8bGk+QW4gQXJyYXkgb2YgZmlsZXMgdG8gbG9hZC48L2xpPlxuICAgICAqIDwvb2w+XG4gICAgICpcbiAgICAgKiBFYWNoIFwiZmlsZVwiIGluIGEgbWFuaWZlc3QgY2FuIGJlIGVpdGhlcjpcbiAgICAgKiA8dWw+XG4gICAgICogICAgIDxsaT5BIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlPC9saT5cbiAgICAgKiAgICAgPGxpPkFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgZGVmaW5lZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG4gICAgICogICAgIDxsaT5PUiBBIHN0cmluZyBwYXRoIHRvIGEgcmVzb3VyY2UuIE5vdGUgdGhhdCB0aGlzIGtpbmQgb2YgbG9hZCBpdGVtIHdpbGwgYmUgY29udmVydGVkIHRvIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiAgICAgaW4gdGhlIGJhY2tncm91bmQuPC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbG9hZE5vdz10cnVlXSBLaWNrIG9mZiBhbiBpbW1lZGlhdGUgbG9hZCAodHJ1ZSkgb3Igd2FpdCBmb3IgYSBsb2FkIGNhbGwgKGZhbHNlKS4gVGhlIGRlZmF1bHRcbiAgICAgKiB2YWx1ZSBpcyB0cnVlLiBJZiB0aGUgcXVldWUgaXMgcGF1c2VkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHRoaXMgdmFsdWUgaXNcbiAgICAgKiBgdHJ1ZWAsIHRoZSBxdWV1ZSB3aWxsIHJlc3VtZSBhdXRvbWF0aWNhbGx5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIEEgYmFzZSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlLiBUaGUgYmFzZVBhdGggYXJndW1lbnQgb3ZlcnJpZGVzIHRoZVxuICAgICAqIHBhdGggc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci4gTm90ZSB0aGF0IGlmIHlvdSBsb2FkIGEgbWFuaWZlc3QgdXNpbmcgYSBmaWxlIG9mIHR5cGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuICAgICAqIGl0cyBmaWxlcyB3aWxsIDxzdHJvbmc+Tk9UPC9zdHJvbmc+IHVzZSB0aGUgYmFzZVBhdGggcGFyYW1ldGVyLiA8c3Ryb25nPlRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZC48L3N0cm9uZz5cbiAgICAgKiBUaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gUGxlYXNlIGVpdGhlciB1c2UgdGhlIGBiYXNlUGF0aGAgcGFyYW1ldGVyIGluIHRoZSBMb2FkUXVldWVcbiAgICAgKiBjb25zdHJ1Y3Rvciwgb3IgYSBgcGF0aGAgcHJvcGVydHkgaW4gYSBtYW5pZmVzdCBkZWZpbml0aW9uLlxuICAgICAqL1xuICAgIHAubG9hZE1hbmlmZXN0ID0gZnVuY3Rpb24gKG1hbmlmZXN0LCBsb2FkTm93LCBiYXNlUGF0aCkge1xuICAgICAgICB2YXIgZmlsZUxpc3QgPSBudWxsO1xuICAgICAgICB2YXIgcGF0aCA9IG51bGw7XG5cbiAgICAgICAgLy8gQXJyYXktYmFzZWQgbGlzdCBvZiBpdGVtc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIGlmIChtYW5pZmVzdC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9FTVBUWVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGVMaXN0ID0gbWFuaWZlc3Q7XG5cbiAgICAgICAgICAgIC8vIFN0cmluZy1iYXNlZC4gT25seSBmaWxlIG1hbmlmZXN0cyBjYW4gYmUgc3BlY2lmaWVkIHRoaXMgd2F5LiBBbnkgb3RoZXIgdHlwZXMgd2lsbCBjYXVzZSBhbiBlcnJvciB3aGVuIGxvYWRlZC5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YobWFuaWZlc3QpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmaWxlTGlzdCA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNyYzogbWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHMuTUFOSUZFU1RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKG1hbmlmZXN0KSA9PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgICAgICAgIC8vIEFuIG9iamVjdCB0aGF0IGRlZmluZXMgYSBtYW5pZmVzdCBwYXRoXG4gICAgICAgICAgICBpZiAobWFuaWZlc3Quc3JjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFuaWZlc3QudHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0LnR5cGUgPSBzLk1BTklGRVNUO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWFuaWZlc3QudHlwZSAhPSBzLk1BTklGRVNUKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9UWVBFXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxlTGlzdCA9IFttYW5pZmVzdF07XG5cbiAgICAgICAgICAgICAgICAvLyBBbiBvYmplY3QgdGhhdCBkZWZpbmVzIGEgbWFuaWZlc3RcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWFuaWZlc3QubWFuaWZlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZpbGVMaXN0ID0gbWFuaWZlc3QubWFuaWZlc3Q7XG4gICAgICAgICAgICAgICAgcGF0aCA9IG1hbmlmZXN0LnBhdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVuc3VwcG9ydGVkLiBUaGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfTUFOSUZFU1RfTlVMTFwiKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZpbGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWRkSXRlbShmaWxlTGlzdFtpXSwgcGF0aCwgYmFzZVBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvYWROb3cgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhdXNlZChmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhdXNlZCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgTG9hZFF1ZXVlIHRoYXQgd2FzIGNyZWF0ZWQsIGJ1dCBub3QgYXV0b21hdGljYWxseSBzdGFydGVkLlxuICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAqL1xuICAgIHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb29rIHVwIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gdXNpbmcgZWl0aGVyIHRoZSBcImlkXCIgb3IgXCJzcmNcIiB0aGF0IHdhcyBzcGVjaWZpZWQgd2hlbiBsb2FkaW5nIGl0LiBOb3RlIHRoYXQgaWYgbm8gXCJpZFwiIHdhc1xuICAgICAqIHN1cHBsaWVkIHdpdGggdGhlIGxvYWQgaXRlbSwgdGhlIElEIHdpbGwgYmUgdGhlIFwic3JjXCIsIGluY2x1ZGluZyBhIGBwYXRoYCBwcm9wZXJ0eSBkZWZpbmVkIGJ5IGEgbWFuaWZlc3QuIFRoZVxuICAgICAqIGBiYXNlUGF0aGAgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgSUQuXG4gICAgICogQG1ldGhvZCBnZXRJdGVtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSA8Y29kZT5pZDwvY29kZT4gb3IgPGNvZGU+c3JjPC9jb2RlPiBvZiB0aGUgbG9hZCBpdGVtLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxvYWQgaXRlbSB0aGF0IHdhcyBpbml0aWFsbHkgcmVxdWVzdGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0uIFRoaXMgb2JqZWN0IGlzIGFsc28gcmV0dXJuZWQgdmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBldmVudCBhcyB0aGUgYGl0ZW1gIHBhcmFtZXRlci5cbiAgICAgKi9cbiAgICBwLmdldEl0ZW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRJdGVtc0J5SWRbdmFsdWVdIHx8IHRoaXMuX2xvYWRJdGVtc0J5U3JjW3ZhbHVlXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9vayB1cCBhIGxvYWRlZCByZXN1bHQgdXNpbmcgZWl0aGVyIHRoZSBcImlkXCIgb3IgXCJzcmNcIiB0aGF0IHdhcyBzcGVjaWZpZWQgd2hlbiBsb2FkaW5nIGl0LiBOb3RlIHRoYXQgaWYgbm8gXCJpZFwiXG4gICAgICogd2FzIHN1cHBsaWVkIHdpdGggdGhlIGxvYWQgaXRlbSwgdGhlIElEIHdpbGwgYmUgdGhlIFwic3JjXCIsIGluY2x1ZGluZyBhIGBwYXRoYCBwcm9wZXJ0eSBkZWZpbmVkIGJ5IGEgbWFuaWZlc3QuIFRoZVxuICAgICAqIGBiYXNlUGF0aGAgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgSUQuXG4gICAgICogQG1ldGhvZCBnZXRSZXN1bHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIDxjb2RlPmlkPC9jb2RlPiBvciA8Y29kZT5zcmM8L2NvZGU+IG9mIHRoZSBsb2FkIGl0ZW0uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmF3UmVzdWx0PWZhbHNlXSBSZXR1cm4gYSByYXcgcmVzdWx0IGluc3RlYWQgb2YgYSBmb3JtYXR0ZWQgcmVzdWx0LiBUaGlzIGFwcGxpZXMgdG8gY29udGVudFxuICAgICAqIGxvYWRlZCB2aWEgWEhSIHN1Y2ggYXMgc2NyaXB0cywgWE1MLCBDU1MsIGFuZCBJbWFnZXMuIElmIHRoZXJlIGlzIG5vIHJhdyByZXN1bHQsIHRoZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZCBpbnN0ZWFkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkLCBzdWNoIGFzOlxuICAgICAqIDx1bD5cbiAgICAgKiAgICAgIDxsaT5BbiBpbWFnZSB0YWcgKCZsdDtpbWFnZSAvJmd0OykgZm9yIGltYWdlczwvbGk+XG4gICAgICogICAgICA8bGk+QSBzY3JpcHQgdGFnIGZvciBKYXZhU2NyaXB0ICgmbHQ7c2NyaXB0IC8mZ3Q7KS4gTm90ZSB0aGF0IHNjcmlwdHMgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIEhUTUxcbiAgICAgKiAgICAgIERPTS48L2xpPlxuICAgICAqICAgICAgPGxpPkEgc3R5bGUgdGFnIGZvciBDU1MgKCZsdDtzdHlsZSAvJmd0OyBvciAmbHQ7bGluayAmZ3Q7KTwvbGk+XG4gICAgICogICAgICA8bGk+UmF3IHRleHQgZm9yIFRFWFQ8L2xpPlxuICAgICAqICAgICAgPGxpPkEgZm9ybWF0dGVkIEphdmFTY3JpcHQgb2JqZWN0IGRlZmluZWQgYnkgSlNPTjwvbGk+XG4gICAgICogICAgICA8bGk+QW4gWE1MIGRvY3VtZW50PC9saT5cbiAgICAgKiAgICAgIDxsaT5BIGJpbmFyeSBhcnJheWJ1ZmZlciBsb2FkZWQgYnkgWEhSPC9saT5cbiAgICAgKiAgICAgIDxsaT5BbiBhdWRpbyB0YWcgKCZsdDthdWRpbyAmZ3Q7KSBmb3IgSFRNTCBhdWRpby4gTm90ZSB0aGF0IGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBTb3VuZEpTIEFQSXMgdG8gcGxheVxuICAgICAqICAgICAgbG9hZGVkIGF1ZGlvLiBTcGVjaWZpY2FsbHksIGF1ZGlvIGxvYWRlZCBieSBGbGFzaCBhbmQgV2ViQXVkaW8gd2lsbCByZXR1cm4gYSBsb2FkZXIgb2JqZWN0IHVzaW5nIHRoaXMgbWV0aG9kXG4gICAgICogICAgICB3aGljaCBjYW4gbm90IGJlIHVzZWQgdG8gcGxheSBhdWRpbyBiYWNrLjwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKiBUaGlzIG9iamVjdCBpcyBhbHNvIHJldHVybmVkIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGFzIHRoZSAnaXRlbWBcbiAgICAgKiBwYXJhbWV0ZXIuIE5vdGUgdGhhdCBpZiBhIHJhdyByZXN1bHQgaXMgcmVxdWVzdGVkLCBidXQgbm90IGZvdW5kLCB0aGUgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBwLmdldFJlc3VsdCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmF3UmVzdWx0KSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5fbG9hZEl0ZW1zQnlJZFt2YWx1ZV0gfHwgdGhpcy5fbG9hZEl0ZW1zQnlTcmNbdmFsdWVdO1xuICAgICAgICBpZiAoaXRlbSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWQgPSBpdGVtLmlkO1xuICAgICAgICBpZiAocmF3UmVzdWx0ICYmIHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZFJlc3VsdHNbaWRdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBsaXN0IG9mIGl0ZW1zIGxvYWRlZCBieSB0aGlzIHF1ZXVlLlxuICAgICAqIEBtZXRob2QgZ2V0SXRlbXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvYWRlZCBEZXRlcm1pbmVzIGlmIG9ubHkgaXRlbXMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkIHNob3VsZCBiZSByZXR1cm5lZC4gSWYgZmFsc2UsIGluLXByb2dyZXNzXG4gICAgICogYW5kIGZhaWxlZCBsb2FkIGl0ZW1zIHdpbGwgYWxzbyBiZSBpbmNsdWRlZC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbGlzdCBvZiBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGxvYWRlZC4gRWFjaCBpdGVtIGluY2x1ZGVzIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSxcbiAgICAgKiByZXN1bHQsIGFuZCByYXdSZXN1bHQuXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICovXG4gICAgcC5nZXRJdGVtcyA9IGZ1bmN0aW9uIChsb2FkZWQpIHtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuIGluIHRoaXMuX2xvYWRJdGVtc0J5SWQpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fbG9hZEl0ZW1zQnlJZFtuXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdldFJlc3VsdChuKTtcbiAgICAgICAgICAgIGlmIChsb2FkZWQgPT09IHRydWUgJiYgcmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyci5wdXNoKHtcbiAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgIHJhd1Jlc3VsdDogdGhpcy5nZXRSZXN1bHQobiwgdHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhdXNlIG9yIHJlc3VtZSB0aGUgY3VycmVudCBsb2FkLiBBY3RpdmUgbG9hZHMgd2lsbCBub3QgYmUgY2FuY2VsbGVkLCBidXQgdGhlIG5leHQgaXRlbXMgaW4gdGhlIHF1ZXVlIHdpbGwgbm90XG4gICAgICogYmUgcHJvY2Vzc2VkIHdoZW4gYWN0aXZlIGxvYWRzIGNvbXBsZXRlLiBMb2FkUXVldWVzIGFyZSBub3QgcGF1c2VkIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaWYgbmV3IGl0ZW1zIGFyZSBhZGRlZCB0byB0aGUgcXVldWUgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG9yXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSwgYSBwYXVzZWQgcXVldWUgd2lsbCBiZSByZXN1bWVkLCB1bmxlc3MgdGhlIGBsb2FkTm93YFxuICAgICAqIGFyZ3VtZW50IGlzIGBmYWxzZWAuXG4gICAgICogQG1ldGhvZCBzZXRQYXVzZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFdoZXRoZXIgdGhlIHF1ZXVlIHNob3VsZCBiZSBwYXVzZWQgb3Igbm90LlxuICAgICAqL1xuICAgIHAuc2V0UGF1c2VkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZE5leHQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgYWN0aXZlIHF1ZXVlLiBDbG9zaW5nIGEgcXVldWUgY29tcGxldGVseSBlbXB0aWVzIHRoZSBxdWV1ZSwgYW5kIHByZXZlbnRzIGFueSByZW1haW5pbmcgaXRlbXMgZnJvbVxuICAgICAqIHN0YXJ0aW5nIHRvIGRvd25sb2FkLiBOb3RlIHRoYXQgY3VycmVudGx5IGFueSBhY3RpdmUgbG9hZHMgd2lsbCByZW1haW4gb3BlbiwgYW5kIGV2ZW50cyBtYXkgYmUgcHJvY2Vzc2VkLlxuICAgICAqXG4gICAgICogVG8gc3RvcCBhbmQgcmVzdGFydCBhIHF1ZXVlLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGluc3RlYWQuXG4gICAgICogQG1ldGhvZCBjbG9zZVxuICAgICAqL1xuICAgIHAuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TG9hZHMucG9wKCkuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2NyaXB0T3JkZXIubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fbG9hZGVkU2NyaXB0cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxvYWRTdGFydFdhc0Rpc3BhdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXRlbUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0gTmFOO1xuICAgIH07XG5cbi8vIHByb3RlY3RlZCBtZXRob2RzXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGl0ZW0gdG8gdGhlIHF1ZXVlLiBJdGVtcyBhcmUgZm9ybWF0dGVkIGludG8gYSB1c2FibGUgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBwcm9wZXJ0aWVzIG5lY2Vzc2FyeSB0b1xuICAgICAqIGxvYWQgdGhlIGNvbnRlbnQuIFRoZSBsb2FkIHF1ZXVlIGlzIHBvcHVsYXRlZCB3aXRoIHRoZSBsb2FkZXIgaW5zdGFuY2UgdGhhdCBoYW5kbGVzIHByZWxvYWRpbmcsIGFuZCBub3QgdGhlIGxvYWRcbiAgICAgKiBpdGVtIHRoYXQgd2FzIHBhc3NlZCBpbiBieSB0aGUgdXNlci4gVG8gbG9vayB1cCB0aGUgbG9hZCBpdGVtIGJ5IGlkIG9yIHNyYywgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUuZ2V0SXRlbVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIG1ldGhvZC5cbiAgICAgKiBAbWV0aG9kIF9hZGRJdGVtXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIHF1ZXVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gQW4gb3B0aW9uYWwgcGF0aCBwcmVwZW5kZWQgdG8gdGhlIGBzcmNgLiBUaGUgcGF0aCB3aWxsIG9ubHkgYmUgcHJlcGVuZGVkIGlmIHRoZSBzcmMgaXNcbiAgICAgKiByZWxhdGl2ZSwgYW5kIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBwcm90b2NvbCBzdWNoIGFzIGBodHRwOi8vYCwgb3IgYSBwYXRoIGxpa2UgYC4uL2AuIElmIHRoZSBMb2FkUXVldWUgd2FzXG4gICAgICogcHJvdmlkZWQgYSB7eyNjcm9zc0xpbmsgXCJfYmFzZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0sIHRoZW4gaXQgd2lsbCBvcHRpb25hbGx5IGJlIHByZXBlbmRlZCBhZnRlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSA8c3Ryb25nPkRlcHJlY2F0ZWQ8L3N0cm9uZz5BbiBvcHRpb25hbCBiYXNlUGF0aCBwYXNzZWQgaW50byBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHRhZ2dlZFxuICAgICAqIHZlcnNpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9hZGRJdGVtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2NyZWF0ZUxvYWRJdGVtKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCk7IC8vIGJhc2VQYXRoIGFuZCBtYW5pZmVzdCBwYXRoIGFyZSBhZGRlZCB0byB0aGUgc3JjLlxuICAgICAgICBpZiAoaXRlbSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU29tZXRpbWVzIHBsdWdpbnMgb3IgdHlwZXMgc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgICAgIHZhciBsb2FkZXIgPSB0aGlzLl9jcmVhdGVMb2FkZXIoaXRlbSk7XG4gICAgICAgIGlmIChsb2FkZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFwicGx1Z2luc1wiIGluIGxvYWRlcikge1xuICAgICAgICAgICAgICAgIGxvYWRlci5wbHVnaW5zID0gdGhpcy5fcGx1Z2lucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0uX2xvYWRlciA9IGxvYWRlcjtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRRdWV1ZS5wdXNoKGxvYWRlcik7XG4gICAgICAgICAgICB0aGlzLl9sb2FkUXVldWVCYWNrdXAucHVzaChsb2FkZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9udW1JdGVtcysrO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblxuICAgICAgICAgICAgLy8gT25seSB3b3JyeSBhYm91dCBzY3JpcHQgb3JkZXIgd2hlbiB1c2luZyBYSFIgdG8gbG9hZCBzY3JpcHRzLiBUYWdzIGFyZSBvbmx5IGxvYWRpbmcgb25lIGF0IGEgdGltZS5cbiAgICAgICAgICAgIGlmICgodGhpcy5tYWludGFpblNjcmlwdE9yZGVyXG4gICAgICAgICAgICAgICAgICAgICYmIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5KQVZBU0NSSVBUXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyYmIGxvYWRlciBpbnN0YW5jZW9mIGNyZWF0ZWpzLlhIUkxvYWRlciAvL05PVEU6IEhhdmUgdG8gdHJhY2sgYWxsIEpTIGZpbGVzIHRoaXMgd2F5XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfHwgaXRlbS5tYWludGFpbk9yZGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NyaXB0T3JkZXIucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZWRTY3JpcHRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVmaW5lZCB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSwgd2hpY2ggY29udGFpbnMgYWxsIHRoZSByZXF1aXJlZCBwcm9wZXJ0aWVzLiBUaGUgdHlwZSBvZlxuICAgICAqIGl0ZW0gaXMgZGV0ZXJtaW5lZCBieSBicm93c2VyIHN1cHBvcnQsIHJlcXVpcmVtZW50cyBiYXNlZCBvbiB0aGUgZmlsZSB0eXBlLCBhbmQgZGV2ZWxvcGVyIHNldHRpbmdzLiBGb3IgZXhhbXBsZSxcbiAgICAgKiBYSFIgaXMgb25seSB1c2VkIGZvciBmaWxlIHR5cGVzIHRoYXQgc3VwcG9ydCBpdCBpbiBuZXcgYnJvd3NlcnMuXG4gICAgICpcbiAgICAgKiBCZWZvcmUgdGhlIGl0ZW0gaXMgcmV0dXJuZWQsIGFueSBwbHVnaW5zIHJlZ2lzdGVyZWQgdG8gaGFuZGxlIHRoZSB0eXBlIG9yIGV4dGVuc2lvbiB3aWxsIGJlIGZpcmVkLCB3aGljaCBtYXlcbiAgICAgKiBhbHRlciB0aGUgbG9hZCBpdGVtLlxuICAgICAqIEBtZXRob2QgX2NyZWF0ZUxvYWRJdGVtXG4gICAgICogQHBhcmFtIHtTdHJpbmcgfCBPYmplY3QgfCBIVE1MQXVkaW9FbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudH0gdmFsdWUgVGhlIGl0ZW0gdGhhdCBuZWVkcyB0byBiZSBwcmVsb2FkZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBBIHBhdGggdG8gcHJlcGVuZCB0byB0aGUgaXRlbSdzIHNvdXJjZS4gU291cmNlcyBiZWdpbm5pbmcgd2l0aCBodHRwOi8vIG9yIHNpbWlsYXIgd2lsbFxuICAgICAqIG5vdCByZWNlaXZlIGEgcGF0aC4gU2luY2UgUHJlbG9hZEpTIDAuNC4xLCB0aGUgc3JjIHdpbGwgYmUgbW9kaWZpZWQgdG8gaW5jbHVkZSB0aGUgYHBhdGhgIGFuZCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvX2Jhc2VQYXRoOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogd2hlbiBpdCBpcyBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSA8c3Ryb25nPkRlcHJlY3RhdGVkPC9zdHJvbmc+IEEgYmFzZSBwYXRoIHRvIHByZXBlbmQgdG8gdGhlIGl0ZW1zIHNvdXJjZSBpbiBhZGRpdGlvbiB0b1xuICAgICAqIHRoZSBwYXRoIGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxvYWRlciBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2NyZWF0ZUxvYWRJdGVtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IGNyZWF0ZWpzLkxvYWRJdGVtLmNyZWF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChpdGVtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJwID0gXCJcIjsgLy8gU3RvcmUgdGhlIGdlbmVyYXRlZCBiYXNlUGF0aFxuICAgICAgICB2YXIgdXNlQmFzZVBhdGggPSBiYXNlUGF0aCB8fCB0aGlzLl9iYXNlUGF0aDtcblxuICAgICAgICBpZiAoaXRlbS5zcmMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghaXRlbS50eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IC8vIHRoZSB0aGUgc3JjIGlzIGFuIG9iamVjdCwgdHlwZSBpcyByZXF1aXJlZCB0byBwYXNzIG9mZiB0byBwbHVnaW5cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgYnAgPSBwYXRoO1xuICAgICAgICAgICAgICAgIHZhciBwYXRoTWF0Y2ggPSBjcmVhdGVqcy5VUkxVdGlscy5wYXJzZVVSSShwYXRoKTtcbiAgICAgICAgICAgICAgICAvLyBBbHNvIGFwcGVuZCBiYXNlUGF0aFxuICAgICAgICAgICAgICAgIGlmICh1c2VCYXNlUGF0aCAhPSBudWxsICYmICFwYXRoTWF0Y2guYWJzb2x1dGUgJiYgIXBhdGhNYXRjaC5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBicCA9IHVzZUJhc2VQYXRoICsgYnA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh1c2VCYXNlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnAgPSB1c2VCYXNlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSBFeHRlbnNpb24sIGV0Yy5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGNyZWF0ZWpzLlVSTFV0aWxzLnBhcnNlVVJJKGl0ZW0uc3JjKTtcbiAgICAgICAgICAgIGlmIChtYXRjaC5leHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmV4dCA9IG1hdGNoLmV4dGVuc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZW0udHlwZSA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5nZXRUeXBlQnlFeHRlbnNpb24oaXRlbS5leHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbmplY3QgcGF0aCAmIGJhc2VQYXRoXG4gICAgICAgICAgICB2YXIgYXV0b0lkID0gaXRlbS5zcmM7XG4gICAgICAgICAgICBpZiAoIW1hdGNoLmFic29sdXRlICYmICFtYXRjaC5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJwID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhNYXRjaCA9IGNyZWF0ZWpzLlVSTFV0aWxzLnBhcnNlVVJJKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvSWQgPSBwYXRoICsgYXV0b0lkO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIGFwcGVuZCBiYXNlUGF0aFxuICAgICAgICAgICAgICAgICAgICBpZiAodXNlQmFzZVBhdGggIT0gbnVsbCAmJiAhcGF0aE1hdGNoLmFic29sdXRlICYmICFwYXRoTWF0Y2gucmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJwID0gdXNlQmFzZVBhdGggKyBicDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlQmFzZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBicCA9IHVzZUJhc2VQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0uc3JjID0gYnAgKyBpdGVtLnNyYztcbiAgICAgICAgfVxuICAgICAgICBpdGVtLnBhdGggPSBicDtcblxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGlkLCBzZXQgb25lIG5vdy5cbiAgICAgICAgaWYgKGl0ZW0uaWQgPT09IHVuZGVmaW5lZCB8fCBpdGVtLmlkID09PSBudWxsIHx8IGl0ZW0uaWQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGl0ZW0uaWQgPSBhdXRvSWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHaXZlIHBsdWdpbnMgYSBjaGFuY2UgdG8gbW9kaWZ5IHRoZSBsb2FkSXRlbTpcbiAgICAgICAgdmFyIGN1c3RvbUhhbmRsZXIgPSB0aGlzLl90eXBlQ2FsbGJhY2tzW2l0ZW0udHlwZV0gfHwgdGhpcy5fZXh0ZW5zaW9uQ2FsbGJhY2tzW2l0ZW0uZXh0XTtcbiAgICAgICAgaWYgKGN1c3RvbUhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIFBsdWdpbnMgYXJlIG5vdyBwYXNzZWQgYm90aCB0aGUgZnVsbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBjb21iaW5lZCBwYXRoK2Jhc2VQYXRoIChhcHByb3ByaWF0ZWx5KVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbUhhbmRsZXIuY2FsbGJhY2suY2FsbChjdXN0b21IYW5kbGVyLnNjb3BlLCBpdGVtLCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gVGhlIHBsdWdpbiB3aWxsIGhhbmRsZSB0aGUgbG9hZCwgb3IgaGFzIGNhbmNlbGVkIGl0LiBJZ25vcmUgaXQuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gTG9hZCBhcyBub3JtYWw6XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIERvIE5vdGhpbmdcblxuICAgICAgICAgICAgICAgIC8vIFJlc3VsdCBpcyBhIGxvYWRlciBjbGFzczpcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVtLl9sb2FkZXIgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXh0ZW5zaW9uIGluIGNhc2UgdGhlIHR5cGUgY2hhbmdlZDpcbiAgICAgICAgICAgIG1hdGNoID0gY3JlYXRlanMuVVJMVXRpbHMucGFyc2VVUkkoaXRlbS5zcmMpO1xuICAgICAgICAgICAgaWYgKG1hdGNoLmV4dGVuc2lvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5leHQgPSBtYXRjaC5leHRlbnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSB0aGUgaXRlbSBmb3IgbG9va3VwLiBUaGlzIGFsc28gaGVscHMgY2xlYW4tdXAgbGF0ZXIuXG4gICAgICAgIHRoaXMuX2xvYWRJdGVtc0J5SWRbaXRlbS5pZF0gPSBpdGVtO1xuICAgICAgICB0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY10gPSBpdGVtO1xuXG4gICAgICAgIGlmIChpdGVtLmNyb3NzT3JpZ2luID09IG51bGwpIHtcbiAgICAgICAgICAgIGl0ZW0uY3Jvc3NPcmlnaW4gPSB0aGlzLl9jcm9zc09yaWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBsb2FkZXIgZm9yIGEgbG9hZCBpdGVtLlxuICAgICAqIEBtZXRob2QgX2NyZWF0ZUxvYWRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIEEgZm9ybWF0dGVkIGxvYWQgaXRlbSB0aGF0IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgbG9hZGVyLlxuICAgICAqIEByZXR1cm4ge0Fic3RyYWN0TG9hZGVyfSBBIGxvYWRlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGxvYWQgY29udGVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2NyZWF0ZUxvYWRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLl9sb2FkZXIgIT0gbnVsbCkgeyAvLyBBIHBsdWdpbiBhbHJlYWR5IHNwZWNpZmllZCBhIGxvYWRlclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uX2xvYWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxseSwgdHJ5IGFuZCB1c2UgdGhlIHByb3ZpZGVkL3N1cHBvcnRlZCBYSFIgbW9kZTpcbiAgICAgICAgdmFyIHByZWZlclhIUiA9IHRoaXMucHJlZmVyWEhSO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYXZhaWxhYmxlTG9hZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvYWRlciA9IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnNbaV07XG4gICAgICAgICAgICBpZiAobG9hZGVyICYmIGxvYWRlci5jYW5Mb2FkSXRlbShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbG9hZGVyKGl0ZW0sIHByZWZlclhIUik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBMb2cgZXJyb3IgKHJlcXVpcmVzIGNyZWF0ZWpzLmxvZylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIG5leHQgaXRlbSBpbiB0aGUgcXVldWUuIElmIHRoZSBxdWV1ZSBpcyBlbXB0eSAoYWxsIGl0ZW1zIGhhdmUgYmVlbiBsb2FkZWQpLCB0aGVuIHRoZSBjb21wbGV0ZSBldmVudFxuICAgICAqIGlzIHByb2Nlc3NlZC4gVGhlIHF1ZXVlIHdpbGwgXCJmaWxsIHVwXCIgYW55IGVtcHR5IHNsb3RzLCB1cCB0byB0aGUgbWF4IGNvbm5lY3Rpb24gc3BlY2lmaWVkIHVzaW5nXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlLnNldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC4gVGhlIG9ubHkgZXhjZXB0aW9uIGlzIHNjcmlwdHMgdGhhdCBhcmUgbG9hZGVkXG4gICAgICogdXNpbmcgdGFncywgd2hpY2ggaGF2ZSB0byBiZSBsb2FkZWQgb25lIGF0IGEgdGltZSB0byBtYWludGFpbiBsb2FkIG9yZGVyLlxuICAgICAqIEBtZXRob2QgX2xvYWROZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9sb2FkTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBkaXNwYXRjaCBsb2Fkc3RhcnQgZXZlbnQgd2hlbiB0aGUgZmlyc3QgZmlsZSBpcyBsb2FkZWQuXG4gICAgICAgIGlmICghdGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VuZExvYWRTdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcXVldWUgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgaWYgKHRoaXMuX251bUl0ZW1zID09IHRoaXMuX251bUl0ZW1zTG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29tcGxldGUoKTtcblxuICAgICAgICAgICAgLy8gTG9hZCB0aGUgbmV4dCBxdWV1ZSwgaWYgaXQgaGFzIGJlZW4gZGVmaW5lZC5cbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQgJiYgdGhpcy5uZXh0LmxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQubG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE11c3QgaXRlcmF0ZSBmb3J3YXJkcyB0byBsb2FkIGluIHRoZSByaWdodCBvcmRlci5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sb2FkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoID49IHRoaXMuX21heENvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5fbG9hZFF1ZXVlW2ldO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGJlIG9ubHkgbG9hZGluZyBvbmUgdGFnLXNjcmlwdCBhdCBhIHRpbWU6XG4gICAgICAgICAgICAvLyBOb3RlOiBtYWludGFpbk9yZGVyIGl0ZW1zIGRvbid0IGRvIGFueXRoaW5nIGhlcmUgYmVjYXVzZSB3ZSBjYW4gaG9sZCBvbnRvIHRoZWlyIGxvYWRlZCB2YWx1ZVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYW5TdGFydExvYWQobG9hZGVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9hZFF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRJdGVtKGxvYWRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQmVnaW4gbG9hZGluZyBhbiBpdGVtLiBFdmVudCBsaXN0ZW5lcnMgYXJlIG5vdCBhZGRlZCB0byB0aGUgbG9hZGVycyB1bnRpbCB0aGUgbG9hZCBzdGFydHMuXG4gICAgICogQG1ldGhvZCBfbG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIGxvYWRlciBpbnN0YW5jZSB0byBzdGFydC4gQ3VycmVudGx5LCB0aGlzIHdpbGwgYmUgYW4gWEhSTG9hZGVyIG9yIFRhZ0xvYWRlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2xvYWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIub24oXCJmaWxlbG9hZFwiLCB0aGlzLl9oYW5kbGVGaWxlTG9hZCwgdGhpcyk7XG4gICAgICAgIGxvYWRlci5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZVByb2dyZXNzLCB0aGlzKTtcbiAgICAgICAgbG9hZGVyLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlRmlsZUNvbXBsZXRlLCB0aGlzKTtcbiAgICAgICAgbG9hZGVyLm9uKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlRXJyb3IsIHRoaXMpO1xuICAgICAgICBsb2FkZXIub24oXCJmaWxlZXJyb3JcIiwgdGhpcy5faGFuZGxlRmlsZUVycm9yLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fY3VycmVudExvYWRzLnB1c2gobG9hZGVyKTtcbiAgICAgICAgdGhpcy5fc2VuZEZpbGVTdGFydChsb2FkZXIuZ2V0SXRlbSgpKTtcbiAgICAgICAgbG9hZGVyLmxvYWQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBsb2FkcyBhIGZpbGUuIFRoaXMgZW5hYmxlcyBsb2FkZXJzIGxpa2Uge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiB0byBtYWludGFpbiBpbnRlcm5hbCBxdWV1ZXMsIGJ1dCBmb3IgdGhpcyBxdWV1ZSB0byBkaXNwYXRjaCB0aGUge3sjY3Jvc3NMaW5rIFwiZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBldmVudHMuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZyb20gdGhlIGxvYWRlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqL1xuICAgIHAuX2hhbmRsZUZpbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvciBmcm9tIGFuIGludGVybmFsIGZpbGUgbG9hZCBvcGVyYXRpb24uIFRoaXMgZW5hYmxlc1xuICAgICAqIGxvYWRlcnMgbGlrZSBNXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVGaWxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJGSUxFX0xPQURfRVJST1JcIiwgbnVsbCwgZXZlbnQuaXRlbSk7XG4gICAgICAgIHRoaXMuX3NlbmRFcnJvcihuZXdFdmVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvci4gVGhlIHF1ZXVlIHdpbGwgY29udGludWUgbG9hZGluZyB1bmxlc3Mge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3N0b3BPbkVycm9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogaXMgc2V0IHRvIGB0cnVlYC5cbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuICAgICAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnQgVGhlIGVycm9yIGV2ZW50LCBjb250YWluaW5nIHJlbGV2YW50IGVycm9yIGluZm9ybWF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgdGhpcy5fbnVtSXRlbXNMb2FkZWQrKztcblxuICAgICAgICB0aGlzLl9maW5pc2hPcmRlcmVkSXRlbShsb2FkZXIsIHRydWUpO1xuICAgICAgICB0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXG4gICAgICAgIHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiRklMRV9MT0FEX0VSUk9SXCIsIG51bGwsIGxvYWRlci5nZXRJdGVtKCkpO1xuICAgICAgICAvLyBUT0RPOiBQcm9wYWdhdGUgYWN0dWFsIGVycm9yIG1lc3NhZ2UuXG5cbiAgICAgICAgdGhpcy5fc2VuZEVycm9yKG5ld0V2ZW50KTtcblxuICAgICAgICBpZiAoIXRoaXMuc3RvcE9uRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxvYWRJdGVtKGxvYWRlcik7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbkxvYWRJdGVtKGxvYWRlcik7XG4gICAgICAgICAgICB0aGlzLl9sb2FkTmV4dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQW4gaXRlbSBoYXMgZmluaXNoZWQgbG9hZGluZy4gV2UgY2FuIGFzc3VtZSB0aGF0IGl0IGlzIHRvdGFsbHkgbG9hZGVkLCBoYXMgYmVlbiBwYXJzZWQgZm9yIGltbWVkaWF0ZSB1c2UsIGFuZFxuICAgICAqIGlzIGF2YWlsYWJsZSBhcyB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eSBvbiB0aGUgbG9hZCBpdGVtLiBUaGUgcmF3IHRleHQgcmVzdWx0IGZvciBhIHBhcnNlZCBpdGVtIChzdWNoIGFzIEpTT04sIFhNTCxcbiAgICAgKiBDU1MsIEphdmFTY3JpcHQsIGV0YykgaXMgYXZhaWxhYmxlIGFzIHRoZSBcInJhd1Jlc3VsdFwiIHByb3BlcnR5LCBhbmQgY2FuIGFsc28gYmUgbG9va2VkIHVwIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9nZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQG1ldGhvZCBfaGFuZGxlRmlsZUNvbXBsZXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBsb2FkZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVGaWxlQ29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgdmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBsb2FkZXIuZ2V0UmVzdWx0KCk7XG4gICAgICAgIHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF0gPSByZXN1bHQ7XG4gICAgICAgIHZhciByYXdSZXN1bHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuICAgICAgICBpZiAocmF3UmVzdWx0ICE9IG51bGwgJiYgcmF3UmVzdWx0ICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF0gPSByYXdSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zYXZlTG9hZGVkSXRlbXMobG9hZGVyKTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxvYWQgaXRlbVxuICAgICAgICB0aGlzLl9yZW1vdmVMb2FkSXRlbShsb2FkZXIpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoT3JkZXJlZEl0ZW0obG9hZGVyKSkge1xuICAgICAgICAgICAgLy8gVGhlIGl0ZW0gd2FzIE5PVCBtYW5hZ2VkLCBzbyBwcm9jZXNzIGl0IG5vd1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0ZpbmlzaGVkTG9hZChpdGVtLCBsb2FkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGxvYWQgaXRlbVxuICAgICAgICB0aGlzLl9jbGVhbkxvYWRJdGVtKGxvYWRlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNvbWUgbG9hZGVycyBtaWdodCBsb2FkIGFkZGl0aW9uYWwgY29udGVudCwgb3RoZXIgdGhhbiB0aGUgaXRlbSB0aGV5IHdlcmUgcGFzc2VkIChzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319KS5cbiAgICAgKiBBbnkgaXRlbXMgZXhwb3NlZCBieSB0aGUgbG9hZGVyIHVzaW5nIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2dldExvYWRJdGVtc1wifX17ey9jcm9zc0xpbmt9fSBhcmUgYWRkZWQgdG8gdGhlXG4gICAgICogTG9hZFF1ZXVlJ3MgbG9vay11cHMsIGluY2x1ZGluZyB7eyNjcm9zc0xpbmsgXCJnZXRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBtZXRob2RzLlxuICAgICAqIEBtZXRob2QgX3NhdmVMb2FkZWRJdGVtc1xuICAgICAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKi9cbiAgICBwLl9zYXZlTG9hZGVkSXRlbXMgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgIC8vIFRPRE86IE5vdCBzdXJlIGhvdyB0byBoYW5kbGUgdGhpcy4gV291bGQgYmUgbmljZSB0byBleHBvc2UgdGhlIGl0ZW1zLlxuICAgICAgICAvLyBMb2FkZXJzIG1heSBsb2FkIHN1Yi1pdGVtcy4gVGhpcyBhZGRzIHRoZW0gdG8gdGhpcyBxdWV1ZVxuICAgICAgICB2YXIgbGlzdCA9IGxvYWRlci5nZXRMb2FkZWRJdGVtcygpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGxpc3RbaV0uaXRlbTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgaXRlbSBsb29rdXBzXG4gICAgICAgICAgICB0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY10gPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXSA9IGl0ZW07XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIGxvYWRlZCBjb250ZW50XG4gICAgICAgICAgICB0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdID0gbGlzdFtpXS5yZXN1bHQ7XG4gICAgICAgICAgICB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdID0gbGlzdFtpXS5yYXdSZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmxhZyBhbiBpdGVtIGFzIGZpbmlzaGVkLiBJZiB0aGUgaXRlbSdzIG9yZGVyIGlzIGJlaW5nIG1hbmFnZWQsIHRoZW4gZW5zdXJlIHRoYXQgaXQgaXMgYWxsb3dlZCB0byBmaW5pc2gsIGFuZCBpZlxuICAgICAqIHNvLCB0cmlnZ2VyIHByaW9yIGl0ZW1zIHRvIHRyaWdnZXIgYXMgd2VsbC5cbiAgICAgKiBAbWV0aG9kIF9maW5pc2hPcmRlcmVkSXRlbVxuICAgICAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9hZEZhaWxlZFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBpdGVtJ3Mgb3JkZXIgaXMgYmVpbmcgbWFuYWdlZC4gVGhpcyBhbGxvd3MgdGhlIGNhbGxlciB0byB0YWtlIGFuIGFsdGVybmF0ZVxuICAgICAqIGJlaGF2aW91ciBpZiBpdCBpcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2ZpbmlzaE9yZGVyZWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlciwgbG9hZEZhaWxlZCkge1xuICAgICAgICB2YXIgaXRlbSA9IGxvYWRlci5nZXRJdGVtKCk7XG5cbiAgICAgICAgaWYgKCh0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgJiYgaXRlbS50eXBlID09IGNyZWF0ZWpzLlR5cGVzLkpBVkFTQ1JJUFQpXG4gICAgICAgICAgICAgICAgfHwgaXRlbS5tYWludGFpbk9yZGVyKSB7XG5cbiAgICAgICAgICAgIC8vVE9ETzogRXZhbHVhdGUgcmVtb3ZhbCBvZiB0aGUgX2N1cnJlbnRseUxvYWRpbmdTY3JpcHRcbiAgICAgICAgICAgIGlmIChsb2FkZXIgaW5zdGFuY2VvZiBjcmVhdGVqcy5KYXZhU2NyaXB0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX3NjcmlwdE9yZGVyLCBpdGVtKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gLy8gVGhpcyBsb2FkZXIgbm8gbG9uZ2VyIGV4aXN0c1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVkU2NyaXB0c1tpbmRleF0gPSAobG9hZEZhaWxlZCA9PT0gdHJ1ZSkgPyB0cnVlIDogaXRlbTtcblxuICAgICAgICAgICAgdGhpcy5fY2hlY2tTY3JpcHRMb2FkT3JkZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhlIHNjcmlwdHMgbG9hZCBhbmQgZGlzcGF0Y2ggaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFdoZW4gdXNpbmcgWEhSLCBzY3JpcHRzIGFyZSBzdG9yZWQgaW4gYW4gYXJyYXkgaW4gdGhlXG4gICAgICogb3JkZXIgdGhleSB3ZXJlIGFkZGVkLCBidXQgd2l0aCBhIFwibnVsbFwiIHZhbHVlLiBXaGVuIHRoZXkgYXJlIGNvbXBsZXRlZCwgdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgbG9hZCBpdGVtLFxuICAgICAqIGFuZCB0aGVuIHdoZW4gdGhleSBhcmUgcHJvY2Vzc2VkIGFuZCBkaXNwYXRjaGVkLCB0aGUgdmFsdWUgaXMgc2V0IHRvIGB0cnVlYC4gVGhpcyBtZXRob2Qgc2ltcGx5XG4gICAgICogaXRlcmF0ZXMgdGhlIGFycmF5LCBhbmQgZW5zdXJlcyB0aGF0IGFueSBsb2FkZWQgaXRlbXMgdGhhdCBhcmUgbm90IHByZWNlZGVkIGJ5IGEgYG51bGxgIHZhbHVlIGFyZVxuICAgICAqIGRpc3BhdGNoZWQuXG4gICAgICogQG1ldGhvZCBfY2hlY2tTY3JpcHRMb2FkT3JkZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2NoZWNrU2NyaXB0TG9hZE9yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbCA9IHRoaXMuX2xvYWRlZFNjcmlwdHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2xvYWRlZFNjcmlwdHNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGlzIHN0aWxsIGxvYWRpbmcuIERvIG5vdCBwcm9jZXNzIGZ1cnRoZXIuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGhhcyBjb21wbGV0ZWQsIGFuZCBiZWVuIHByb2Nlc3NlZC4gTW92ZSBvbi5cblxuICAgICAgICAgICAgdmFyIGxvYWRJdGVtID0gdGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXTtcbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuSkFWQVNDUklQVCkge1xuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBzY3JpcHQgdGFncyB0byB0aGUgaGVhZCBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgICAgICAgIGNyZWF0ZWpzLkRvbVV0aWxzLmFwcGVuZFRvSGVhZChsb2FkSXRlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSBpdGVtLl9sb2FkZXI7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzRmluaXNoZWRMb2FkKGl0ZW0sIGxvYWRlcik7XG4gICAgICAgICAgICB0aGlzLl9sb2FkZWRTY3JpcHRzW2ldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZpbGUgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLCBhbmQgdGhlIExvYWRRdWV1ZSBjYW4gbW92ZSBvbi4gVGhpcyB0cmlnZ2VycyB0aGUgY29tcGxldGUgZXZlbnQsIGFuZCBraWNrLXN0YXJ0c1xuICAgICAqIHRoZSBuZXh0IGl0ZW0uXG4gICAgICogQG1ldGhvZCBfcHJvY2Vzc0ZpbmlzaGVkTG9hZFxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHAuX3Byb2Nlc3NGaW5pc2hlZExvYWQgPSBmdW5jdGlvbiAoaXRlbSwgbG9hZGVyKSB7XG4gICAgICAgIHRoaXMuX251bUl0ZW1zTG9hZGVkKys7XG5cbiAgICAgICAgLy8gU2luY2UgTG9hZFF1ZXVlIG5lZWRzIG1haW50YWluIG9yZGVyLCB3ZSBjYW4ndCBhcHBlbmQgc2NyaXB0cyBpbiB0aGUgbG9hZGVyLlxuICAgICAgICAvLyBTbyB3ZSBkbyBpdCBoZXJlIGluc3RlYWQuIE9yIGluIF9jaGVja1NjcmlwdExvYWRPcmRlcigpO1xuICAgICAgICBpZiAoIXRoaXMubWFpbnRhaW5TY3JpcHRPcmRlciAmJiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuSkFWQVNDUklQVCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcbiAgICAgICAgICAgIGNyZWF0ZWpzLkRvbVV0aWxzLmFwcGVuZFRvSGVhZCh0YWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcbiAgICAgICAgdGhpcy5fc2VuZEZpbGVDb21wbGV0ZShpdGVtLCBsb2FkZXIpO1xuICAgICAgICB0aGlzLl9sb2FkTmV4dCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgaXRlbXMgd2l0aCBgbWFpbnRhaW5PcmRlcj10cnVlYCB0aGF0IGFyZSBiZWZvcmUgdGhlIHNwZWNpZmllZCBpdGVtIGhhdmUgbG9hZGVkLiBUaGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAqIEphdmFTY3JpcHQgaXRlbXMgdGhhdCBhcmUgYmVpbmcgbG9hZGVkIHdpdGggYSBUYWdMb2FkZXIsIHNpbmNlIHRoZXkgaGF2ZSB0byBiZSBsb2FkZWQgYW5kIGNvbXBsZXRlZCA8c3Ryb25nPmJlZm9yZTwvc3Ryb25nPlxuICAgICAqIHRoZSBzY3JpcHQgY2FuIGV2ZW4gYmUgc3RhcnRlZCwgc2luY2UgaXQgZXhpc3QgaW4gdGhlIERPTSB3aGlsZSBsb2FkaW5nLlxuICAgICAqIEBtZXRob2QgX2NhblN0YXJ0TG9hZFxuICAgICAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIGZvciB0aGUgaXRlbVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gY2FuIHN0YXJ0IGEgbG9hZCBvciBub3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9jYW5TdGFydExvYWQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5tYWludGFpblNjcmlwdE9yZGVyIHx8IGxvYWRlci5wcmVmZXJYSFIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSAhPSBjcmVhdGVqcy5UeXBlcy5KQVZBU0NSSVBUKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2NyaXB0T3JkZXIuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2hlY2tJdGVtID0gdGhpcy5fbG9hZGVkU2NyaXB0c1tpXTtcbiAgICAgICAgICAgIGlmIChjaGVja0l0ZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9hZCBpdGVtIGlzIGNvbXBsZXRlZCBvciB3YXMgY2FuY2VsZWQsIGFuZCBuZWVkcyB0byBiZSByZW1vdmVkIGZyb20gdGhlIExvYWRRdWV1ZS5cbiAgICAgKiBAbWV0aG9kIF9yZW1vdmVMb2FkSXRlbVxuICAgICAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBBIGxvYWRlciBpbnN0YW5jZSB0byByZW1vdmUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9yZW1vdmVMb2FkSXRlbSA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMb2Fkc1tpXSA9PSBsb2FkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TG9hZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB1bm5lZWRlZCByZWZlcmVuY2VzIGZyb20gYSBsb2FkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9hZGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9jbGVhbkxvYWRJdGVtID0gZnVuY3Rpb24obG9hZGVyKSB7XG4gICAgICAgIHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtLl9sb2FkZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBpdGVtIGhhcyBkaXNwYXRjaGVkIHByb2dyZXNzLiBQcm9wYWdhdGUgdGhhdCBwcm9ncmVzcywgYW5kIHVwZGF0ZSB0aGUgTG9hZFF1ZXVlJ3Mgb3ZlcmFsbCBwcm9ncmVzcy5cbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVQcm9ncmVzc1xuICAgICAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZXZlbnQgVGhlIHByb2dyZXNzIGV2ZW50IGZyb20gdGhlIGl0ZW0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB0aGlzLl9zZW5kRmlsZVByb2dyZXNzKGxvYWRlci5nZXRJdGVtKCksIGxvYWRlci5wcm9ncmVzcyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE92ZXJhbGwgcHJvZ3Jlc3MgaGFzIGNoYW5nZWQsIHNvIGRldGVybWluZSB0aGUgbmV3IHByb2dyZXNzIGFtb3VudCBhbmQgZGlzcGF0Y2ggaXQuIFRoaXMgY2hhbmdlcyBhbnkgdGltZSBhblxuICAgICAqIGl0ZW0gZGlzcGF0Y2hlcyBwcm9ncmVzcyBvciBjb21wbGV0ZXMuIE5vdGUgdGhhdCBzaW5jZSB3ZSBkb24ndCBhbHdheXMga25vdyB0aGUgYWN0dWFsIGZpbGVzaXplIG9mIGl0ZW1zIGJlZm9yZVxuICAgICAqIHRoZXkgYXJlIGxvYWRlZC4gSW4gdGhpcyBjYXNlLCB3ZSBkZWZpbmUgYSBcInNsb3RcIiBmb3IgZWFjaCBpdGVtICgxIGl0ZW0gaW4gMTAgd291bGQgZ2V0IDEwJSksIGFuZCB0aGVuIGFwcGVuZFxuICAgICAqIGxvYWRlZCBwcm9ncmVzcyBvbiB0b3Agb2YgdGhlIGFscmVhZHktbG9hZGVkIGl0ZW1zLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIDUvMTAgaXRlbXMgaGF2ZSBsb2FkZWQsIGFuZCBpdGVtIDYgaXMgMjAlIGxvYWRlZCwgdGhlIHRvdGFsIHByb2dyZXNzIHdvdWxkIGJlOlxuICAgICAqIDx1bD5cbiAgICAgKiAgICAgIDxsaT41LzEwIG9mIHRoZSBpdGVtcyBpbiB0aGUgcXVldWUgKDUwJSk8L2xpPlxuICAgICAqICAgICAgPGxpPnBsdXMgMjAlIG9mIGl0ZW0gNidzIHNsb3QgKDIlKTwvbGk+XG4gICAgICogICAgICA8bGk+ZXF1YWxzIDUyJTwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKiBAbWV0aG9kIF91cGRhdGVQcm9ncmVzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5fdXBkYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2FkZWQgPSB0aGlzLl9udW1JdGVtc0xvYWRlZCAvIHRoaXMuX251bUl0ZW1zOyAvLyBGdWxseSBMb2FkZWQgUHJvZ3Jlc3NcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHRoaXMuX251bUl0ZW1zIC0gdGhpcy5fbnVtSXRlbXNMb2FkZWQ7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICB2YXIgY2h1bmsgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgKz0gdGhpcy5fY3VycmVudExvYWRzW2ldLnByb2dyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZGVkICs9IChjaHVuayAvIHJlbWFpbmluZykgKiAocmVtYWluaW5nIC8gdGhpcy5fbnVtSXRlbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xhc3RQcm9ncmVzcyAhPSBsb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRQcm9ncmVzcyhsb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0gbG9hZGVkO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFuIG91dCBpdGVtIHJlc3VsdHMsIHRvIGZyZWUgdGhlbSBmcm9tIG1lbW9yeS4gTWFpbmx5LCB0aGUgbG9hZGVkIGl0ZW0gYW5kIHJlc3VsdHMgYXJlIGNsZWFyZWQgZnJvbSBpbnRlcm5hbFxuICAgICAqIGhhc2hlcy5cbiAgICAgKiBAbWV0aG9kIF9kaXNwb3NlSXRlbVxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgd2FzIHBhc3NlZCBpbiBmb3IgcHJlbG9hZGluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2Rpc3Bvc2VJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xvYWRJdGVtc0J5U3JjW2l0ZW0uc3JjXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYSBcImZpbGVwcm9ncmVzc1wiIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSBMb2FkUXVldWUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVwcm9ncmVzczpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuICAgICAqIEBtZXRob2QgX3NlbmRGaWxlUHJvZ3Jlc3NcbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvZ3Jlc3MgVGhlIGFtb3VudCB0aGUgaXRlbSBoYXMgYmVlbiBsb2FkZWQgKGJldHdlZW4gMCBhbmQgMSkuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHAuX3NlbmRGaWxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoaXRlbSwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSB8fCB0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVwcm9ncmVzc1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9MTTogUmV3b3JrIFByb2dyZXNzRXZlbnQgdG8gc3VwcG9ydCB0aGlzP1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlcHJvZ3Jlc3NcIik7XG4gICAgICAgIGV2ZW50LnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIGV2ZW50LmxvYWRlZCA9IHByb2dyZXNzO1xuICAgICAgICBldmVudC50b3RhbCA9IDE7XG4gICAgICAgIGV2ZW50Lml0ZW0gPSBpdGVtO1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgZmlsZWxvYWQge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBmb3JcbiAgICAgKiBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuICAgICAqIEBtZXRob2QgX3NlbmRGaWxlQ29tcGxldGVcbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtT2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuICAgICAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl9zZW5kRmlsZUNvbXBsZXRlID0gZnVuY3Rpb24gKGl0ZW0sIGxvYWRlcikge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxlZCgpIHx8IHRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWxvYWRcIik7XG4gICAgICAgIGV2ZW50LmxvYWRlciA9IGxvYWRlcjtcbiAgICAgICAgZXZlbnQuaXRlbSA9IGl0ZW07XG4gICAgICAgIGV2ZW50LnJlc3VsdCA9IHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG4gICAgICAgIGV2ZW50LnJhd1Jlc3VsdCA9IHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF07XG5cbiAgICAgICAgLy8gVGhpcyBjYWxscyBhIGhhbmRsZXIgc3BlY2lmaWVkIG9uIHRoZSBhY3R1YWwgbG9hZCBpdGVtLiBDdXJyZW50bHksIHRoZSBTb3VuZEpTIHBsdWdpbiB1c2VzIHRoaXMuXG4gICAgICAgIGlmIChpdGVtLmNvbXBsZXRlSGFuZGxlcikge1xuICAgICAgICAgICAgaXRlbS5jb21wbGV0ZUhhbmRsZXIoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZWxvYWRcIikgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYSBmaWxlc3RhcnQge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gaW1tZWRpYXRlbHkgYmVmb3JlIGEgZmlsZSBzdGFydHMgdG8gbG9hZC4gUGxlYXNlIHNlZVxuICAgICAqIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZXN0YXJ0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuICAgICAqIEBtZXRob2QgX3NlbmRGaWxlU3RhcnRcbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcC5fc2VuZEZpbGVTdGFydCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVzdGFydFwiKTtcbiAgICAgICAgZXZlbnQuaXRlbSA9IGl0ZW07XG4gICAgICAgIHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVzdGFydFwiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG5cbiAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbUHJlbG9hZEpTIExvYWRRdWV1ZV1cIjtcbiAgICB9O1xuXG4gICAgY3JlYXRlanMuTG9hZFF1ZXVlID0gY3JlYXRlanMucHJvbW90ZShMb2FkUXVldWUsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGV4dExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBjb25zdHJ1Y3RvclxuICAgIC8qKlxuICAgICAqIEEgbG9hZGVyIGZvciBUZXh0IGZpbGVzLlxuICAgICAqIEBjbGFzcyBUZXh0TG9hZGVyXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG4gICAgICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZXh0TG9hZGVyKGxvYWRJdGVtKSB7XG4gICAgICAgIHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLlR5cGVzLlRFWFQpO1xuICAgIH07XG5cbiAgICB2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUZXh0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG4gICAgdmFyIHMgPSBUZXh0TG9hZGVyO1xuXG4gICAgLy8gc3RhdGljIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBsb2FkcyBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlIHt7I2Nyb3NzTGluayBcIlR5cGVzL1RFWFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG4gICAgICogYnV0IGlzIGFsc28gdGhlIGRlZmF1bHQgbG9hZGVyIGlmIGEgZmlsZSB0eXBlIGNhbiBub3QgYmUgZGV0ZXJtaW5lZC5cbiAgICAgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuVEVYVDtcbiAgICB9O1xuXG4gICAgY3JlYXRlanMuVGV4dExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoVGV4dExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJpbmFyeUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBjb25zdHJ1Y3RvclxuICAgIC8qKlxuICAgICAqIEEgbG9hZGVyIGZvciBiaW5hcnkgZmlsZXMuIFRoaXMgaXMgdXNlZnVsIGZvciBsb2FkaW5nIHdlYiBhdWRpbywgb3IgY29udGVudCB0aGF0IHJlcXVpcmVzIGFuIEFycmF5QnVmZmVyLlxuICAgICAqIEBjbGFzcyBCaW5hcnlMb2FkZXJcbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cbiAgICAgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpbmFyeUxvYWRlcihsb2FkSXRlbSkge1xuICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5UeXBlcy5CSU5BUlkpO1xuICAgICAgICB0aGlzLm9uKFwiaW5pdGlhbGl6ZVwiLCB0aGlzLl91cGRhdGVYSFIsIHRoaXMpO1xuICAgIH07XG5cbiAgICB2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCaW5hcnlMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcbiAgICB2YXIgcyA9IEJpbmFyeUxvYWRlcjtcblxuICAgIC8vIHN0YXRpYyBtZXRob2RzXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvQklOQVJZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLlR5cGVzLkJJTkFSWTtcbiAgICB9O1xuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgLyoqXG4gICAgICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgdGhlIHJlc3BvbnNlIHR5cGUgdG8gXCJhcnJheWJ1ZmZlclwiXG4gICAgICogQHByb3BlcnR5IF91cGRhdGVYSFJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5fdXBkYXRlWEhSID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcbiAgICB9O1xuXG4gICAgY3JlYXRlanMuQmluYXJ5TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShCaW5hcnlMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDU1NMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gY29uc3RydWN0b3JcbiAgICAvKipcbiAgICAgKiBBIGxvYWRlciBmb3IgQ1NTIGZpbGVzLlxuICAgICAqIEBjbGFzcyBDU1NMb2FkZXJcbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuICAgICAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ1NTTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcbiAgICAgICAgdGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5UeXBlcy5DU1MpO1xuXG4gICAgICAgIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG4gICAgICAgIC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwiaHJlZlwiO1xuXG4gICAgICAgIGlmIChwcmVmZXJYSFIpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhZyA9IGNyZWF0ZWpzLkVsZW1lbnRzLnN0eWxlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90YWcgPSBjcmVhdGVqcy5FbGVtZW50cy5saW5rKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90YWcucmVsID0gXCJzdHlsZXNoZWV0XCI7XG4gICAgICAgIHRoaXMuX3RhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgIH07XG5cbiAgICB2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDU1NMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcbiAgICB2YXIgcyA9IENTU0xvYWRlcjtcblxuICAgIC8vIHN0YXRpYyBtZXRob2RzXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5DU1M7XG4gICAgfTtcblxuICAgIC8vIHByb3RlY3RlZCBtZXRob2RzXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIENTUyBmaWxlcy5cbiAgICAgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcbiAgICAgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcbiAgICAgKiBAcmV0dXJucyB7SFRNTExpbmtFbGVtZW50fEhUTUxTdHlsZUVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSBsb2FkZXIuZ2V0VGFnKCk7XG5cbiAgICAgICAgICAgIGlmICh0YWcuc3R5bGVTaGVldCkgeyAvLyBJRVxuICAgICAgICAgICAgICAgIHRhZy5zdHlsZVNoZWV0LmNzc1RleHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVqcy5FbGVtZW50cy50ZXh0KGxvYWRlci5nZXRSZXN1bHQodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHRhZy5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWcgPSB0aGlzLl90YWc7XG4gICAgICAgIH1cblxuICAgICAgICBjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQodGFnKTtcblxuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH07XG5cbiAgICBjcmVhdGVqcy5DU1NMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENTU0xvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEZvbnRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvcjpcbiAgICAvKipcbiAgICAgKiBBIGxvYWRlciB0aGF0IGhhbmRsZXMgZm9udCBmaWxlcywgQ1NTIGRlZmluaXRpb25zLCBhbmQgQ1NTIHBhdGhzLiBGb250TG9hZGVyIGRvZXNuJ3QgYWN0dWFsbHkgcHJlbG9hZCBmb250c1xuICAgICAqIHRoZW1zZWx2ZXMsIGJ1dCByYXRoZXIgZ2VuZXJhdGVzIENTUyBkZWZpbml0aW9ucywgYW5kIHRoZW4gdGVzdHMgdGhlIHNpemUgY2hhbmdlcyBvbiBhbiBIVE1MNSBDYW52YXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBGb250TG9hZGVyIGRvZXMgbm90IHN1cHBvcnQgdGFnLWJhc2VkIGxvYWRpbmcgZHVlIHRvIHRoZSByZXF1aXJlbWVudCB0aGF0IENTUyBiZSByZWFkIHRvIGRldGVybWluZSB0aGVcbiAgICAgKiBmb250IGRlZmluaXRpb25zIHRvIHRlc3QgZm9yLlxuICAgICAqIEBjbGFzcyBGb250TG9hZGVyXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxvYmplY3R8c3RyaW5nfSBsb2FkSXRlbSBUaGUgaXRlbSB0byBiZSBsb2FkZWQuXG4gICAgICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiovXG4gICAgZnVuY3Rpb24gRm9udExvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG4gICAgICAgIHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgbG9hZEl0ZW0udHlwZSk7XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsb29rdXAgb2YgZm9udCBmYWNlcyB0byBsb2FkLlxuICAgICAgICAgKiBAcHJvcGVydHkgX2ZhY2VzXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgICAqKi9cbiAgICAgICAgdGhpcy5fZmFjZXMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGZvbnQgZmFjZXMgY3VycmVudGx5IGJlaW5nIFwid2F0Y2hlZFwiLiBXYXRjaGVkIGZvbnRzIHdpbGwgYmUgdGVzdGVkIG9uIGEgcmVndWxhciBpbnRlcnZhbCwgYW5kIGJlXG4gICAgICAgICAqIHJlbW92ZWQgZnJvbSB0aGlzIGxpc3Qgd2hlbiB0aGV5IGFyZSBjb21wbGV0ZS5cbiAgICAgICAgICogQG9yb3BlcnR5IF93YXRjaGVkXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fd2F0Y2hlZCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvdW50IG9mIHRoZSB0b3RhbCBmb250IGZhY2VzIHRvIGxvYWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBfY291bnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb3VudCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnRlcnZhbCBmb3IgY2hlY2tpbmcgaWYgZm9udHMgaGF2ZSBiZWVuIGxvYWRlZC5cbiAgICAgICAgICogQHByb3BlcnR5IF93YXRjaEludGVydmFsXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3dhdGNoSW50ZXJ2YWwgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZW91dCBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBmb250IGNhbid0IGJlIGxvYWRlZC4gVXNlcyB0aGUgTG9hZEl0ZW0ge3sjY3Jvc3NMaW5rIFwiTG9hZEltdGUvdGltZW91dDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAgICAgKiB2YWx1ZS5cbiAgICAgICAgICogQHByb3BlcnR5IF9sb2FkVGltZW91dFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkVGltZW91dCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIGdlbmVyYXRlZCBDU1Mgc2hvdWxkIGJlIGluamVjdGVkIGludG8gdGhlIGRvY3VtZW50LlxuICAgICAgICAgKiBAcHJvcGVydHkgX2luamVjdENTU1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5qZWN0Q1NTID0gKGxvYWRJdGVtLmluamVjdENTUyA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBsb2FkSXRlbS5pbmplY3RDU1M7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiaW5pdGlhbGl6ZVwiKTtcbiAgICB9XG4gICAgdmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoRm9udExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuICAgIFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuICAgICAqIHt7I2Nyb3NzTGluayBcIlR5cGVzL0ZPTlQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIEZvbnRMb2FkZXIuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLlR5cGVzLkZPTlQgfHwgaXRlbS50eXBlID09IGNyZWF0ZWpzLlR5cGVzLkZPTlRDU1M7XG4gICAgfTtcblxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG4gICAgLyoqXG4gICAgICogU2FtcGxlIHRleHQgdXNlZCBieSB0aGUgRm9udExvYWRlciB0byBkZXRlcm1pbmUgaWYgdGhlIGZvbnQgaGFzIGJlZW4gbG9hZGVkLiBUaGUgc2FtcGxlIHRleHQgc2l6ZSBpcyBjb21wYXJlZFxuICAgICAqIHRvIHRoZSBsb2FkZWQgZm9udCBzaXplLCBhbmQgYSBjaGFuZ2UgaW5kaWNhdGVzIHRoYXQgdGhlIGZvbnQgaGFzIGNvbXBsZXRlZC5cbiAgICAgKiBAcHJvcGVydHkgc2FtcGxlVGV4dFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBGb250TG9hZGVyLnNhbXBsZVRleHQgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byB0ZXN0IHRoZSBmb250IHNpemUuIE5vdGUgdGhhdCB0aGlzIGN1cnJlbnRseSByZXF1aXJlcyBhbiBIVE1MIERPTS5cbiAgICAgKiBAcHJvcGVydHkgX2N0eFxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRm9udExvYWRlci5fY3R4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik7IC8vIFRPRE86IENvbnNpZGVyIGEgbWV0aG9kIHRvIGRvIHRoaXMgbGlrZSBFYXNlbEpTIFN0YWdlIGhhcy5cblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiByZWZlcmVuY2UgZm9udHMgdG8gdGVzdC4gTXVsdGlwbGUgZmFjZXMgYXJlIHRlc3RlZCB0byBhZGRyZXNzIHRoZSByYXJlIGNhc2Ugb2YgYSBsb2FkZWQgZm9udCBiZWluZyB0aGVcbiAgICAgKiBleGFjdCBzYW1lIGRpbWVuc2lvbnMgYXMgdGhlIHRlc3QgZm9udC5cbiAgICAgKiBAcHJvcGVydHkgX3JlZmVyZW5jZUZvbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBkZWZhdWx0IFtcInNlcmlmXCIsIFwibW9ub3NwYWNlXCJdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBGb250TG9hZGVyLl9yZWZlcmVuY2VGb250cyA9IFtcInNlcmlmXCIsXCJtb25vc3BhY2VcIl07XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHB1bGxzIG91dCBwb3NzaWJsZSBzdHlsZSB2YWx1ZXMgZnJvbSB0aGUgZm9udCBuYW1lLlxuICAgICAqIDx1bD5cbiAgICAgKiAgICAgPGxpPlRoaXMgaW5jbHVkZXMgZm9udCBuYW1lcyB0aGF0IGluY2x1ZGUgdGhpbiwgbm9ybWFsLCBib29rLCByZWd1bGFyLCBtZWRpdW0sIGJsYWNrLCBhbmQgaGVhdnkgKHN1Y2ggYXNcbiAgICAgKiAgICAgXCJBcmlhbCBCbGFja1wiKTwvbGk+XG4gICAgICogICAgIDxsaT5XZWlnaHQgbW9kaWZpZXJzIGluY2x1ZGluZyBleHRyYSwgdWx0cmEsIHNlbWksIGRlbWksIGxpZ2h0LCBhbmQgYm9sZCAoc3VjaCBhcyBcIldvcmtTYW5zIFNlbWlCb2xkXCIpPC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqXG4gICAgICogV2VpZ2h0IGRlc2NyaXB0aW9ucyBtYXAgdG8gZm9udCB3ZWlnaHQgdmFsdWVzIGJ5IGRlZmF1bHQgdXNpbmcgdGhlIGZvbGxvd2luZyAoZnJvbVxuICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtZm9udHMvI2ZvbnQtd2VpZ2h0LW51bWVyaWMtdmFsdWVzKTpcbiAgICAgKiA8dWw+XG4gICAgICogICAgIDxsaT4xMDAgLSBUaGluPC9saT5cbiAgICAgKiAgICAgPGxpPjIwMCAtIEV4dHJhIExpZ2h0LCBVbHRyYSBMaWdodDwvbGk+XG4gICAgICogICAgIDxsaT4zMDAgLSBMaWdodCwgU2VtaSBMaWdodCwgRGVtaSBMaWdodDwvbGk+XG4gICAgICogICAgIDxsaT40MDAgLSBOb3JtYWwsIEJvb2ssIFJlZ3VsYXI8L2xpPlxuICAgICAqICAgICA8bGk+NTAwIC0gTWVkaXVtPC9saT5cbiAgICAgKiAgICAgPGxpPjYwMCAtIFNlbWkgQm9sZCwgRGVtaSBCb2xkPC9saT5cbiAgICAgKiAgICAgPGxpPjcwMCAtIEJvbGQ8L2xpPlxuICAgICAqICAgICA8bGk+ODAwIC0gRXh0cmEgQm9sZCwgVWx0cmEgQm9sZDwvbGk+XG4gICAgICogICAgIDxsaT45MDAgLSBCbGFjaywgSGVhdnk8L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICogQHByb3BlcnR5IFdFSUdIVF9SRUdFWFxuICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIEZvbnRMb2FkZXIuV0VJR0hUX1JFR0VYID0gL1stIC5fXSoodGhpbnxub3JtYWx8Ym9va3xyZWd1bGFyfG1lZGl1bXxibGFja3xoZWF2eXxbMS05XTAwfCg/OmV4dHJhfHVsdHJhfHNlbWl8ZGVtaSk/Wy0gLl9dKig/OmxpZ2h0fGJvbGQpKVstIC5fXSovaWc7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHB1bGxzIG91dCBwb3NzaWJsZSBzdHlsZSB2YWx1ZXMgZnJvbSB0aGUgZm9udCBuYW1lLiBUaGVzZSBpbmNsdWRlIFwiaXRhbGljXCJcbiAgICAgKiBhbmQgXCJvYmxpcXVlXCIuXG4gICAgICogQHByb3BlcnR5IFNUWUxFX1JFR0VYXG4gICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgRm9udExvYWRlci5TVFlMRV9SRUdFWCA9IC9bLSAuX10qKGl0YWxpY3xvYmxpcXVlKVstIC5fXSovaWc7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvb2t1cCBvZiBmb250IHR5cGVzIGZvciBnZW5lcmF0aW5nIGEgQ1NTIGRlZmluaXRpb24uIEZvciBleGFtcGxlLCBUVEYgZm9udHMgcmVxdWlyZXMgYSBcInRydWV0eXBlXCIgdHlwZS5cbiAgICAgKiBAcHJvcGVydHkgRk9OVF9GT1JNQVRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBGb250TG9hZGVyLkZPTlRfRk9STUFUID0ge3dvZmYyOlwid29mZjJcIiwgd29mZjpcIndvZmZcIiwgdHRmOlwidHJ1ZXR5cGVcIiwgb3RmOlwidHJ1ZXR5cGVcIn07XG5cbiAgICAvKipcbiAgICAgKiBBIGxvb2t1cCBvZiBmb250IHdlaWdodHMgYmFzZWQgb24gYSBuYW1lLiBUaGVzZSB2YWx1ZXMgYXJlIGZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1mb250cy8jZm9udC13ZWlnaHQtbnVtZXJpYy12YWx1ZXMuXG4gICAgICogQHByb3BlcnR5IEZPTlRfV0VJR0hUXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgRm9udExvYWRlci5GT05UX1dFSUdIVCA9IHt0aGluOjEwMCwgZXh0cmFsaWdodDoyMDAsIHVsdHJhbGlnaHQ6MjAwLCBsaWdodDozMDAsIHNlbWlsaWdodDozMDAsIGRlbWlsaWdodDozMDAsIGJvb2s6XCJub3JtYWxcIiwgcmVndWxhcjpcIm5vcm1hbFwiLCBzZW1pYm9sZDo2MDAsIGRlbWlib2xkOjYwMCwgZXh0cmFib2xkOjgwMCwgdWx0cmFib2xkOjgwMCwgYmxhY2s6OTAwLCBoZWF2eTo5MDB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyZXF1ZW5jeSBpbiBtaWxsaXNlY29uZHMgdG8gY2hlY2sgZm9yIGxvYWRlZCBmb250cy5cbiAgICAgKiBAcHJvcGVydHkgV0FUQ0hfRFVSQVRJT05cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIEZvbnRMb2FkZXIuV0FUQ0hfRFVSQVRJT04gPSAxMDtcbi8vIHB1YmxpYyBtZXRob2RzOlxuICAgIHAubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IGNyZWF0ZWpzLlR5cGVzLkZPTlRDU1MpIHtcbiAgICAgICAgICAgIHZhciBsb2FkZWQgPSB0aGlzLl93YXRjaENTUygpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgQ1NTIGlzIG5vdCByZWFkeSwgaXQgd2lsbCBjcmVhdGUgYSByZXF1ZXN0LCB3aGljaCBBYnN0cmFjdExvYWRlciBjYW4gaGFuZGxlLlxuICAgICAgICAgICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pdGVtLnNyYyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl93YXRjaEZvbnRBcnJheSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2RlZkZyb21TcmModGhpcy5faXRlbS5zcmMpO1xuICAgICAgICAgICAgdGhpcy5fd2F0Y2hGb250KGRlZik7XG4gICAgICAgICAgICB0aGlzLl9pbmplY3RTdHlsZVRhZyh0aGlzLl9jc3NGcm9tRGVmKGRlZikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb250IGxvYWQgaGFzIHRpbWVkIG91dC4gVGhpcyBpcyBjYWxsZWQgdmlhIGEgPGNvZGU+c2V0VGltZW91dDwvY29kZT4uXG4gICAgICogY2FsbGJhY2suXG4gICAgICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdG9wV2F0Y2hpbmcoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9USU1FT1VUXCIpKTtcbiAgICB9O1xuXG4gICAgLy8gV2F0Y2hDU1MgZG9lcyB0aGUgd29yayBmb3IgdXMsIGFuZCBwcm92aWRlcyBhIG1vZGlmaWVkIHNyYy5cbiAgICBwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0O1xuICAgIH07XG5cbiAgICAvLyBFdmVudHMgY29tZSBmcm9tIHRoZSBpbnRlcm5hbCBYSFIgbG9hZGVyLlxuICAgIHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY29tcGxldGVcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuX3Jlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VDU1ModGhpcy5fcmF3UmVzdWx0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFdhdGNoaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5BYnN0cmFjdExvYWRlcl9oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBwcm92aWRlZCBDU1MgaXMgYSBzdHJpbmcgZGVmaW5pdGlvbiwgQ1NTIEhUTUwgZWxlbWVudCwgb3IgYSBDU1MgZmlsZSBVUkkuIERlcGVuZGluZyBvbiB0aGVcbiAgICAgKiBmb3JtYXQsIHRoZSBDU1Mgd2lsbCBiZSBwYXJzZWQsIG9yIGxvYWRlZC5cbiAgICAgKiBAbWV0aG9kIF93YXRjaENTU1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgQ1NTIGlzIHJlYWR5XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHAuX3dhdGNoQ1NTID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzcmMgPSB0aGlzLl9pdGVtLnNyYztcblxuICAgICAgICAvLyBBbiBIVE1MRWxlbWVudCB3YXMgcGFzc2VkIGluLiBKdXN0IHVzZSBpdC5cbiAgICAgICAgaWYgKHNyYyBpbnN0YW5jZW9mIEhUTUxTdHlsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmplY3RDU1MgJiYgIXNyYy5wYXJlbnROb2RlKSB7IChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pLmFwcGVuZENoaWxkKHNyYyk7IH1cbiAgICAgICAgICAgIHRoaXMuX2luamVjdENTUyA9IGZhbHNlO1xuICAgICAgICAgICAgc3JjID0gXCJcXG5cIitzcmMudGV4dENvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBIENTUyBzdHJpbmcgd2FzIHBhc3NlZCBpbi4gUGFyc2UgYW5kIHVzZSBpdFxuICAgICAgICBpZiAoc3JjLnNlYXJjaCgvXFxufFxccnxAZm9udC1mYWNlL2kpICE9PSAtMSkgeyAvLyBjc3Mgc3RyaW5nLlxuICAgICAgICAgICAgdGhpcy5fcGFyc2VDU1Moc3JjKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9hZCBhIENTUyBQYXRoLiBOb3RlIHRoYXQgd2UgQ0FOIE5PVCBsb2FkIGl0IHdpdGhvdXQgWEhSIGJlY2F1c2Ugd2UgbmVlZCB0byByZWFkIHRoZSBDU1MgZGVmaW5pdGlvblxuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlhIUlJlcXVlc3QodGhpcy5faXRlbSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBDU1Mgc3RyaW5nIHRvIGRldGVybWluZSB0aGUgZm9udHMgdG8gbG9hZC5cbiAgICAgKiBAbWV0aG9kIF9wYXJzZUNTU1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjc3MgVGhlIENTUyBzdHJpbmcgdG8gcGFyc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcC5fcGFyc2VDU1MgPSBmdW5jdGlvbihjc3MpIHtcbiAgICAgICAgdmFyIHJlZ2V4ID0gL0Bmb250LWZhY2VcXHMqXFx7KFtefV0rKX0vZ1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlZ2V4LmV4ZWMoY3NzKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7IGJyZWFrOyB9XG4gICAgICAgICAgICB0aGlzLl93YXRjaEZvbnQodGhpcy5fcGFyc2VGb250RmFjZShyZXN1bHRbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbmplY3RTdHlsZVRhZyhjc3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJvdmlkZWQgZm9udHMgd2VyZSBhbiBhcnJheSBvZiBvYmplY3Qgb3Igc3RyaW5nIGRlZmluaXRpb25zLiBQYXJzZSB0aGVtLCBhbmQgaW5qZWN0IGFueSB0aGF0IGFyZSByZWFkeS5cbiAgICAgKiBAbWV0aG9kIF93YXRjaEZvbnRBcnJheVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl93YXRjaEZvbnRBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gdGhpcy5faXRlbS5zcmMsIGNzcyA9IFwiXCIsIGRlZjtcbiAgICAgICAgZm9yICh2YXIgaT1hcnIubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgdmFyIG8gPSBhcnJbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHsgZGVmID0gdGhpcy5fZGVmRnJvbVNyYyhvKSB9XG4gICAgICAgICAgICBlbHNlIHsgZGVmID0gdGhpcy5fZGVmRnJvbU9iaihvKTsgfVxuICAgICAgICAgICAgdGhpcy5fd2F0Y2hGb250KGRlZik7XG4gICAgICAgICAgICBjc3MgKz0gdGhpcy5fY3NzRnJvbURlZihkZWYpK1wiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5qZWN0U3R5bGVUYWcoY3NzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5qZWN0IGFueSBzdHlsZSBkZWZpbml0aW9ucyBpbnRvIHRoZSBkb2N1bWVudCBoZWFkLiBUaGlzIGlzIG5lY2Vzc2FyeSB3aGVuIHRoZSBkZWZpbml0aW9uIGlzIGp1c3QgYSBzdHJpbmcgb3JcbiAgICAgKiBvYmplY3QgZGVmaW5pdGlvbiBpbiBvcmRlciBmb3IgdGhlIHN0eWxlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudC4gSWYgdGhlIGxvYWRlZCBmb250cyBhcmUgYWxyZWFkeSBIVE1MIENTU1xuICAgICAqIGVsZW1lbnRzLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgYXBwZW5kZWQgYWdhaW4uXG4gICAgICogQG1ldGhvZCBfaW5qZWN0U3R5bGVUYWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY3NzIFRoZSBDU1Mgc3RyaW5nIGNvbnRlbnQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHAuX2luamVjdFN0eWxlVGFnID0gZnVuY3Rpb24oY3NzKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5qZWN0Q1NTKSB7IHJldHVybjsgfVxuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgdmFyIHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBzdHlsZVRhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICBpZiAoc3R5bGVUYWcuc3R5bGVTaGVldCl7XG4gICAgICAgICAgICBzdHlsZVRhZy5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBmb250IGZhY2UgZnJvbSBhIENTUyBkZWZpbml0aW9uLlxuICAgICAqIEBtZXRob2QgX3BhcnNlRm9udEZhY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBDU1Mgc3RyaW5nIGRlZmluaXRpb25cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBBIG1vZGlmaWVkIENTUyBvYmplY3QgY29udGFpbmluZyBmYW1pbHkgbmFtZSwgc3JjLCBzdHlsZSwgYW5kIHdlaWdodFxuICAgICAqL1xuICAgIHAuX3BhcnNlRm9udEZhY2UgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIGZhbWlseSA9IHRoaXMuX2dldENTU1ZhbHVlKHN0ciwgXCJmb250LWZhbWlseVwiKSwgc3JjID0gdGhpcy5fZ2V0Q1NTVmFsdWUoc3RyLCBcInNyY1wiKTtcbiAgICAgICAgaWYgKCFmYW1pbHkgfHwgIXNyYykgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmRnJvbU9iaih7XG4gICAgICAgICAgICBmYW1pbHk6IGZhbWlseSxcbiAgICAgICAgICAgIHNyYzogc3JjLFxuICAgICAgICAgICAgc3R5bGU6IHRoaXMuX2dldENTU1ZhbHVlKHN0ciwgXCJmb250LXN0eWxlXCIpLFxuICAgICAgICAgICAgd2VpZ2h0OiB0aGlzLl9nZXRDU1NWYWx1ZShzdHIsIFwiZm9udC13ZWlnaHRcIilcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGZvbnQgdG8gdGhlIGxpc3Qgb2YgZm9udHMgY3VycmVudGx5IGJlaW5nIHdhdGNoZWQuIElmIHRoZSBmb250IGlzIGFscmVhZHkgd2F0Y2hlZCBvciBsb2FkZWQsIGl0IHdvbid0IGJlXG4gICAgICogYWRkZWQgYWdhaW4uXG4gICAgICogQG1ldGhvZCBfd2F0Y2hGb250XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlZiBUaGUgZm9udCBkZWZpbml0aW9uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHAuX3dhdGNoRm9udCA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgICBpZiAoIWRlZiB8fCB0aGlzLl9mYWNlc1tkZWYuaWRdKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLl9mYWNlc1tkZWYuaWRdID0gZGVmO1xuICAgICAgICB0aGlzLl93YXRjaGVkLnB1c2goZGVmKTtcbiAgICAgICAgdGhpcy5fY291bnQrKztcblxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVSZWZlcmVuY2VTaXplcyhkZWYpO1xuICAgICAgICB0aGlzLl9zdGFydFdhdGNoaW5nKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGludGVydmFsIHRvIGNoZWNrIGZvciBsb2FkZWQgZm9udHMuIE9ubHkgb25lIGludGVydmFsIGlzIHVzZWQgZm9yIGFsbCBmb250cy4gVGhlIGZvbnRzIGFyZSBjaGVja2VkIGJhc2VkXG4gICAgICogb24gdGhlIHt7I2Nyb3NzTGluayBcIkZvbnRMb2FkZXIvV0FUQ0hfRFVSQVRJT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQG1ldGhvZCBfc3RhcnRXYXRjaGluZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl9zdGFydFdhdGNoaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl93YXRjaEludGVydmFsICE9IG51bGwpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMuX3dhdGNoSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjcmVhdGVqcy5wcm94eSh0aGlzLl93YXRjaCwgdGhpcyksIEZvbnRMb2FkZXIuV0FUQ0hfRFVSQVRJT04pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgaW50ZXJ2YWwgdXNlZCB0byBjaGVjayBmb250cy4gVGhpcyBoYXBwZW5zIHdoZW4gYWxsIGZvbnRzIGFyZSBsb2FkZWQsIG9yIGFuIGVycm9yIG9jY3Vycywgc3VjaCBhcyBhXG4gICAgICogQ1NTIGZpbGUgZXJyb3IsIG9yIGEgbG9hZCB0aW1lb3V0LlxuICAgICAqIEBtZXRob2QgX3N0b3BXYXRjaGluZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl9zdG9wV2F0Y2hpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl93YXRjaEludGVydmFsKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5fd2F0Y2hJbnRlcnZhbCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGFsbCB0aGUgZm9udHMgdGhhdCBoYXZlIG5vdCBiZWVuIGxvYWRlZC4gVGhlIGZvbnRzIGFyZSBkcmF3biB0byBhIGNhbnZhcyBpbiBtZW1vcnksIGFuZCBpZiB0aGVpciBmb250IHNpemVcbiAgICAgKiB2YXJpZXMgZnJvbSB0aGUgZGVmYXVsdCB0ZXh0IHNpemUsIHRoZW4gdGhlIGZvbnQgaXMgY29uc2lkZXJlZCBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBBIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2ZpbGVsb2FkXCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCB3aGVuIGVhY2ggZmlsZSBpcyBsb2FkZWQsIGFsb25nXG4gICAgICogd2l0aCB0aGUgZm9udCBmYW1pbHkgbmFtZSBhcyB0aGUgYGl0ZW1gIHZhbHVlLiBBIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gaXMgZGlzcGF0Y2hlZCBhXG4gICAgICogbWF4aW11bSBvZiBvbmUgdGltZSBwZXIgY2hlY2sgd2hlbiBhbnkgZm9udHMgYXJlIGxvYWRlZCwgd2l0aCB0aGUge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudC9wcm9ncmVzczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIHZhbHVlIHNob3dpbmcgdGhlIHBlcmNlbnRhZ2Ugb2YgZm9udHMgdGhhdCBoYXZlIGxvYWRlZC5cbiAgICAgKiBAbWV0aG9kIF93YXRjaFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl93YXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVmcyA9IHRoaXMuX3dhdGNoZWQsIHJlZkZvbnRzID0gRm9udExvYWRlci5fcmVmZXJlbmNlRm9udHMsIGwgPSBkZWZzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGwgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGRlZnNbaV0sIHJlZnMgPSBkZWYucmVmcztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSByZWZzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSB0aGlzLl9nZXRUZXh0V2lkdGgoZGVmLmZhbWlseSArIFwiLFwiICsgcmVmRm9udHNbal0sIGRlZi53ZWlnaHQsIGRlZi5zdHlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHcgIT0gcmVmc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlbG9hZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmLnR5cGUgPSBcImZvbnQtZmFtaWx5XCI7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lml0ZW0gPSBkZWY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwgIT09IGRlZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudCh0aGlzLl9jb3VudC1kZWZzLmxlbmd0aCwgdGhpcy5fY291bnQpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFdhdGNoaW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRlZmF1bHQgc2l6ZSBvZiB0aGUgcmVmZXJlbmNlIGZvbnRzIHVzZWQgdG8gY29tcGFyZSBhZ2FpbnN0IGxvYWRlZCBmb250cy5cbiAgICAgKiBAbWV0aG9kIF9jYWxjdWxhdGVSZWZlcmVuY2VTaXplc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWYgVGhlIGZvbnQgZGVmaW5pdGlvbiB0byBnZXQgdGhlIHNpemUgb2YuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHAuX2NhbGN1bGF0ZVJlZmVyZW5jZVNpemVzID0gZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgIHZhciByZWZGb250cyA9IEZvbnRMb2FkZXIuX3JlZmVyZW5jZUZvbnRzO1xuICAgICAgICB2YXIgcmVmcyA9IGRlZi5yZWZzID0gW107XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxyZWZGb250cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVmc1tpXSA9IHRoaXMuX2dldFRleHRXaWR0aChyZWZGb250c1tpXSwgZGVmLndlaWdodCwgZGVmLnN0eWxlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBDU1MgZGVmaW5pdGlvbiBmcm9tIGEgZm9udCBzb3VyY2UgYW5kIG5hbWUuXG4gICAgICogQG1ldGhvZCBfZGVmRnJvbVNyY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIGZvbnQgc291cmNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHAuX2RlZkZyb21TcmMgPSBmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgdmFyIHJlID0gL1stIC5fXSsvZywgbmFtZSA9IHNyYywgZXh0ID0gbnVsbCwgaW5kZXg7XG4gICAgICAgIFxuICAgICAgICBpbmRleCA9IG5hbWUuc2VhcmNoKC9bPyNdLyk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG5hbWUubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBleHQgPSBuYW1lLnN1YnN0cihpbmRleCsxKTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG5hbWUubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIoaW5kZXgrMSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBmYW1pbHkgPSBuYW1lLFxuICAgICAgICAgICAgICAgIHdlaWdodCA9IGZhbWlseS5tYXRjaChGb250TG9hZGVyLldFSUdIVF9SRUdFWCk7XG4gICAgICAgIGlmICh3ZWlnaHQpIHtcbiAgICAgICAgICAgIHdlaWdodCA9IHdlaWdodFswXTtcbiAgICAgICAgICAgIGZhbWlseSA9IGZhbWlseS5yZXBsYWNlKHdlaWdodCwgXCJcIik7XG4gICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQucmVwbGFjZShyZSwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGUgPSBuYW1lLm1hdGNoKEZvbnRMb2FkZXIuU1RZTEVfUkVHRVgpO1xuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgIGZhbWlseSA9IGZhbWlseS5yZXBsYWNlKHN0eWxlWzBdLCBcIlwiKTtcbiAgICAgICAgICAgIHN0eWxlID0gXCJpdGFsaWNcIjtcbiAgICAgICAgfVxuICAgICAgICBmYW1pbHkgPSBmYW1pbHkucmVwbGFjZShyZSwgXCJcIik7XG4gICAgICAgIFxuICAgICAgICB2YXIgY3NzU3JjID0gXCJsb2NhbCgnXCIrbmFtZS5yZXBsYWNlKHJlLFwiIFwiKStcIicpLCB1cmwoJ1wiK3NyYytcIicpXCI7XG4gICAgICAgIHZhciBmb3JtYXQgPSBGb250TG9hZGVyLkZPTlRfRk9STUFUW2V4dF07XG4gICAgICAgIGlmIChmb3JtYXQpIHsgY3NzU3JjICs9IFwiIGZvcm1hdCgnXCIrZm9ybWF0K1wiJylcIjsgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZkZyb21PYmooe1xuICAgICAgICAgICAgZmFtaWx5OiBmYW1pbHksXG4gICAgICAgICAgICB3ZWlnaHQ6IEZvbnRMb2FkZXIuRk9OVF9XRUlHSFRbd2VpZ2h0XXx8d2VpZ2h0LFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3JjOiBjc3NTcmNcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGZvbnQgZGVmaW5pdGlvbiBmcm9tIGEgcmF3IGZvbnQgb2JqZWN0LlxuICAgICAqIEBtZXRob2QgX2RlZkZyb21PYmpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbyBBIHJhdyBvYmplY3QgcHJvdmlkZWQgdG8gdGhlIEZvbnRMb2FkZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIHN0YW5kYXJkIGZvbnQgb2JqZWN0IHRoYXQgdGhlIEZvbnRMb2FkZXIgdW5kZXJzdGFuZHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcC5fZGVmRnJvbU9iaiA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdmFyIGRlZiA9IHtcbiAgICAgICAgICAgIGZhbWlseTogby5mYW1pbHksXG4gICAgICAgICAgICBzcmM6IG8uc3JjLFxuICAgICAgICAgICAgc3R5bGU6IG8uc3R5bGUgfHwgXCJub3JtYWxcIixcbiAgICAgICAgICAgIHdlaWdodDogby53ZWlnaHQgfHwgXCJub3JtYWxcIlxuICAgICAgICB9O1xuICAgICAgICBkZWYuaWQgPSBkZWYuZmFtaWx5ICsgXCI7XCIgKyBkZWYuc3R5bGUgKyBcIjtcIiArIGRlZi53ZWlnaHQ7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBDU1MgZnJvbSBhIGZvbnQgZGVmaW5pdGlvbi5cbiAgICAgKiBAbWV0aG9kIF9jc3NGcm9tRGVmXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlZiBBIGZvbnQgZGVmaW5pdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl9jc3NGcm9tRGVmID0gZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgIHJldHVybiBcIkBmb250LWZhY2Uge1xcblwiICtcbiAgICAgICAgICAgIFwiXFx0Zm9udC1mYW1pbHk6ICdcIitkZWYuZmFtaWx5K1wiJztcXG5cIiArXG4gICAgICAgICAgICBcIlxcdGZvbnQtc3R5bGU6IFwiK2RlZi5zdHlsZStcIjtcXG5cIiArXG4gICAgICAgICAgICBcIlxcdGZvbnQtd2VpZ2h0OiBcIitkZWYud2VpZ2h0K1wiO1xcblwiICtcbiAgICAgICAgICAgIFwiXFx0c3JjOiBcIitkZWYuc3JjK1wiO1xcblwiICtcbiAgICAgICAgICAgIFwifVwiO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRleHQgd2lkdGggb2YgdGV4dCB1c2luZyB0aGUgZmFtaWx5LCB3ZWlnaHQsIGFuZCBzdHlsZVxuICAgICAqIEBtZXRob2QgX2dldFRleHRXaWR0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmYW1pbHkgVGhlIGZvbnQgZmFtaWx5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdlaWdodCBUaGUgZm9udCB3ZWlnaHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3R5bGUgVGhlIGZvbnQgc3R5bGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgcGl4ZWwgbWVhc3VyZW1lbnQgb2YgdGhlIGZvbnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHAuX2dldFRleHRXaWR0aCA9IGZ1bmN0aW9uKGZhbWlseSwgd2VpZ2h0LCBzdHlsZSkge1xuICAgICAgICB2YXIgY3R4ID0gRm9udExvYWRlci5fY3R4O1xuICAgICAgICBjdHguZm9udCA9IHN0eWxlK1wiIFwiK3dlaWdodCtcIiA3MnB4IFwiK2ZhbWlseTtcbiAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dChGb250TG9hZGVyLnNhbXBsZVRleHQpLndpZHRoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgZnJvbSBhIENTUyBzdHJpbmcuIEZvciBleGFtcGxlLCBzZWFyY2hlcyBhIENTUyBzdHJpbmcgZm9yIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgKiBcImZvbnQtZmFtaWx5XCIgcHJvcGVydHkuXG4gICAgICogQG1ldGhvZCBfZ2V0Q1NTVmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBDU1Mgc3RyaW5nIHRvIHNlYXJjaFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSBUaGUgcHJvcGVydHkgbmFtZSB0byBnZXQgdGhlIHZhbHVlIGZvclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB2YWx1ZSBpbiB0aGUgQ1NTIGZvciB0aGUgcHJvdmlkZWQgcHJvcGVydHkgbmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwLl9nZXRDU1NWYWx1ZSA9IGZ1bmN0aW9uKHN0ciwgcHJvcE5hbWUpIHtcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChwcm9wTmFtZStcIjpcXHMqKFteO31dKz8pXFxzKls7fV1cIik7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdleC5leGVjKHN0cik7XG4gICAgICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHRbMV0pIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICB9O1xuXG4gICAgY3JlYXRlanMuRm9udExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoRm9udExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEltYWdlTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgLyoqXG4gICAgICogQSBsb2FkZXIgZm9yIGltYWdlIGZpbGVzLlxuICAgICAqIEBjbGFzcyBJbWFnZUxvYWRlclxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG4gICAgICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbWFnZUxvYWRlciAobG9hZEl0ZW0sIHByZWZlclhIUikge1xuICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLklNQUdFKTtcblxuICAgICAgICAvLyBwdWJsaWMgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuICAgICAgICAvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuICAgICAgICB0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwcmVsb2FkIGl0ZW0gaXMgYWxyZWFkeSBhIHRhZy5cbiAgICAgICAgaWYgKGNyZWF0ZWpzLkRvbVV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLl90YWcgPSBsb2FkSXRlbTtcbiAgICAgICAgfSBlbHNlIGlmIChjcmVhdGVqcy5Eb21VdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtLnNyYykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhZyA9IGxvYWRJdGVtLnNyYztcbiAgICAgICAgfSBlbHNlIGlmIChjcmVhdGVqcy5Eb21VdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtLnRhZykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhZyA9IGxvYWRJdGVtLnRhZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl90YWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJlZmVyWEhSID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90YWcgPSBjcmVhdGVqcy5FbGVtZW50cy5pbWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG4gICAgfTtcblxuICAgIHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEltYWdlTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG4gICAgdmFyIHMgPSBJbWFnZUxvYWRlcjtcblxuICAgIC8vIHN0YXRpYyBtZXRob2RzXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLlR5cGVzLklNQUdFO1xuICAgIH07XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhZy5zcmMgIT0gXCJcIiAmJiB0aGlzLl90YWcuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNyb3NzT3JpZ2luID0gdGhpcy5faXRlbS5jcm9zc09yaWdpbjtcbiAgICAgICAgaWYgKGNyb3NzT3JpZ2luID09IHRydWUpIHsgY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiOyB9XG4gICAgICAgIGlmIChjcm9zc09yaWdpbiAhPSBudWxsICYmICFjcmVhdGVqcy5VUkxVdGlscy5pc0xvY2FsKHRoaXMuX2l0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLl90YWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuICAgIH07XG5cbiAgICAvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIEJlZm9yZSB0aGUgaXRlbSBsb2Fkcywgc2V0IGl0cyBtaW1lVHlwZSBhbmQgcmVzcG9uc2VUeXBlLlxuICAgICAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX3VwZGF0ZVhIUiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5sb2FkZXIubWltZVR5cGUgPSAndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZC1iaW5hcnknO1xuXG4gICAgICAgIC8vIE9ubHkgZXhpc3RzIGZvciBYSFJcbiAgICAgICAgaWYgKGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJibG9iXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBJbWFnZSBmaWxlcy5cbiAgICAgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcbiAgICAgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcbiAgICAgKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdEltYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXN5bmNocm9ub3VzIGltYWdlIGZvcm1hdHRlciBmdW5jdGlvbi4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIGltYWdlcyBoYXZlXG4gICAgICogYSBzaG9ydCBkZWxheSBiZWZvcmUgdGhleSBhcmUgcmVhZHkuXG4gICAgICogQG1ldGhvZCBfZm9ybWF0SW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzQ2FsbGJhY2sgVGhlIG1ldGhvZCB0byBjYWxsIHdoZW4gdGhlIHJlc3VsdCBoYXMgZmluaXNoZWQgZm9ybWF0dGluZ1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yQ2FsbGJhY2sgVGhlIG1ldGhvZCB0byBjYWxsIGlmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgZm9ybWF0dGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5fZm9ybWF0SW1hZ2UgPSBmdW5jdGlvbiAoc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0YWcgPSB0aGlzLl90YWc7XG4gICAgICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcblxuICAgICAgICAgICAgLy9kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRhZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoVVJMKSB7XG4gICAgICAgICAgICB2YXIgb2JqVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLmdldFJlc3VsdCh0cnVlKSk7XG4gICAgICAgICAgICB0YWcuc3JjID0gb2JqVVJMO1xuXG4gICAgICAgICAgICB0YWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5fY2xlYW5VcFVSTCwgZmFsc2UpO1xuICAgICAgICAgICAgdGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9jbGVhblVwVVJMLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWcuc3JjID0gdGhpcy5faXRlbS5zcmM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFnLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2sodGFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhZy5vbmxvYWQgPSBjcmVhdGVqcy5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2sodGhpcy5fdGFnKTtcbiAgICAgICAgICAgICAgICB0YWcub25sb2FkID0gdGFnLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHRhZy5vbmVycm9yID0gY3JlYXRlanMucHJveHkoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KCdJTUFHRV9GT1JNQVQnLCBudWxsLCBldmVudCkpO1xuICAgICAgICAgICAgICAgIHRhZy5vbmxvYWQgPSB0YWcub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCB0aGUgT2JqZWN0VVJMLCB0aGUgdGFnIGlzIGRvbmUgd2l0aCBpdC4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgcnVuXG4gICAgICogYXMgYW4gZXZlbnQgbGlzdGVuZXIgd2l0aG91dCBhIHByb3h5L2Nsb3N1cmUsIGFzIGl0IGRvZXNuJ3QgcmVxdWlyZSBpdCAtIHNvIGRvIG5vdFxuICAgICAqIGluY2x1ZGUgYW55IGZ1bmN0aW9uYWxpdHkgdGhhdCByZXF1aXJlcyBzY29wZSB3aXRob3V0IGNoYW5naW5nIGl0LlxuICAgICAqIEBtZXRob2QgX2NsZWFuVXBVUkxcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2NsZWFuVXBVUkwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChldmVudC50YXJnZXQuc3JjKTtcbiAgICB9O1xuXG4gICAgY3JlYXRlanMuSW1hZ2VMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEltYWdlTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSmF2YVNjcmlwdExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBjb25zdHJ1Y3RvclxuICAgIC8qKlxuICAgICAqIEEgbG9hZGVyIGZvciBKYXZhU2NyaXB0IGZpbGVzLlxuICAgICAqIEBjbGFzcyBKYXZhU2NyaXB0TG9hZGVyXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcbiAgICAgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEphdmFTY3JpcHRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLkpBVkFTQ1JJUFQpO1xuXG4gICAgICAgIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG4gICAgICAgIC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwic3JjXCI7XG4gICAgICAgIHRoaXMuc2V0VGFnKGNyZWF0ZWpzLkVsZW1lbnRzLnNjcmlwdCgpKTtcbiAgICB9O1xuXG4gICAgdmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSmF2YVNjcmlwdExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuICAgIHZhciBzID0gSmF2YVNjcmlwdExvYWRlcjtcblxuICAgIC8vIHN0YXRpYyBtZXRob2RzXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5KQVZBU0NSSVBUO1xuICAgIH07XG5cbiAgICAvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBKYXZhU2NyaXB0IGZpbGVzLlxuICAgICAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuICAgICAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuICAgICAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgdmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByZWZlclhIUikge1xuICAgICAgICAgICAgdGFnLnRleHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfTtcblxuICAgIGNyZWF0ZWpzLkphdmFTY3JpcHRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEphdmFTY3JpcHRMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBKU09OTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgLyoqXG4gICAgICogQSBsb2FkZXIgZm9yIEpTT04gZmlsZXMuIFRvIGxvYWQgSlNPTiBjcm9zcy1kb21haW4sIHVzZSBKU09OUCBhbmQgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogaW5zdGVhZC4gVG8gbG9hZCBKU09OLWZvcm1hdHRlZCBtYW5pZmVzdHMsIHVzZSB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHRvXG4gICAgICogbG9hZCBFYXNlbEpTIFNwcml0ZVNoZWV0cywgdXNlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBjbGFzcyBKU09OTG9hZGVyXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG4gICAgICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBKU09OTG9hZGVyKGxvYWRJdGVtKSB7XG4gICAgICAgIHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLlR5cGVzLkpTT04pO1xuXG4gICAgICAgIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuICAgIH07XG5cbiAgICB2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChKU09OTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG4gICAgdmFyIHMgPSBKU09OTG9hZGVyO1xuXG4gICAgLy8gc3RhdGljIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJUeXBlcy9KU09OOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5KU09OO1xuICAgIH07XG5cbiAgICAvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBKU09OIGZpbGVzLlxuICAgICAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuICAgICAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuICAgICAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgdmFyIGpzb24gPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAganNvbiA9IGNyZWF0ZWpzLkRhdGFVdGlscy5wYXJzZUpTT04obG9hZGVyLmdldFJlc3VsdCh0cnVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiSlNPTl9GT1JNQVRcIiwgbnVsbCwgZSk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9O1xuXG4gICAgY3JlYXRlanMuSlNPTkxvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSlNPTkxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEpTT05QTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgLyoqXG4gICAgICogQSBsb2FkZXIgZm9yIEpTT05QIGZpbGVzLCB3aGljaCBhcmUgSlNPTi1mb3JtYXR0ZWQgdGV4dCBmaWxlcywgd3JhcHBlZCBpbiBhIGNhbGxiYWNrLiBUbyBsb2FkIHJlZ3VsYXIgSlNPTlxuICAgICAqIHdpdGhvdXQgYSBjYWxsYmFjayB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC4gVG8gbG9hZCBKU09OLWZvcm1hdHRlZCBtYW5pZmVzdHMsXG4gICAgICogdXNlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdG8gbG9hZCBFYXNlbEpTIFNwcml0ZVNoZWV0cywgdXNlXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiBKU09OUCBpcyBhIGZvcm1hdCB0aGF0IHByb3ZpZGVzIGEgc29sdXRpb24gZm9yIGxvYWRpbmcgSlNPTiBmaWxlcyBjcm9zcy1kb21haW4gPGVtPndpdGhvdXQ8L2VtPiByZXF1aXJpbmcgQ09SUy5cbiAgICAgKiBKU09OUCBmaWxlcyBhcmUgbG9hZGVkIGFzIEphdmFTY3JpcHQsIGFuZCB0aGUgXCJjYWxsYmFja1wiIGlzIGV4ZWN1dGVkIG9uY2UgdGhleSBhcmUgbG9hZGVkLiBUaGUgY2FsbGJhY2sgaW4gdGhlXG4gICAgICogSlNPTlAgbXVzdCBtYXRjaCB0aGUgY2FsbGJhY2sgcGFzc2VkIHRvIHRoZSBsb2FkSXRlbS5cbiAgICAgKlxuICAgICAqIDxoND5FeGFtcGxlIEpTT05QPC9oND5cbiAgICAgKlxuICAgICAqICAgICAgY2FsbGJhY2tOYW1lKHtcbiAgICAgKiAgICAgICAgICBcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuICAgICAqICAgICAgICAgIFwibnVtXCI6IDMsXG4gICAgICogICAgICAgICAgXCJvYmpcIjogeyBcImJvb2xcIjp0cnVlIH1cbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogPGg0PkV4YW1wbGU8L2g0PlxuICAgICAqXG4gICAgICogICAgICB2YXIgbG9hZEl0ZW0gPSB7aWQ6XCJqc29uXCIsIHR5cGU6XCJqc29ucFwiLCBzcmM6XCJodHRwOi8vc2VydmVyLmNvbS90ZXh0Lmpzb25cIiwgY2FsbGJhY2s6XCJjYWxsYmFja05hbWVcIn1cbiAgICAgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcbiAgICAgKiAgICAgIHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUpO1xuICAgICAqICAgICAgcXVldWUubG9hZEl0ZW0obG9hZEl0ZW0pO1xuICAgICAqXG4gICAgICogICAgICBmdW5jdGlvbiBoYW5kbGVDb21wbGV0ZShldmVudCkgfVxuICAgICAqICAgICAgICAgIHZhciBqc29uID0gcXVldWUuZ2V0UmVzdWx0KFwianNvblwiKTtcbiAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZyhqc29uLm9iai5ib29sKTsgLy8gdHJ1ZVxuICAgICAqICAgICAgfVxuICAgICAqXG4gICAgICogSlNPTlAgZmlsZXMgbG9hZGVkIGNvbmN1cnJlbnRseSByZXF1aXJlIGEgPGVtPnVuaXF1ZTwvZW0+IGNhbGxiYWNrLiBUbyBlbnN1cmUgSlNPTlAgZmlsZXMgYXJlIGxvYWRlZCBpbiBvcmRlcixcbiAgICAgKiBlaXRoZXIgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIChzZXQgdG8gMSksIG9yIHNldFxuICAgICAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL21haW50YWluT3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gb24gaXRlbXMgd2l0aCB0aGUgc2FtZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEltcG9ydGFudCBub3RlOiBTb21lIGJyb3dzZXJzIHdpbGwgcHJldmVudCBKU09OUCBmcm9tIGZpcmluZyB0aGUgY2FsbGJhY2sgaWYgdGhlIGZpbGUgd2FzIGxvYWRlZCBhcyBKU09OLCBhbmQgbm90XG4gICAgICogSmF2YVNjcmlwdC4gWW91IG1heSBoYXZlIHRvIGhhdmUgeW91ciBzZXJ2ZXIgZ2l2ZSB5b3UgYSBKYXZhU2NyaXB0IG1pbWUtdHlwZSBmb3IgdGhpcyB0byB3b3JrLlxuICAgICAqXG4gICAgICogQGNsYXNzIEpTT05QTG9hZGVyXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG4gICAgICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBKU09OUExvYWRlcihsb2FkSXRlbSkge1xuICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBmYWxzZSwgY3JlYXRlanMuVHlwZXMuSlNPTlApO1xuICAgICAgICB0aGlzLnNldFRhZyhjcmVhdGVqcy5FbGVtZW50cy5zY3JpcHQoKSk7XG4gICAgICAgIHRoaXMuZ2V0VGFnKCkudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gICAgfTtcblxuICAgIHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEpTT05QTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG4gICAgdmFyIHMgPSBKU09OUExvYWRlcjtcblxuXG4gICAgLy8gc3RhdGljIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJUeXBlcy9KU09OUDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuSlNPTlA7XG4gICAgfTtcblxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgcC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuQWJzdHJhY3RMb2FkZXJfY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIEpTT05wIGZpbGUuICBCZWNhdXNlIG9mIHRoZSB1bmlxdWUgbG9hZGluZyBuZWVkcyBvZiBKU09OcFxuICAgICAqIHdlIGRvbid0IHVzZSB0aGUgQWJzdHJhY3RMb2FkZXIubG9hZCgpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAqXG4gICAgICovXG4gICAgcC5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbS5jYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGlzIHJlcXVpcmVkIGZvciBsb2FkaW5nIEpTT05QIHJlcXVlc3RzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogTG9vayBpbnRvIGNyZWF0aW5nIG91ciBvd24gaUZyYW1lIHRvIGhhbmRsZSB0aGUgbG9hZFxuICAgICAgICAvLyBJbiB0aGUgZmlyc3QgYXR0ZW1wdCwgRkYgZGlkIG5vdCBnZXQgdGhlIHJlc3VsdFxuICAgICAgICAvLyAgIHJlc3VsdCBpbnN0YW5jZW9mIE9iamVjdCBkaWQgbm90IHdvcmsgZWl0aGVyXG4gICAgICAgIC8vICAgc28gd2Ugd291bGQgbmVlZCB0byBjbG9uZSB0aGUgcmVzdWx0LlxuICAgICAgICBpZiAod2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkpTT05QIGNhbGxiYWNrICdcIiArXG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbS5jYWxsYmFjayArXG4gICAgICAgICAgICAgICAgXCInIGFscmVhZHkgZXhpc3RzIG9uIHdpbmRvdy4gWW91IG5lZWQgdG8gc3BlY2lmeSBhIGRpZmZlcmVudCBjYWxsYmFjayBvciByZS1uYW1lIHRoZSBjdXJyZW50IG9uZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3dbdGhpcy5faXRlbS5jYWxsYmFja10gPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkLCB0aGlzKTtcbiAgICAgICAgY3JlYXRlanMuRG9tVXRpbHMuYXBwZW5kVG9Cb2R5KHRoaXMuX3RhZyk7XG5cbiAgICAgICAgdGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcblxuICAgICAgICAvLyBMb2FkIHRoZSB0YWdcbiAgICAgICAgdGhpcy5fdGFnLnNyYyA9IHRoaXMuX2l0ZW0uc3JjO1xuICAgIH07XG5cbiAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIEpTT05QIGNhbGxiYWNrLCB3aGljaCBpcyBhIHB1YmxpYyBtZXRob2QgZGVmaW5lZCBvbiBgd2luZG93YC5cbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVMb2FkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGZvcm1hdHRlZCBKU09OIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVMb2FkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fcmF3UmVzdWx0ID0gZGF0YTtcbiAgICAgICAgdGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cbiAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFnIHJlcXVlc3QgaGFzIG5vdCBsb2FkZWQgd2l0aGluIHRoZSB0aW1lIHNwZWNmaWVkIGluIGxvYWRUaW1lb3V0LlxuICAgICAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgZXJyb3IgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcInRpbWVvdXRcIikpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCB0aGUgSlNPTlAgbG9hZC4gVGhpcyBjbGVhcnMgb3V0IHRoZSBjYWxsYmFjayBhbmQgc2NyaXB0IHRhZyB0aGF0IHRoaXMgbG9hZGVyIGNyZWF0ZXMuXG4gICAgICogQG1ldGhvZCBfZGlzcG9zZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5fZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3JlYXRlanMuRG9tVXRpbHMucmVtb3ZlQ2hpbGQodGhpcy5fdGFnKTtcbiAgICAgICAgZGVsZXRlIHdpbmRvd1t0aGlzLl9pdGVtLmNhbGxiYWNrXTtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuICAgIH07XG5cbiAgICBjcmVhdGVqcy5KU09OUExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSlNPTlBMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNYW5pZmVzdExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBjb25zdHJ1Y3RvclxuICAgIC8qKlxuICAgICAqIEEgbG9hZGVyIGZvciBKU09OIG1hbmlmZXN0cy4gSXRlbXMgaW5zaWRlIHRoZSBtYW5pZmVzdCBhcmUgbG9hZGVkIGJlZm9yZSB0aGUgbG9hZGVyIGNvbXBsZXRlcy4gVG8gbG9hZCBtYW5pZmVzdHNcbiAgICAgKiB1c2luZyBKU09OUCwgc3BlY2lmeSBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2NhbGxiYWNrOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFzIHBhcnQgb2YgdGhlXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiBUaGUgbGlzdCBvZiBmaWxlcyBpbiB0aGUgbWFuaWZlc3QgbXVzdCBiZSBkZWZpbmVkIG9uIHRoZSB0b3AtbGV2ZWwgSlNPTiBvYmplY3QgaW4gYSBgbWFuaWZlc3RgIHByb3BlcnR5LiBUaGlzXG4gICAgICogZXhhbXBsZSBzaG93cyBhIHNhbXBsZSBtYW5pZmVzdCBkZWZpbml0aW9uLCBhcyB3ZWxsIGFzIGhvdyB0byB0byBpbmNsdWRlIGEgc3ViLW1hbmlmZXN0LlxuICAgICAqXG4gICAgICogICAgICB7XG4gICAgICogICAgICAgICAgXCJwYXRoXCI6IFwiYXNzZXRzL1wiLFxuICAgICAqICAgICAgICAgIFwibWFuaWZlc3RcIjogW1xuICAgICAqICAgICAgICAgICAgICBcImltYWdlLnBuZ1wiLFxuICAgICAqICAgICAgICAgICAgICB7XCJzcmNcIjogXCJpbWFnZTIucG5nXCIsIFwiaWRcIjpcImltYWdlMlwifSxcbiAgICAgKiAgICAgICAgICAgICAge1wic3JjXCI6IFwic3ViLW1hbmlmZXN0Lmpzb25cIiwgXCJ0eXBlXCI6XCJtYW5pZmVzdFwiLCBcImNhbGxiYWNrXCI6XCJqc29uQ2FsbGJhY2tcIn1cbiAgICAgKiAgICAgICAgICBdXG4gICAgICogICAgICB9XG4gICAgICpcbiAgICAgKiBXaGVuIGEgTWFuaWZlc3RMb2FkZXIgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLCB0aGUgcGFyZW50IGxvYWRlciAodXN1YWxseSBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSxcbiAgICAgKiBidXQgY291bGQgYWxzbyBiZSBhbm90aGVyIE1hbmlmZXN0TG9hZGVyKSB3aWxsIGluaGVyaXQgYWxsIHRoZSBsb2FkZWQgaXRlbXMsIHNvIHlvdSBjYW4gYWNjZXNzIHRoZW0gZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFyZVxuICAgICAqIGhpZ2hlciBwcmlvcml0eSBsb2FkZXJzLCBzbyBtYW5pZmVzdHMgPHN0cm9uZz5tdXN0PC9zdHJvbmc+IHNldCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS90eXBlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IHRvIHt7I2Nyb3NzTGluayBcIlR5cGVzL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogQWRkaXRpb25hbGx5LCBzb21lIGJyb3dzZXJzIHJlcXVpcmUgdGhlIHNlcnZlciB0byBzZXJ2ZSBhIEphdmFTY3JpcHQgbWltZS10eXBlIGZvciBKU09OUCwgc28gaXQgbWF5IG5vdCB3b3JrIGluXG4gICAgICogc29tZSBjb25kaXRpb25zLlxuICAgICAqIEBjbGFzcyBNYW5pZmVzdExvYWRlclxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuICAgICAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFuaWZlc3RMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLk1BTklGRVNUKTtcblxuICAgIC8vIFB1YmxpYyBQcm9wZXJ0aWVzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB0aGUgcGx1Z2lucyByZWdpc3RlcmVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LFxuICAgICAgICAgKiB1c2VkIHRvIHBhc3MgcGx1Z2lucyB0byBuZXcgTG9hZFF1ZXVlcyB0aGF0IG1heSBiZSBjcmVhdGVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgX3BsdWdpbnNcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAc2luY2UgMC42LjFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IG51bGw7XG5cblxuICAgIC8vIFByb3RlY3RlZCBQcm9wZXJ0aWVzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbnRlcm5hbCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyB0aGUgY29udGVudHMgb2YgdGhlIG1hbmlmZXN0LlxuICAgICAgICAgKiBAcHJvcGVydHkgX21hbmlmZXN0UXVldWVcbiAgICAgICAgICogQHR5cGUge0xvYWRRdWV1ZX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmlmZXN0UXVldWUgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNYW5pZmVzdExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuICAgIHZhciBzID0gTWFuaWZlc3RMb2FkZXI7XG5cbiAgICAvLyBzdGF0aWMgcHJvcGVydGllc1xuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3MgdGhhdCB0aGUgbWFuaWZlc3QgaXRzZWxmIHRha2VzIHVwLlxuICAgICAqIEBwcm9wZXJ0eSBNQU5JRkVTVF9QUk9HUkVTU1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4yNSAoMjUlKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHMuTUFOSUZFU1RfUFJPR1JFU1MgPSAwLjI1O1xuXG4gICAgLy8gc3RhdGljIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJUeXBlcy9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5NQU5JRkVTVDtcbiAgICB9O1xuXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICBwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuICAgIH07XG5cbiAgICAvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuICAgIHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5faXRlbS5jYWxsYmFjaztcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTlBMb2FkZXIodGhpcy5faXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05Mb2FkZXIodGhpcy5faXRlbSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3Jhd1Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRQcm9ncmVzcyhzLk1BTklGRVNUX1BST0dSRVNTKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkTWFuaWZlc3QodGhpcy5fcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwicHJvZ3Jlc3NcIjpcbiAgICAgICAgICAgICAgICBldmVudC5sb2FkZWQgKj0gcy5NQU5JRkVTVF9QUk9HUkVTUztcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWw7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJvZ3Jlc3MpIHx8IHRoaXMucHJvZ3Jlc3MgPT0gSW5maW5pdHkpIHsgdGhpcy5wcm9ncmVzcyA9IDA7IH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kUHJvZ3Jlc3MoZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2hhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICB9O1xuXG4gICAgcC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuQWJzdHJhY3RMb2FkZXJfZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9tYW5pZmVzdFF1ZXVlLmNsb3NlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgbWFuaWZlc3QgaXRlbXMgb25jZSB0aGUgYWN0dWFsIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZC5cbiAgICAgKiBAbWV0aG9kIF9sb2FkTWFuaWZlc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0ganNvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5fbG9hZE1hbmlmZXN0ID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgaWYgKGpzb24gJiYganNvbi5tYW5pZmVzdCkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5fbWFuaWZlc3RRdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUodGhpcy5fcHJlZmVyWEhSKTtcbiAgICAgICAgICAgIHF1ZXVlLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCwgdGhpcyk7XG4gICAgICAgICAgICBxdWV1ZS5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MsIHRoaXMpO1xuICAgICAgICAgICAgcXVldWUub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHF1ZXVlLm9uKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RFcnJvciwgdGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSA8IGw7IGkrKykgeyAgIC8vIGNvbnNlcnZlIG9yZGVyIG9mIHBsdWdpbnNcbiAgICAgICAgICAgICAgICBxdWV1ZS5pbnN0YWxsUGx1Z2luKHRoaXMucGx1Z2luc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoanNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbiBpdGVtIGZyb20gdGhlIHt7I2Nyb3NzTGluayBcIl9tYW5pZmVzdFF1ZXVlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBjb21wbGV0ZWQuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RGaWxlTG9hZFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYW5pZmVzdCBoYXMgY29tcGxldGVkIGxvYWRpbmcuIFRoaXMgdHJpZ2dlcnMgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICoge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZnJvbSB0aGUgTWFuaWZlc3RMb2FkZXIuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RDb21wbGV0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2xvYWRlZEl0ZW1zID0gdGhpcy5fbWFuaWZlc3RRdWV1ZS5nZXRJdGVtcyh0cnVlKTtcbiAgICAgICAgdGhpcy5fc2VuZENvbXBsZXRlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYW5pZmVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RQcm9ncmVzc1xuICAgICAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IGV2ZW50LnByb2dyZXNzICogKDEgLSBzLk1BTklGRVNUX1BST0dSRVNTKSArIHMuTUFOSUZFU1RfUFJPR1JFU1M7XG4gICAgICAgIHRoaXMuX3NlbmRQcm9ncmVzcyh0aGlzLnByb2dyZXNzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hbmlmZXN0IGhhcyByZXBvcnRlZCBhbiBlcnJvciB3aXRoIG9uZSBvZiB0aGUgZmlsZXMuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RFcnJvclxuICAgICAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2hhbmRsZU1hbmlmZXN0RXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWVycm9yXCIpO1xuICAgICAgICBuZXdFdmVudC5pdGVtID0gZXZlbnQuZGF0YTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9O1xuXG4gICAgY3JlYXRlanMuTWFuaWZlc3RMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKE1hbmlmZXN0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU291bmRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gY29uc3RydWN0b3JcbiAgICAvKipcbiAgICAgKiBBIGxvYWRlciBmb3IgSFRNTCBhdWRpbyBmaWxlcy4gUHJlbG9hZEpTIGNhbiBub3QgbG9hZCBXZWJBdWRpbyBmaWxlcywgYXMgYSBXZWJBdWRpbyBjb250ZXh0IGlzIHJlcXVpcmVkLCB3aGljaFxuICAgICAqIHNob3VsZCBiZSBjcmVhdGVkIGJ5IGVpdGhlciBhIGxpYnJhcnkgcGxheWluZyB0aGUgc291bmQgKHN1Y2ggYXMgPGEgaHJlZj1cImh0dHA6Ly9zb3VuZGpzLmNvbVwiPlNvdW5kSlM8L2E+LCBvciBhblxuICAgICAqIGV4dGVybmFsIGZyYW1ld29yayB0aGF0IGhhbmRsZXMgYXVkaW8gcGxheWJhY2suIFRvIGxvYWQgY29udGVudCB0aGF0IGNhbiBiZSBwbGF5ZWQgYnkgV2ViQXVkaW8sIHVzZSB0aGVcbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJCaW5hcnlMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCBoYW5kbGUgdGhlIGF1ZGlvIGNvbnRleHQgZGVjb2RpbmcgbWFudWFsbHkuXG4gICAgICogQGNsYXNzIFNvdW5kTG9hZGVyXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcbiAgICAgKiBAZXh0ZW5kcyBBYnN0cmFjdE1lZGlhTG9hZGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU291bmRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuICAgICAgICB0aGlzLkFic3RyYWN0TWVkaWFMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuVHlwZXMuU09VTkQpO1xuXG4gICAgICAgIC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgIGlmIChjcmVhdGVqcy5Eb21VdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5fdGFnID0gbG9hZEl0ZW07XG4gICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlanMuRG9tVXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbS5zcmMpKSB7XG4gICAgICAgICAgICB0aGlzLl90YWcgPSBsb2FkSXRlbTtcbiAgICAgICAgfSBlbHNlIGlmIChjcmVhdGVqcy5Eb21VdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtLnRhZykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhZyA9IGNyZWF0ZWpzLkRvbVV0aWxzLmlzQXVkaW9UYWcobG9hZEl0ZW0pID8gbG9hZEl0ZW0gOiBsb2FkSXRlbS5zcmM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNvdW5kTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyKTtcbiAgICB2YXIgcyA9IFNvdW5kTG9hZGVyO1xuXG4gICAgLy8gc3RhdGljIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJUeXBlcy9TT1VORDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG4gICAgICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuVHlwZXMuU09VTkQ7XG4gICAgfTtcblxuICAgIC8vIHByb3RlY3RlZCBtZXRob2RzXG4gICAgcC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKHNyYykge1xuICAgICAgICB2YXIgdGFnID0gY3JlYXRlanMuRWxlbWVudHMuYXVkaW8oKTtcbiAgICAgICAgdGFnLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgICAgIHRhZy5wcmVsb2FkID0gXCJub25lXCI7XG5cbiAgICAgICAgLy9MTTogRmlyZWZveCBmYWlscyB3aGVuIHRoaXMgdGhlIHByZWxvYWQ9XCJub25lXCIgZm9yIG90aGVyIHRhZ3MsIGJ1dCBpdCBuZWVkcyB0byBiZSBcIm5vbmVcIiB0byBlbnN1cmUgUHJlbG9hZEpTIHdvcmtzLlxuICAgICAgICB0YWcuc3JjID0gc3JjO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH07XG5cbiAgICBjcmVhdGVqcy5Tb3VuZExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoU291bmRMb2FkZXIsIFwiQWJzdHJhY3RNZWRpYUxvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFZpZGVvTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgLyoqXG4gICAgICogQSBsb2FkZXIgZm9yIHZpZGVvIGZpbGVzLlxuICAgICAqIEBjbGFzcyBWaWRlb0xvYWRlclxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG4gICAgICogQGV4dGVuZHMgQWJzdHJhY3RNZWRpYUxvYWRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZpZGVvTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcbiAgICAgICAgdGhpcy5BYnN0cmFjdE1lZGlhTG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLlZJREVPKTtcblxuICAgICAgICBpZiAoY3JlYXRlanMuRG9tVXRpbHMuaXNWaWRlb1RhZyhsb2FkSXRlbSkgfHwgY3JlYXRlanMuRG9tVXRpbHMuaXNWaWRlb1RhZyhsb2FkSXRlbS5zcmMpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRhZyhjcmVhdGVqcy5Eb21VdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtKT9sb2FkSXRlbTpsb2FkSXRlbS5zcmMpO1xuXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCB1c2UgWEhSIGZvciBhIHRhZyB0aGF0J3MgcGFzc2VkIGluLlxuICAgICAgICAgICAgdGhpcy5fcHJlZmVyWEhSID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFRhZyh0aGlzLl9jcmVhdGVUYWcoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVmlkZW9Mb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TWVkaWFMb2FkZXIpO1xuICAgIHZhciBzID0gVmlkZW9Mb2FkZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdmlkZW8gdGFnXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVqcy5FbGVtZW50cy52aWRlbygpO1xuICAgIH07XG5cbiAgICAvLyBzdGF0aWMgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuICAgICAqIHt7I2Nyb3NzTGluayBcIlR5cGVzL1ZJREVPOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5WSURFTztcbiAgICB9O1xuXG4gICAgY3JlYXRlanMuVmlkZW9Mb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFZpZGVvTG9hZGVyLCBcIkFic3RyYWN0TWVkaWFMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBjb25zdHJ1Y3RvclxuICAgIC8qKlxuICAgICAqIEEgbG9hZGVyIGZvciBFYXNlbEpTIFNwcml0ZVNoZWV0cy4gSW1hZ2VzIGluc2lkZSB0aGUgc3ByaXRlc2hlZXQgZGVmaW5pdGlvbiBhcmUgbG9hZGVkIGJlZm9yZSB0aGUgbG9hZGVyXG4gICAgICogY29tcGxldGVzLiBUbyBsb2FkIFNwcml0ZVNoZWV0cyB1c2luZyBKU09OUCwgc3BlY2lmeSBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2NhbGxiYWNrOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogYXMgcGFydCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIGFuZCB7eyNjcm9zc0xpbmsgXCJKU09OUExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhcmUgaGlnaGVyIHByaW9yaXR5IGxvYWRlcnMsIHNvIFNwcml0ZVNoZWV0cyA8c3Ryb25nPm11c3Q8L3N0cm9uZz5cbiAgICAgKiBzZXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHlcbiAgICAgKiB0byB7eyNjcm9zc0xpbmsgXCJUeXBlcy9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKlxuICAgICAqIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jcm9zc09yaWdpbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBhcyB3ZWxsXG4gICAgICogYXMgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZSdzXCJ9fXt7L2Nyb3NzTGlua319IGBiYXNlUGF0aGAgYXJndW1lbnQgYW5kIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9fcHJlZmVyWEhSXCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICogcHJvcGVydHkgc3VwcGxpZWQgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSBhcmUgcGFzc2VkIG9uIHRvIHRoZSBzdWItbWFuaWZlc3QgdGhhdCBsb2Fkc1xuICAgICAqIHRoZSBTcHJpdGVTaGVldCBpbWFnZXMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIFNwcml0ZVNoZWV0IEpTT04gZG9lcyBub3QgcmVzcGVjdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL19wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBwcm9wZXJ0eSwgd2hpY2ggc2hvdWxkIGluc3RlYWQgYmUgZGV0ZXJtaW5lZCBieSB0aGUgcHJlc2VuY2Ugb2YgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jYWxsYmFjazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIHByb3BlcnR5IG9uIHRoZSBTcHJpdGVTaGVldCBsb2FkIGl0ZW0uIFRoaXMgaXMgYmVjYXVzZSB0aGUgSlNPTiBsb2FkZWQgd2lsbCBoYXZlIGEgZGlmZmVyZW50IGZvcm1hdCBkZXBlbmRpbmcgb25cbiAgICAgKiBpZiBpdCBpcyBsb2FkZWQgYXMgSlNPTiwgc28ganVzdCBjaGFuZ2luZyBgcHJlZmVyWEhSYCBpcyBub3QgZW5vdWdoIHRvIGNoYW5nZSBob3cgaXQgaXMgbG9hZGVkLlxuICAgICAqIEBjbGFzcyBTcHJpdGVTaGVldExvYWRlclxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuICAgICAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3ByaXRlU2hlZXRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLlNQUklURVNIRUVUKTtcblxuICAgICAgICAvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgcXVldWUgd2hpY2ggbG9hZHMgdGhlIFNwcml0ZVNoZWV0J3MgaW1hZ2VzLlxuICAgICAgICAgKiBAbWV0aG9kIF9tYW5pZmVzdFF1ZXVlXG4gICAgICAgICAqIEB0eXBlIHtMb2FkUXVldWV9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTcHJpdGVTaGVldExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuICAgIHZhciBzID0gU3ByaXRlU2hlZXRMb2FkZXI7XG5cbiAgICAvLyBzdGF0aWMgcHJvcGVydGllc1xuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3MgdGhhdCB0aGUgbWFuaWZlc3QgaXRzZWxmIHRha2VzIHVwLlxuICAgICAqIEBwcm9wZXJ0eSBTUFJJVEVTSEVFVF9QUk9HUkVTU1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4yNSAoMjUlKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MgPSAwLjI1O1xuXG4gICAgLy8gc3RhdGljIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcbiAgICAgKiB7eyNjcm9zc0xpbmsgXCJUeXBlcy9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5TUFJJVEVTSEVFVDtcbiAgICB9O1xuXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICBwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5BYnN0cmFjdExvYWRlcl9kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX21hbmlmZXN0UXVldWUuY2xvc2UoKTtcbiAgICB9O1xuXG4gICAgLy8gcHJvdGVjdGVkIG1ldGhvZHNcbiAgICBwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2l0ZW0uY2FsbGJhY2s7XG4gICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05QTG9hZGVyKHRoaXMuX2l0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OTG9hZGVyKHRoaXMuX2l0ZW0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY29tcGxldGVcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kUHJvZ3Jlc3Mocy5TUFJJVEVTSEVFVF9QUk9HUkVTUyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZE1hbmlmZXN0KHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcInByb2dyZXNzXCI6XG4gICAgICAgICAgICAgICAgZXZlbnQubG9hZGVkICo9IHMuU1BSSVRFU0hFRVRfUFJPR1JFU1M7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih0aGlzLnByb2dyZXNzKSB8fCB0aGlzLnByb2dyZXNzID09IEluZmluaXR5KSB7IHRoaXMucHJvZ3Jlc3MgPSAwOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZFByb2dyZXNzKGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5BYnN0cmFjdExvYWRlcl9oYW5kbGVFdmVudChldmVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgaW1hZ2VzIG9uY2UgdGhlIFNwcml0ZVNoZWV0IEpTT04gaGFzIGJlZW4gbG9hZGVkLlxuICAgICAqIEBtZXRob2QgX2xvYWRNYW5pZmVzdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICBpZiAoanNvbiAmJiBqc29uLmltYWdlcykge1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5fbWFuaWZlc3RRdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUodGhpcy5fcHJlZmVyWEhSLCB0aGlzLl9pdGVtLnBhdGgsIHRoaXMuX2l0ZW0uY3Jvc3NPcmlnaW4pO1xuICAgICAgICAgICAgcXVldWUub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHF1ZXVlLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCwgdGhpcyk7XG4gICAgICAgICAgICBxdWV1ZS5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MsIHRoaXMpO1xuICAgICAgICAgICAgcXVldWUub24oXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdEVycm9yLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChqc29uLmltYWdlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQW4gaXRlbSBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJfbWFuaWZlc3RRdWV1ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBoYXMgY29tcGxldGVkLlxuICAgICAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgaW1hZ2UgPSBldmVudC5yZXN1bHQ7XG4gICAgICAgIGlmIChpbWFnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2VzID0gdGhpcy5nZXRSZXN1bHQoKS5pbWFnZXM7XG4gICAgICAgICAgICB2YXIgcG9zID0gaW1hZ2VzLmluZGV4T2YoZXZlbnQuaXRlbS5zcmMpO1xuICAgICAgICAgICAgaW1hZ2VzW3Bvc10gPSBpbWFnZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2VzIGhhdmUgY29tcGxldGVkIGxvYWRpbmcuIFRoaXMgdHJpZ2dlcnMgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG4gICAgICoge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZnJvbSB0aGUgU3ByaXRlU2hlZXRMb2FkZXIuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RDb21wbGV0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldCh0aGlzLl9yZXN1bHQpO1xuICAgICAgICB0aGlzLl9sb2FkZWRJdGVtcyA9IHRoaXMuX21hbmlmZXN0UXVldWUuZ2V0SXRlbXModHJ1ZSk7XG4gICAgICAgIHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2VzIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG4gICAgICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RQcm9ncmVzc1xuICAgICAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHAuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IGV2ZW50LnByb2dyZXNzICogKDEgLSBzLlNQUklURVNIRUVUX1BST0dSRVNTKSArIHMuU1BSSVRFU0hFRVRfUFJPR1JFU1M7XG4gICAgICAgIHRoaXMuX3NlbmRQcm9ncmVzcyh0aGlzLnByb2dyZXNzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQW4gaW1hZ2UgaGFzIHJlcG9ydGVkIGFuIGVycm9yLlxuICAgICAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RXJyb3JcbiAgICAgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9oYW5kbGVNYW5pZmVzdEVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVlcnJvclwiKTtcbiAgICAgICAgbmV3RXZlbnQuaXRlbSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgfTtcblxuICAgIGNyZWF0ZWpzLlNwcml0ZVNoZWV0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNWR0xvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBjb25zdHJ1Y3RvclxuICAgIC8qKlxuICAgICAqIEEgbG9hZGVyIGZvciBTVkcgZmlsZXMuXG4gICAgICogQGNsYXNzIFNWR0xvYWRlclxuICAgICAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG4gICAgICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTVkdMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLlR5cGVzLlNWRyk7XG5cbiAgICAgICAgLy8gcHVibGljIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cbiAgICAgICAgLy8gcHJvdGVjdGVkIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJkYXRhXCI7XG5cbiAgICAgICAgaWYgKHByZWZlclhIUikge1xuICAgICAgICAgICAgdGhpcy5zZXRUYWcoY3JlYXRlanMuRWxlbWVudHMuc3ZnKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRUYWcoY3JlYXRlanMuRWxlbWVudHMub2JqZWN0KCkpO1xuICAgICAgICAgICAgdGhpcy5nZXRUYWcoKS50eXBlID0gXCJpbWFnZS9zdmcreG1sXCI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU1ZHTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG4gICAgdmFyIHMgPSBTVkdMb2FkZXI7XG5cbiAgICAvLyBzdGF0aWMgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuICAgICAqIHt7I2Nyb3NzTGluayBcIlR5cGVzL1NWRzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuICAgICAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5TVkc7XG4gICAgfTtcblxuICAgIC8vIHByb3RlY3RlZCBtZXRob2RzXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIFNWRyBmaWxlcy5cbiAgICAgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcbiAgICAgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgICAvLyBtaW1lIHNob3VsZCBiZSBpbWFnZS9zdmcreG1sLCBidXQgT3BlcmEgcmVxdWlyZXMgdGV4dC94bWxcbiAgICAgICAgdmFyIHhtbCA9IGNyZWF0ZWpzLkRhdGFVdGlscy5wYXJzZVhNTChsb2FkZXIuZ2V0UmVzdWx0KHRydWUpKTtcbiAgICAgICAgdmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3ByZWZlclhIUiAmJiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRhZykpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGFnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4bWwuZG9jdW1lbnRFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0geG1sLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgbG9hZGluZyBhbiBTVkcgZnJvbSBhIGRpZmZlcmVudCBkb21haW4gaW4gSURcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5pbXBvcnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmltcG9ydE5vZGUoZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICB9IGVsc2UgeyAvLyBGb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IFNWRywganVzdCBnaXZlIHRoZW0gdGhlIFhNTC4gKElFIDktOClcbiAgICAgICAgICAgIHJldHVybiB4bWw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY3JlYXRlanMuU1ZHTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTVkdMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYTUxMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gY29uc3RydWN0b3JcbiAgICAvKipcbiAgICAgKiBBIGxvYWRlciBmb3IgQ1NTIGZpbGVzLlxuICAgICAqIEBjbGFzcyBYTUxMb2FkZXJcbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cbiAgICAgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFhNTExvYWRlcihsb2FkSXRlbSkge1xuICAgICAgICB0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5UeXBlcy5YTUwpO1xuXG4gICAgICAgIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuICAgIH07XG5cbiAgICB2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChYTUxMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcbiAgICB2YXIgcyA9IFhNTExvYWRlcjtcblxuICAgIC8vIHN0YXRpYyBtZXRob2RzXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG4gICAgICoge3sjY3Jvc3NMaW5rIFwiVHlwZXMvWE1MOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5UeXBlcy5YTUw7XG4gICAgfTtcblxuICAgIC8vIHByb3RlY3RlZCBtZXRob2RzXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIFhNTCBmaWxlcy5cbiAgICAgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcbiAgICAgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcbiAgICAgKiBAcmV0dXJucyB7WE1MRG9jdW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVqcy5EYXRhVXRpbHMucGFyc2VYTUwobG9hZGVyLmdldFJlc3VsdCh0cnVlKSk7XG4gICAgfTtcblxuICAgIGNyZWF0ZWpzLlhNTExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoWE1MTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpOyJdLCJmaWxlIjoidmVuZG9yL3ByZWxvYWRqc18wLjYuMi5taW4uanMifQ==
